Testing. That's what the.
All righty. Hello and welcome today to, of course, to 
B, let's go ahead and dig in. And as I mentioned on Monday, I really appreciate you quieting down really quickly, as I mentioned on Monday.
I do like to start right at and I'll ask that you quiet down.
And if I can like if I don't mind if you whisper through a class, but if I can hear you up here, it's probably disrupting students around to you.
And it's also just a bit distracting for me. If I can hear people while I'm trying to keep my thoughts organized.
Some announcements before we dig in to C++ material today.
So first of all,
we're going to try to execute what we refer to as the waterfall strategy for ingress and egress as we transition from this class to one,
two, six eight, which has the classroom after us.
And so the waterfall method is just imagine you're a waterfall, you would just flow down this way and then exit through that door over there.
And if you were a waterfall, you'd be able to read and know that's not an exit, so you won't go that way.
So the to B instructor is asking his students to come in through this back doors out there,
and that way they can start to come in as we're going out.
So we'll try that for this first week as things are really, really crowded and people are kind of figuring their strategy there.
We do have a couple upcoming deadlines. You can raise their hand and tell me what's one deadline that you have coming up really, really soon here?
What's one thing you have to turn in? When is it to go for it?
What does it. Yeah.
Assignment zero is due Friday p.m. What other thing do you have to do?
What big upcoming deadlines do you have yet to work with? Zero.
Yeah. Quiz zero. The syllabus quiz is due. When is the syllabus quiz?
Do everyone just shout it out? Yeah. Friday p.m.
What percent of your grade is it worth to What should you do?
If you've used two attempts on that quiz and you're not % sure what the right answers are before burning through that third attempt?
Since it counts for % of your grade, you should ask for help.
Very, very good. Come to office hours, catch us after class, whatever the case may be.
What else do you have? I mentioned it that it's opening up this week.
There's something you're going to have to do,
and then there's a deadline coming up pretty soon for that other thing that you have to do because they won't remember that other thing.
It happens tomorrow, actually, that starts. Yeah, what's up?
So yeah, if we if we can kind of just calm down with the chatter here, just everyone can hear as we're going through all of this.
So Yes. Sign up for section begins tomorrow and that's going to be due Sunday at p.m.
And then the coordinators who oversee the section leading program are going to
have a mad scramble to put you into a section that works with your schedule,
send that information out to you, and then section starts next week.
So that's kind of where we are right now. And then beyond that, it's just time to dive into some material.
I'm going to teach you all of C++ in minutes today. So it's a tight agenda.
We're going to move at an aggressive pace as you're as you're working on projects this quarter, as you start things out with the cute creator,
one of the things that you'll do is either download an assignment starter pack of code that we have for you As we release assignments,
we'll probably release your first actual programing assignment Athis Friday after we've covered some more C++ material.
But if you just wanted to start a project with the Q creator, the thing to do is to go to the course homepage,
click on resources, and then when you scroll down here with an icon, buy it.
So it kind of stands out. There's this blank, cute project that you can download.
I've already actually downloaded that here to my desktop, but I'll just go ahead and replace that.
When you download that project, then you can go ahead and unzip that folder on your desktop.
And I want to walk you through how I already have this over here. Let me delete the folder so it doesn't actually conflict with anything there.
So when I want to walk you through is this whole process of like,
how do you get a project started, show you the cute creator and show you a lot of code today.
So when I open this up, I have two files in here. One is main copy and then another one is rename me Not Pro.
This is your project file. You might give it a name for like whatever project you're working on.
Today's project is Mayhem. We just have a barrage of information coming at us today, and then when you open this double click this profile.
If you've got the Q t creator installed, you'll get this configuration page that pops up.
Really, everything should be configured for you already.
What you want to do is just click this configure project button over here to the right and that configures your project.
And this is your idea to open files. Then in this little menu bar here on the left.
Let me zoom in on that for you over here. You'll just double click the project name.
And under there you have that project file that I just showed you.
This has a lot of settings that creator is using to figure out how to compile and run your projects, get your code working and whatnot.
And then under here we have a source this folder, so I'll just double click that and there's that may not copy that was back here.
If I can open that folder for you that was back here in this folder, it automatically populates here in the project.
So I'm going to double click main copy and now I've got this file open.
This is where I'm going to write all my code is may not copy.
So that's the start up kind of process that you'll go through as you're starting a project here.
It'll start with some some starter code. You've got a template here. You can go down to this main function and start writing code.
What I actually want to do is pull back that code that I showed you the end of class on
Monday and put that in here and just spend basically the rest of the rest of the day.
I want to spend a lot of time explicating what's going on in this code and then teaching you some more C++, adding some features to this code.
But I'm going to dig in and show you what each component of this code is doing,
kind of unpack those things for you and then give you some new C++ knowledge as I go
through to terms that I want you to be familiar with as I go through and talk about stuff.
There is syntax not in caps, though. I'm not going to shout out you syntax and semantics.
So syntax with syntax, whether it's in a programing language or a natural language,
and by natural language I mean spoken written languages like English, Spanish, Chinese, so on and so forth.
The syntax is the rules of a language. So if I write a sentence like this, the picture of Dorian, who maybe I'll get the capitalization right.
Dorian Gray was on the shelf by the Count of Monte Cristo.
The syntax here is stuff like I had a period at the end of the sentence or, you know, the picture of Dorian Gray is a noun.
Phrase was is a verb. On the shelf is a prepositional phrase.
By the Count of Monte Cristo is a prepositional phrase.
I don't know if you're panicking and you're like, Whoa, where was like English when I want to react to this class?
Is this something we need to know? Don't worry, I'm not going to barrage you with a whole lot of English stuff this quarter.
This won't be on your well, this will be on your midterm. So, you know, brush up on noun phrases.
And the Count of Monte Cristo is a noun one. That's the syntax.
The fact that we have a grammatically correct sentence structure going on here.
Semantics. Does anyone know what semantics refers to? You can just shout it out if you know what the word semantics is.
It's it refers to. Yeah.
You people nervously are saying the correct thing up here. Yeah, it refers to meaning.
So the meaning of the sentence, the semantics behind it.
I mean, we've got the syntax, all the rules that we use to create a grammatically sound sentence.
But the meaning behind this, you know, you're not looking at this probably and thinking, oh, there's a picture that's on a shelf.
And the picture had some person named Dorian Gray. And also on the shelf next to that picture was some old count whose name was Monte Cristo.
You know that actually what's going on in this sentence is you have a book called The Picture of Dorian Gray,
and it's sitting on a shelf next to another book called The Count of Monte Cristo.
So when we talk about semantics,
we're talking about meaning reading a sentence that's grammatically structurally sound and inferring meaning from that.
And the reason I'm introducing these terms to you is because this is what we do when we learn a programing language.
We we introduce to you a the syntax for all the different things that the language can do.
What are the rules for how you're going to construct syntactically correct statements
that are actual valid code that will run and do the things that you want?
And then we talk about the semantics behind those things. So when you type X-Y-Z, the semantics are what does that mean?
What does that cause that to do? So we use those terms frequently over these next couple of days.
And I just wanted to be sure that I wasn't throwing those out. You're like, What is the difference between syntax and semantics?
What's he talking about here? So syntax and semantics is what's going on there.
I'm the one of the term repeat over here as if I was already on the next the next thing you ever hear.
Okay, so let's go through and start talking about what some of these things are here. So upfront here,
I have some include statements and the syntax for that is I type pound include and then I give some sort of library that I want to pull into my code.
So the IO stream in the console that H those are indeed referred to as libraries.
And just like libraries in the real world which have books and all kinds of information,
knowledge that you can go capitalize on a library in the coding world is a bunch of preexisting stuff that you can pull into your project.
A lot of functions that have been written for you to use that you can just pull into your project.
Those are organized into different libraries. So here the syntax that I'm going to pound include a library, and there are two types of libraries.
So when I use these angled brackets to pull a library into my code like I'm doing on line seven here to pull
the IO stream library in the angled brackets signify that that library is something that's built into C++.
It's part of just the standard goodies that you get with the C++ language.
This is part of the core functionality of the language. When I use instead the double quotes as I'm doing on line eight.
The double quotes mean that that's some sort of homebrewed custom not built into C++,
but some extra thing that someone created outside of the standard definition of what the language includes for us.
So online aid, I'm including in quotes this console that h that is something that's not built into the Stanford C++ or into the regular C++ libraries.
It's something that actually comes from the Stanford C++ libraries.
So I mentioned on Monday we have a bunch of extra goodies that we've created in C++ that you can import into
your projects that will unlock all kinds of functionality so you can focus on solving interesting problems,
writing interesting code that does neat things, and not worrying about defining a lot of functionality,
like creating a graphics package from scratch in your second quarter of ever programing.
So that's the distinction here. Now, in all of the assignments that we give you this quarter, we will have those includes baked in for you.
When you download that starter code, you don't need to memorize like oh IO stream console that H How am I going to remember those?
What functions come from each of those things? We'll have those there for you. But I want you to know when I type those.
That's the distinction there. So these are our libraries. That's what we've got going on there to begin with.
So the other thing that I've got going on straight away is I have lines of code on seven through 
I don't know why it's is that point line over there on lines one through six.
I'm writing basically English statements that have turned green. What does that call it?
When we write English statements in our code that aren't really part of the code that's going to get executed and run?
You can just shout it out. Yeah, these are comments.
And so the comments are not for the compiler when when your program is executed, when it's turned into into a program and executed.
These are basically stripped away. Comments are for human beings.
They're written to help us understand what's happening in code. And there are two pieces of syntax that you can use to create comments in C++.
One of them is what I'm doing here just slash, slash, and then you write whatever you want.
And when you reach the end of that line with the slash, slash and go on to the next line,
the next line is no longer part of a comment unless you put a slash that on that line also.
So you'll see on line six that slash, slash, everything turned green there.
That's signifying that this thing is a comment. And then on the next line, that's not a comment, that's actual code.
The other syntax for writing a comment in C++ is this You can do a slash star and be like, this is a comment like that.
And when I notice actually when I typed Slash Star, all of the stuff below this line has also turned green.
So everything right now is the idea is telling us everything right now is considered a comet When you type slash star,
everything after that, throughout the entire file is considered a comet until.
You hit a correspondent. So like you can write a multiple and comment like multi-line comment neat until you type down here a star slash and you could
even do here you could to about it let me actually just do blah blah blah and put the star slash over here so check this out.
Like without that star slash everything is green.
And as soon as I do the star slash boom, everything after that line, after that star slash is code again.
So from the beginning of slash star all the way to the end of Star Slash, that's a comment.
That's just another way that you can do comments. You don't need these asterisks at the beginning of each line.
The q t creator just puts those there to kind of format these multi-line comments nicely.
I actually you won't see me using in class this style of comment this quarter.
I have a strong preference for this style of comment for reasons that I don't have time to discuss,
but I'd be happy to proselytize the slash slash style comments.
If you'd like to discuss after class. At some point you can use either one in your projects.
I just have a strong preference for this one for kind of side reasons that I that I just don't have time to get into today.
So that's what's going on there. Then we have this thing saying using namespace steady with a semicolon after it.
I'm going to talk a little bit about what namespaces are in C++.
And let me preface this by saying all you really need to know out of the next couple of minutes of what I'm going to say about using namespace.
Steady is type of that line in your code. We're going to do that this quarter.
So the next thing about virtual is just supplemental information, and I never would.
The reason to tell you that up front is I never want to bamboozle you where I tell you something.
And then after minutes, I'm like, You don't really need to know that. I'm just sharing that for your personal edification.
And then you're like, Oh, I don't know when I can trust this guy and when he's telling me important things.
Everything I say is important. All of it is on the exam. Unless I give you a disclaimer ahead of time that it's not,
probably I'll say things that aren't important, but that's how I help myself sleep at night.
I tell myself that I'm sharing important things with you anyway, so using namespace STG, C++ organizes functions into these things called namespaces.
And here's what this is all about as you're creating large scale software, whether you're working on a personal project or an industry somewhere,
We often import libraries, as I mentioned, with those include statements up above.
We include libraries that have pre-written pieces of code that we can capitalize on.
So you can imagine that someone wants to write a program that needs to connect to a computer over a network.
And so they go in and they find a really great library and they include that in their code.
I'm going to call this just fantasy networking, and I'm putting fantasy in front of it.
So, you know, this isn't an actual C++ library, but there are network libraries out there.
I'm just making this one up for the sake of discussion. And maybe that same program that someone's writing,
they want to have a database where they store a bunch of information about users who are logging into their system.
And so they find a good database package library called Fantasy Database H and they import both of those into their program.
The problem with importing multiple libraries into your code is they might have functions in them that have the same name.
So it stands to reason that if we import a library that's going to allow us to establish network connections,
there could be a create connection function in this library that we want to call to create a connection to some computer over our network.
And there could also in this database library be a create connection function that we're
going to use to create a connection to a database and read and write from that database.
The problem with that is if there are two functions named create connection.
We can't get our code to work in C++ because C++ will be like, Well, which one are you trying to call here?
There are two things with the same name. This is not allowed in C++.
Now, C++ knows, though,
that people are going to publish libraries in the real world and use whatever names they want for the functions that are creating.
And there are going to be libraries that have conflicting names across libraries.
So what C++ does is it gives people the power to organize their functions into what we call a namespace.
It's a way of saying all of the functions over here from this library.
They belong in this space over here, and all the functions from this other library belong in this space over here.
And when you want to use them, what you do is you put the namespace they belong to in front of them.
So maybe this fantasy network thing has all the functions belong to a namespace called Nat,
and so you do Nat Colon Colon to say from the networking namespace where all those cool network functions are used that connect,
create connection function. And down here the database library might use a DB namespace to put all the database functions together,
and so in front of that thing you would type DB colon,
colon and say the function that I'm calling you, the connection specifically is the database version of that thing.
And so all of the goodies that are built into C++, a lot of those goodies are in the namespace called STD,
so that if you're writing code and you create a function that has the same name,
it's something in the in the in the standard namespace that it's not conflicting with that thing over there.
If you remove this line using namespace STD, check out what happens over here.
In fact, when I try to compile and run, I don't know if you can see this down here.
It's like see out at the very bottom of the screen. It was not to. Clifford.
Did you mean STD? Colon. Colon. See out. And the thing there is see out is defined in the standard namespace.
So one way to use that is to do STD. And then here, STD colon, colon like that.
And so we have to dress these things up with. And if I give this a run over here, it's like, okay, that actually works.
But that's really tedious to type STD. Colon. Colon in front of everything that's built into C++ that you want to use in your programs.
So we don't do that. And the syntax for telling your programs like, Hey, all this stuff that I'm referring to,
if it's not defined locally in this file, look in the standard namespace and see if it's there.
The way to tell C++ to do that is to say using namespace STD.
And now I can compile and run this program without the STD colon colon in front of the C out and the end there.
So this is just a way of saying everything that I'm using is from the standard
namespace and actually all the C plus plus stuff from the Stanford C++ libraries.
We've put that in the standard namespace as well so that when you go to compile and run your programs,
it'll pull stuff in from the standard namespace and know where to look at those functions. What namespace there in there.
By the way, when I want to compile and run a program, I could go down here.
The button is down here in the left side of the screen. I can do this little play button.
I can hit that in order to compile and run my program.
The other way to do it, the hotkey that I'm using over there, and actually if I hover over this,
it'll tell me the key is Control R and it probably behooves you to at some point this quarter,
learn some of those hot keys when you want to compile and run a program.
What you don't want to do is you're typing code, typing code, typing code,
and then you move your hand to your mouse and then you move the mouse to bring your cursor to that run button.
And then you click the button and then you move your hand back to the keyboard.
That is so painful and slow.
If you do that every time you want to compile and run a program this quarter, by the time you reach the end of the quarter,
you will have wasted entire minutes of your life just moving your hand around unnecessarily as opposed to going control.
R And you don't need to move your hands away from the keyboard at all. That just runs the program right away.
So and then if you if you dropped that over the course of your lifetime, by the time you die,
assuming you live a long, happy life and you don't get hit by the Marguerite tomorrow,
by the time you die, you will have saved entire hours of typing or of moving your hand around to your mouse and whatnot.
And also typing said colon, colon. And so these are just things to kind of optimize your productivity and leave you more time for.
I don't know what you do in your spare time.
Doomscrolling worrying about the housing market, worrying about the tech collapse, worrying about climate change.
Tick tock. So whatever the case may be, and as I say that I don't know if you're experiencing as existential dread right now, but come back.
Come back here in one in six be And it's safe here for now. The outside world is sequestered away outside these walls.
Okay, let's continue moving forward from here. This next thing that I have down here is a function.
I've defined this function called main. Oh, and by the way, I was I was writing comments earlier.
One of the things I want to mention about comments is we generally use comments to either explain a complex,
lengthy piece of code like what's happening or what that piece of code does or why we're
doing something that maybe wouldn't be apparent to someone who's reading our code.
And so what I don't want you to do is you're using comments this quarter to do stuff like this and be like, this is a function smiley face and like.
This prince. Hello world to the screen.
And this is my least favorite here. And a function like this, all of these comments are unnecessary.
You can trust that the people reading your code this quarter know that these are the primary components of code and whatnot.
We want our code comments to actually explain what's happening in our code or
explain lengthy chunks of code or explain why we're doing particular things.
And I'll have a little write up for you in today's section of notes that you can see.
Like, here is just an overview of me, like five bullet points of like how and when to write good comments in your code.
But this is kind of a learning process. And what will happen is your sales who grade your programs.
For some of those programs, they'll have one on one meetings with you, and that's where they'll talk to you about comment style and they'll approach
that and really like non punitive way in terms of how they create that and
give more qualitative feedback at the beginning of the quarter as we kind of
indoctrinate you to our standards in terms of what good comments look like.
Anyway, down here we have this thing called this is the main function down here, so I'm going to write a really bad comment, main function.
So don't follow this type of comment.
This is just an educational like in case someone hasn't seen a main function before or kind of like what's going on here.
So indeed,
our code in C++ is broken up into different functions and functions do in in programing languages functions do effectively the same kind of thing,
or they're really similar to what the kinds of functions that you learned when you were first learning functions in grade school,
probably kindergarten. First grade is where you were learning like F of x equals X, where someone was like, What was I supposed to do?
Now? I'm just kidding. The collapse of the American education system Insert comment here.
So functions in the real world like mathematical functions that you've encountered.
They do a few things. First of all, they take inputs.
So if you have a math function that's like F of x equals x squared, and when I type X squared, that means x to the second power.
So this function takes an input, you feed it X, then it does some work, it multiplies x by x and then it produces a result.
It spits out like if you pass it five,
it spits out the number after multiplying five by five and functions in programing languages do effectively the same thing.
We feed them parameters. So down here, if you have a function that takes parameters, those arguments would go in parentheses.
We would type parameters here and they then do some work.
Those are the lines of code that are happening right here, and then they spit out some sort of value.
And I kind of have a footnote in my head as I say that that says some of them don't actually spit out some sort of value.
And we'll talk about that in a second. But the syntax for defining a function in C++ looks like this.
We talk about what the return type. So what is the type of information this thing is spitting out at us?
We give it a function name and then in parentheses we list off the kinds of parameters and number of parameters that we want that function to have.
Then we use curly braces, opening and closing, and within those curly braces we place a statement or statements statements in C++,
these are lines of code that are terminated with a semicolon.
So this is the basic the basic formula for creating a function in C++.
What C++ does not like is the ambiguity of a mathematical function like this F of x equals x squared.
I haven't defined formally with this function yet. Like what's the domain?
What kind of numbers am I able to pass into this? What's the range that comes out of this?
What's the what are the types of things that this can produce and whatnot?
So C++ does not like that. It wants to know if you have a function, what kind of data could that spit out?
So if I write a mathematical function to square numbers and I'm only ever feeding it integers,
integers, remember our whole numbers like negative one zero one,
what kind of data can come out of a function that is squaring something and it only ever receives integers, It would spit out integers.
Also, what kind of restriction would you place on that? Actually, what kind of integers would it spit out like a little bit more specifically?
Yeah. Non negative integers. Very good. It would never spit out a negative integer if you were just feeding it a regular integer to begin with.
Very good. So C++ wants to know kind of what's being spit out by a function.
So this main function here, what's being spit out by this function is an integer,
and that's signified by this return statement down here when you type return and then a value semicolon in C++ that leaves the function you're in.
And this is the value that that thing is emanating.
So just like F of five with this function, F that if defined here, it would emanate the value that's five squared.
Similarly here, when I'm finished running main, it emanates the number or emits the number zero.
And you might be looking at where does that zero go?
What's happening here and what's happening with Main actually is when you run a program in C++, Main is special.
The compiler. Oh man, I need to mention this also.
So C++ is a compiled language when you want to build a C++ program, unlike Python, which is an interpreted language.
So if you've used Python as your primary language before,
you've probably opened up like an interactive terminal where you type lines of code and as soon as you hit enter,
like a line of code will be executed and run for you. It's being interpreted in real time in contrast with C++.
We write all of our code and then we transform it into a program that we can execute, that we can run.
And so that process is called compilation taking code and transforming that into an actual program that we can run.
That's called compilation.
Now, when you compile a program, the C++ compiler starts at the very first line and it goes line by line through your program,
checks that your syntax is good and starts to assemble the program for you.
But once you've compiled your program and you run the program, C++ does not just start at the first line and march through every line of your program.
What C++ does is it looks for a function called Main and it jumps straight to that function.
And that's the first thing that gets executed when you're actually running your program.
And Main is a special if you don't have a function called main.
If you just have something called side dish instead of main and I try to compile and run this program,
you can see down here in red, it's giving me all kinds of errors that it can't find main.
So you need to have a function called main, and that's the first thing that runs.
So that returns zero line that says when your program is running and we hit the end of
Main that says Main is finished and I'm returning control back to the operating system.
And when I return that number zero, it's the operating system that catches that zero from Main and takes a look at that.
And that zero means, Hey, this program ran fine.
We encountered zero errors as we were going through.
So you always want to return zero from Main to indicate that it compiled and ran successfully is what's going on there.
And by the way, in curly braces here, this is called a code block.
And within every code block, when you open new code block, we indent our code in C++.
So this is a terrible thing about C++ and a lot of languages.
If you've just program in Python before, this might take you by surprise.
In Python, you have to indent your code like that's how you signify to Python.
Like this line of code is part of this function or it falls underneath the scope of this poor loop that I have up here, or whatever the case may be.
In C++, you can do wild stuff like this. You can just be like, La la la la.
Curly Brace goes way over here, and when I hit Control R, it runs just fine.
This should strike fear in your hearts when you look at code like this.
If you're looking at this code and being like, I don't know, it looks fine to me, we need to touch base on office hours right away.
This would look alarming to you in C++. White space is for humans, not the compiler.
Whitespace makes our code more readable to other people.
And by the way, if you ever have whitespace that's gotten out of control like this with the cute creator, you can highlight that.
And if you right click you'll see there's an option here too.
Where did it go to fix the indentation Auto Adjust the selection right here.
It says the key for that is control eyes of hit control eye boom.
It fixes that indentation and then you can just eliminate all of these extra blank lines here like that.
So that's what's going on there. This other line of code of the main event is line on line 
What I have is this thing called see out, which is a stream.
This the stream is hooked up to your terminal.
And this is just a kind of a synonym for where output is going to go.
That my program is printing and the syntax for using this as you type C out,
that's the place where I want my output to go is just the standard place where output goes in a C++ program.
And then I have these two little arrows and you see those little arrows are kind of pointing to C out that's saying the stuff that I am that
I have on the rest of the line I want to go over here to see out which is hooked up to your terminal that's going to print to the screen.
The thing that I have after that, in double quotes,
do you all know what it's called when you have a bunch of characters strung together in double quotes?
It's a it's a string. Very good. So this is a string sometimes refer to it as a string literal.
It is literally the characters HELOC on and so forth.
And then after that string, I have another little arrow. Arrow.
And this here says, I want to go to the next line, print a new line character after this.
So I give this a compile. Then I have Hello World. Watch What happens if I remove this now?
I mean, there's no difference here that you can discern when I run this program without that.
And but if I put another thing here that I'm just like code array C is to B like this,
you'll see that these lines just run together right after my Hello world.
I have her C one of six B In order to prevent that, what we do is and l like this says go to the next line after each of these pieces of output.
So when I give this a compile and run again, everything is on its own little line there.
So the end are all following that idea and all this takes me to the next line.
It's a little signifier. I'm getting a lot of knots from that. Very, very good. Okay, so that's what's going on there with all of that stuff.
That's what all of those components are.
So what I want to talk about next then is just give you the syntax for a lot of things that you've seen in other languages and how those work in C++,
variable declarations, loops, writing, other functions, things like that.
So let's start with the variable declarations.
And if you've used Java as your primary language before, remind me again how many of you are primarily Java users?
How many of you are primarily Python users? Python's the dominant language.
If you've used Java before, a lot of stuff in C++ is very similar to that if you've used Python.
This is already diverging from what you're used to in terms of like white space doesn't matter anymore.
I mean, it matters to me and it matters to your grade. I'm assuming you care what you're going.
The the curly braces are new in terms of defining the body of a function.
By the way, what did I call that? When you have curly braces, I call that a code block.
Very, very good. And what do we do? Anytime we open a new code block to the code, we indent it.
Very, very good. Okay, so let's do some variables you're used to.
If you've used Python, you're used to doing something like this. And Python is like, sure, I'll set equal to the number five.
C++ is like, Nah, C++ doesn't like the ambiguity of you just saying equals five.
And it's like, let's say I've never heard of it before. No one told me it was coming. Where do they come from?
What is it? And then it panics and freaks out and doesn't compile and you get red squiggly underlines elsewhere in your code.
If you want to use a variable in C++, you have to first do what we call a variable declaration.
You have to declare its existence. So the declaration, the syntax for that is you say the data type,
what kind of information you're going to hold in your variable, and then a variable name, variable name like this.
So if I want a variable that can hold just a whole number, an integer,
the syntax for declaring that in C is to just say int that says we're using an integer and then the variable name is a So I'm declaring it.
I'm saying Behold C++, I have created a variable A and its fundamental nature is it is an integer.
And then I can do a equals five. What's bad about line ?
Based on what I've told you so far about all statements in C++, you just shout it out if you see it.
Yeah, it's missing a semicolon. Statements must be terminated with a semicolon.
Okay, so this is valid C syntax online I've declared my variable A and then on line 
Now it's now line I've initialized A initialization is when you give something its initial value and if you want to print that to the screen,
you can use that with the C out stream.
You could do something like this, you could do it, put a space here and then put a the variable A and just put arrows around that.
So this is like, Hello world is going to the screen that A is going to the screen and then a new line is going to the screen.
And if I give this a compile and run what hockey did I say that I'm pressing when I compile and run it's control R to run the program.
Very good. And what you see is this number actually got printed to the screen that oh no, you can't see the number up into the screen there.
That number five, here's what you can't do.
Here's let me say this. You can do declaration and initialization on the same line.
That's totally fine. You could combine those if you want. That puts the number seven in there.
Everything's fine. You can also change a later to be like the number six instead of the number seven.
So when I compile this and run, you see that we're getting the number six. That's fine.
What you cannot do though then is be like eight equals. Hello.
Like that. If I try to compile this and run, I'm getting a compile error at the bottom here that says you're trying to convert.
This is C++ a way of saying you're trying to put a string into an integer. It's a type mismatch.
You told me that thing was going to hold a whole number. You're trying to put a string in there.
I'm really confused and alarmed by what you're doing in life.
And so if you have programs in other languages, you might be tempted to do this, be like, Well, I want this to be, and then change the data type.
And another data type I introduce you to here right now is there's a string data type built into C,
So maybe like, let me just do that there and I'll change it to a string.
And again, when I compile and run, it's yelling at me down there and it's saying like, You can't do this online.
You're trying to say A is a string already exists online.
and its data type is immutable.
You cannot change the fundamental nature of a once you've created it within this function so that one goes away there.
So that's just something that you can't do is re declare a variable and change its type.
You also can't do this. You also can't say like down here into a equals five.
I'm re declaring that variable here already exists.
I don't need to put the word int in front of line if I want to set equal five to set eight equal to five, you only declare a variable once.
Let me show you some data types then. So we have ints. These are integers we use to create integers.
You know, these are whole numbers like negative one, zero and one.
We have this thing called a float, which is a floating point number.
So, for example, actually, let me just do this down here. So let me do float F equals like that.
So floating point number has decimal precision after it, whereas the int does not a double.
Oh no. What did I just do? A double is a floating point number like this and I'm sorry I can't use that.
I'm reusing this variable name here. Let me use D like that.
The difference between a float and a double, it's actually the double takes up twice as much memory as a float.
And you don't need to know that for the purposes of this class. That's something you'll learn in one of seven if you're going to take that class.
But basically the double because it's using more space in memory,
you can get more decimal places of precision with the double more information after that decimal place.
And so some people just use the double in their daily lives and never use a float if you want a single character.
So let me call this char C, a single character we use. Char for that in in C++.
And if you want to put the character Q in this variable,
you can't just say cha c equals Q This isn't going to work because C++ thinks this naked variable,
but this naked Q like that must be some other variable. It's like, what is this variable? Never seen it before.
You have to put the Q in single quotes to say that I have a single character over there like that.
Now, if I let me just compile and run and show you some of these things working over here.
So in addition to a let me put a space after that and then print out F and then A space after that and print out this,
this character C and give that a compile and run. And you see that it's printing all of these things to the screen.
These are all getting put in there just fine. And then I also mentioned already there's a string variable to string as equals.
Hello, like that. And so we could put that at the end over here instead of C the string s and we'll get another hello over there like that.
So that's, everything's going totally okay there. So those are variables.
And oh, another common pitfall with variables is people will sometimes in C++ try to create a variable like C,
you know, I've already used C, let me just create X and then I'll try to print X to the screen.
And one of the things that you like, I haven't put a value in X, so by default in C++,
if you don't put a value in X, it just contains some random thing.
There's no guarantee what it is. And so we should never just start to use a variable in C++ that we haven't put a value into.
This is an unofficial variable. And actually if I try to run the program right now, you'll see I get this error down here.
It's just like, I don't know why my system won't let me. You can barely see at the bottom here.
X may be used on initialized and it's not letting me run the code because it knows that I'm trying to use X without having given its initial value.
And so when you download that blank queue to create a project from your website that will actually it has a flag built in that ensures that if
you didn't initialize a variable that your program won't compile and run in the real world when you're not using the blank starter project,
if you just open a C++ project and say index and then try to print it to the screen,
that will compile and run and it will just print some random value to the screen that X contains.
So the blank project has some guardrails on it to kind of make your life easier so you don't
have to worry about errors like that as you code and work your way through this quarter.
So those are some data types right there. I've talked about initialization.
We've talked about all kinds of crazy stuff out there.
Let's switch gears and talk a little bit about loops. How many of you have seen loops before?
I need to know if you've been okay. Has anyone not encountered a loop before?
Okay, I'm not seeing any hands go up. Okay. So this shouldn't be anything really crazy.
So I'm going to kind of go fairly quickly through it. In Python, if you've seen a loop, you've probably seen something like this before.
You've seen like R equals one. And then like while I is less than five and then you want to like print I and then
you want to do I plus equals one and this would be so one is less than five,
two is less than five, three is less than five, four is less than five, five is not less than five.
So this would print one, two, three and four to the screen. The syntax for doing the semantically equivalent thing in C++,
the syntax for a while loop is a bit different in wonky you do while and then in parentheses you do some condition that you want to evaluate.
Then we create what is this called again? With the Codebases everyone, we create a code block.
Very good. And then within here we put our statement or statements that we want to execute while that condition is true.
So let me just transform this for you here. I need a semicolon.
And then on this next line here,
I can do while and put this into parentheses and then do here the curly braces and then intent all of this consistently.
And then instead of print, what do I use to print something to the screen? Everyone just shout it out.
See? Out. Very good. So just print that variable like that followed by Endo and then I can do I plus equals one.
What's bad about the code? So far I've left something out deliberately.
Go for it. Say it louder for that for everyone.
Yeah, I haven't. Yeah. Very, very good to hear you say that.
That's like it. Yeah. I have not declared this. It was initialized.
I was attempting to do it. I hadn't technically initialized it because I hadn't declared it, so it was never going to be initialized.
So. So you. You're right. But, yeah, I hadn't declared it. So let me create that thing over there, and then I will give you this compile and run.
You see, we get the one, two, three, four. It's doing the expected thing there.
Now this plus equals one that you've used in Python a whole lot.
It's a lot of keystrokes. You have to do space shift plus release.
The shift equals space and then a one and then a semicolon.
C++, because it's so common to want to add one to a variable, especially as we're doing what we call iterations of a loop.
Because that's so common. C++ has a shorthand notation for that where after variable you just type plus plus.
Did I just change the syntax or semantics of line ?
Just shout it out the syntax. I changed what specific symbols I was using to make the thing happen.
Semantically, the meaning is the same as I plus equals one.
This means just add one to this variable over here. And so if I give this a compile run, it actually works and does the same thing over here.
So the name of the language actually C++, it's kind of like a geeky joke.
The predecessor to that language was C, and then we built upon that.
I mean, I wasn't there. I wasn't part of like the ancient council that created C++, but we built upon C and made a iteration on it.
We made a better language. And so C++, we like increment.
You see the nerdy joke built in there. Okay. I also didn't I'm not responsible for that joke.
I don't even know if the joke. Maybe it's worse. Anyway, so that's the way loop there.
There's an analogous thing in C++ called a for loop. Let's write a for loop.
The syntax for writing a for loop is just wild when you first see it.
This the in parentheses here for the for loop. We want three things in order to create a valid for loop.
The first is an initialization statement,
something that we want to execute exactly once as soon as we hit this for loop and only once semicolon, then we put our condition.
We're used to seeing conditions and we put those in parentheses with the Y loop,
and then we have what we call the post iteration statement, something we want to do at the end of each iteration.
If we can actually type at the end of each iteration of our loop.
But before we go back around and check our condition.
And so to change this thing into a for loop here, let me, let me do here.
So for one of the things that I wanted to do before I kicked off this loop was set equal to one.
And so let me just put that in parentheses over here for IntelliJ equals one.
That's something that I do as soon as I hit this for loop and it happens just once right when I hit the for loop.
And similarly up here, it was happening just once. Right before I evaluate my condition for the while loop, Then I put my condition.
I can use the same condition for that loop and then something I want to happen at the end of each iteration.
Well, up here, at the end of each iteration of this loop I was incrementing I so I can actually write that here.
And this for loop. Then what I want to happen in each iteration is print like that.
And this is now semantically equivalent to what I was doing up here with the while loop.
So again, to walk through that, when I hit this for loop, the first thing I do is create I set in equal to one.
Then I say it's one less than five. Yes. So I come into the loop, print that out, and then before I loop around and ask, Is I still less than five,
I do this post increment tation or this post iteration statement where increment eight now becomes two.
And then I ask is two less than five? Yeah. So print it out and then execute this.
The two becomes a three and then I ask is three less than five? Yeah. So print it out, increment it becomes four is for this in five.
Yeah. So printed out increment then I ask is five less than five. No.
And so the loop terminates and that's a for loop and it has that result there.
Now if you're looking at this in your panic and you're like, oh my gosh, this is so much information.
What the heck is going on here? Remember, I will post really elaborate notes for you.
This will release sometime today with all of the details that we've talked about here.
But it's up to you to sit down and work on this and like try to write a for loop.
If you've never written one before,
like close the notes and just try it and see how it feels and make sure you can lock down that syntax without referring back to any notes.
And then you'll be really prepared for next week's lectures.
There's a third kind of loop in C++ that we call a for each loop, or it's sometimes called a range based loop.
And the syntax for this one. Oh, by the way, you might look at this and say, When do I use a for loop?
Well, it's when you have those three things, a single thing that you want to happen before you check your condition, then a condition,
and then this thing that helps you move on to the next iteration of the loop like a I plus plus is then if you have all three of those things,
a for loop might be more appropriate or readable than a while.
Loop the for each loop does this, you create some sort of variable here and use a colon and give it some sort of container.
And what this does is it loops through a container and executes a bunch of statements on the things in that container.
And each element of that container gets bound to this variable that we create in that range base loop.
For example, if I create a string, you might be looking at something. What does he mean by container?
Well, one example of a container like thing in C++, and we'll see more as this quarter goes on.
But one example is a string.
So if I say like string equals giraffe like this, I can say four and I'm going to I want to loop through every individual component.
You know that a string is made up of a bunch of individual characters.
So here, what do I type exactly? To create a character variable?
Everyone I need to type here char h and then I'll give it some variable name like just c h like that.
So this says create a new variable called c h,
and that each iteration of the loop make it equal to the next thing in that container and just go through those things in the container one by one.
So as we go through, let me put that out. See out the character followed by an end.
L So initially C H is going to be a G, then the next iteration of the Loop I.
Then R and so on and so forth. And if I give this a run. We get giraffe and it's nice and tall, like the neck of a giraffe.
Like an actual giraffe. Thank you. One person over here, you can have an A for the rest of.
You're on thin ice. I'm just kidding.
Or am I? I learned last quarter.
So last quarter was actually my first quarter at Stanford.
I transfer to another institution and I had, like, standards, just things that I would say at that institution that were always worth a laugh.
For the past two decades that I've been teaching and just like those things didn't always translate here.
And one of the things that I learned partway through the quarter,
I have like a spreadsheet going off like what you all think is funny already from day one, I'm like, I have notes like, This wasn't funny.
Sean, get a real job.
Keep up on teaching. But any time I, like, threaten people's grades, they're like, Oh, that's hilarious.
Is he going to give me a name anyway? So I'll continue to threaten your grades all quarter long because the people are still giggling at me then.
Okay, So as I go through, that's the that's the Oh, what did let me go back over here to control Run.
What did I call that kind of loop. You can just shout it out if you remember it's a a for each loop or a range based loop.
Amazing. Very, very good. Okay, You're also familiar with conditional statements, so let's just do some quick if else and else if statements.
And I want to show you that syntax for those things. The syntax for if statement is very much like a wild loop.
So we had wild condition the syntax for an IF statement in C++ as you just do if condition instead and if that thing is true, we execute.
So let's do this. INT num cupcakes equals three and I'll say if num cupcakes is greater than zero C out.
Hurray! Cupcakes like this.
And now. And when I give this a compile and run because that number was greater than zero, that piece of code triggers and everything is good.
If you want to compliment an if statement in C++.
So if the if statement does not evaluate to true, you want to do something else,
you type else right after that and introduce a new code block and maybe say something like code.
Oh no. Cupcake, cupcake error for whatever you call that when you don't have cupcakes in life, it's just general sadness.
And so if I set this to like negative three and you have some sort of weird cupcake debt and I give this a run,
well, negative three is not greater than zero. So you say, Oh, no, cupcake error.
I guess it's not good if you have someone three cupcakes. You can also combine these.
So you could say like if not cupcakes, if you want to check if two things are equal to one another in C++, you don't just say equal.
Equal actually sets one thing equal to another. If you want to ask if two things are equal, you use to equal statement.
There are two equal signs to ask if two things are equal. So you can say if not cupcakes is equal to one.
Maybe we would say something like this,
like see out almost out of cupcakes like this and terminate that thing over there and then you can do else if and chain maybe if if it's not one,
but it's actually like greater than zero then we'll say hurray cupcakes.
So we still get cupcake error there. If we have exactly one cupcake, you'll see this first thing triggers.
We're almost out of cupcakes. If we had like five cupcakes, well, that's not one.
So then we check if that's greater than zero, and you'll see. Indeed.
Hurray! We have a lot of cupcakes there. I'm not going to go through all the operators that we have and show you examples of them.
I'll just say we have greater than less than greater than or equal to which cannot be written as equal to or greater than like that.
It has to be greater than or equal to the greater than comes before, the equal to less than or equal to.
And then we have not equal. So if we have that, we could do something like this. Like if num cupcakes is not equal to I would say see out,
not a baker's dozen that you don't have a baker's dozen worth of cupcakes over there like that.
And indeed, that's not a baker's dozen. I also want to introduce you really quickly to these other operators.
The not so this is the not operator, this is the Boolean and operator that gives you a true if both things are true.
And then this is the OR operator and I'm assuming you've seen these before in other classes.
So you could actually do something like this.
You could say if non cupcake is equal to wrap that in parentheses if you put the not operator in front of it.
This is asking, is it the case that it is not the case that num cupcakes is equal to ?
So if not, cupcakes is equal to When you apply a not to that, you get that it's not equal or if you're if it's not equal and you play not to it,
you get a true that they're not not equal to one another.
So this is doing effectively the same thing.
It's not equal to saying take this and if this is true, make it a false and if it's a false, make it a true.
Just invert the logic. And indeed, the store reveals that we don't have a baker's dozen and then you can mix ends and orders in there.
And so you can say if num cupcakes is equal to and making poor life choices, maybe we could say this.
If not, cupcakes is is greater than zero and we're making poor life choices.
And so here's another data type for it's a boolean. You can set it to either true or false.
Let me set this equal to true. We're making poor life choices, by which I mean consuming cupcakes.
We should probably stop doing that. But they're so delicious. And the thing is, like, cupcakes are real.
They exist today. Whereas like the heart disease, that's a problem for many.
It's a theoretical problem for many years from now. So anyway, let's continue making poor life choices.
So this is saying, do we have more than zero cupcakes? And is it true that we are making poor life choices still?
And for a boolean, you put the true or false here without any quotes or anything like that.
And so if you use an and that's that's very true if both of these are true.
And so indeed both of those are, oh, I need to actually make them like this.
And then we would just eat the cupcakes. And then the order is a similar thing where if one or the other is true, then that would evaluate to true.
We'll pick up there on Friday. Thanks for your attention, everyone. Have a great day.
	esting. Testing. Oh, okay.
All right. All righty.
Hello? Hello. It's Let's go ahead and get started. Some announcements as we dig in today.
So don't forget, Assignment zero is due tonight. Assignment series do tonight p.m.
That quiz zero is due tonight. The syllabus quiz is due tonight.
That's where % of your grade all the other quizzes moving forward this quarter are just for bonus points and for learning.
Checking your understanding, you probably noticed there was a quiz that unlocked on on Wednesday after class.
There's a quiz unlocking today after class.
I have those set to open at two because I have office hours after class and if after office hours I need to make a modification to the quiz,
that gives me a little bit of time to go back to my office and make that modification.
One of the things to be aware of with those quizzes as they are due at a weird time, so they're due at a.m. on Wednesdays.
The idea is I want you to have hit certain checkpoints before we come into class certain days, so you'll have those do in about weekly batches.
So the two lecture quizzes,
the one from today and this past Wednesday are due this coming Wednesday at a.m. Be sure that you set yourself a reminder.
It is a weird time for something to be do section sign up is due p.m. this Sunday.
That's not on a first come first serve basis. It's just as long as you get that in by p.m.
We'll look at meeting what your preferences are for what time you'd like to have. Your section Section does begin next week,
so the coordinators will have a panicky meeting on Monday where they figure out what sections
they're putting everyone into and start sending emails and that will begin next week.
Layer begins on Monday. If you could all quiet down a little bit, please.
I'm just I'm concerned that if I'm hearing all the noise up here,
that people around here may be having trouble hearing me and getting distracted by you.
I don't mind if you chat as long as it's kind of like in a in a bit of a whispery tone.
So you're not disturbing others. D So we'll start holding their hours this Monday.
Even though that's a holiday.
What's going to happen is because Monday is a holiday, we're giving the slack Sunday night off, so maybe they can have some fun this weekend.
We don't want to have too much fun, but they're going to have some fun this weekend and then they'll be here Monday night,
even though it's a holiday to help you with things. And please make judicious use of AD as we work through the quarter.
By making judicious use of AD, you can help us avoid this situation over here.
This is just a picture of my sad small life teaching a class with people in it.
And by putting things on AD, we can ensure that sales can chip in and and give answers to questions that are coming up this quarter as we move along.
So those are my announcements. I know that moves pretty quickly, but of course,
those we posted for you in in your lecture notes when those unlock and also I did I posted your
lecture notes for Wednesday and then spent several hours editing them and refreshing them.
So be sure you've refreshed that page. If you'd looked at those lecture notes like around on Wednesday when I first posted them,
I mentioned and added just a bunch of things to make this more readable.
So let's go ahead and dig into some coding and we need to learn the rest of C++ today.
So I'm going to talk mostly about strings today, but a bunch of other things kind of along the way.
And we have some loose ends to tie up that I had hopes to get to on Wednesday that we didn't quite get to.
So let me just dive in right here. I have this kind of this boilerplate,
this template here to kind of start coding with the cute creator we've already talked about and explicated the different pieces of this on Wednesday.
I want to get back in to where we left off on Wednesday, which was conditional statements.
And just do one really quick example with you for conditional statements there.
How do you feel, first of all, someone like raise their hand and tell me what's wrong with actually,
let me just change the state to what's wrong with this line of code in C++.
I'm just saying nothing. Cupcakes equals five. Looks good if you're in Python, but in C++, yeah, there's no semicolon.
What else? If someone else raised their hand and tell us what else needs to change before. Was that?
Say it louder. Yeah. I need to put a data type here. I need to put it that I'm holding an integer here.
Great. So this creates this thing here. And then we talked about if statements.
And I just want to show you a common pitfall that I see a lot with if statements.
So sometimes you want to do something where you check if an integer is maybe one number or another or some variable is one value or another.
And does anyone actually let me just with this here, if I want to check if num cupcakes is equal to one,
can someone raise their hand and remind us what's wrong with this way of checking whether num cupcakes is equal to one?
Go for it like that. Yeah.
The equals the single equals means set this equal to one If you want to ask if it's equal to one in C++, you need to use two equal signs.
That's the comparison. Operator A single equal sign is an assignment operator.
So sometimes people do this. They want to know if it's if it's one thing or the other.
What was the symbol that we saw on Wednesday for the Boolean or I guess I just kind of do.
You can shout it out if you remember. Yeah. Two vertical bars, two pipes like this.
If you just do a single pipe, that's actually something else.
And similarly for and if you do a single ampersand, that's something else that you learn about in CSE.
One, two, seven If you want an end or operator in C++, you need to pipes or two and two symbols, two ampersand symbols of emergency.
People do this. They'll say if GNOME cupcakes is one or two and then see out running low on cupcakes and l like this.
And if we give this a run, this seems to be working. We're running low.
And if I set this to one, this seems to be working. We're running low. But if I set this to it's still telling me we're running low.
There's a bug in the code and that bug relates to how I've employed the order symbol there.
The way that C++ interprets this, it's asking, is this true or is this true over here?
And on the right hand side of that order statement, the number two C++ considers that to be a true value.
C++ considers anything other than zero or an explicit false fallacy written out there very concretely.
Literally, it considers anything other than that to be true. So the number two or the number negative two, those are considered true to C++.
So here I'm asking, is this false thing or this true thing is one or the other true?
Well, yeah, The piece that I have highlighted right now, it's true. If you want to know if cupcakes is one or two, you need to repeat the comparison.
You need to say, I want to know if num cupcakes is equal to one or if num cupcakes is equal to two.
You need to compare twice there. And then when I give this a compiler and run, you'll see there's no output because is neither one or two.
But if I go back to two over here, we are indeed getting that output that we're running low on cupcakes.
So this is a common pitfall that I see with C++ that people will not do that comparison.
They'll do something like this and this value is considered true and will wreck your life in C++ is what's going on there.
What I want to do next then, is write some functions with you. I talked on Wednesday about the basic syntax for writing a function.
The basic syntax was the return type or the data type that the function spits out or emanates.
Then we have a function name and then we have a parameter list.
And then we had what did I call it when I opened and closed curly braces like this.
Everyone Yeah, it's a code block. Very good.
And then we have a statement or statements within this thing. So I want to write I want to write a couple of functions with you really quickly this
morning and then dig into some other stuff related to strings and things like that.
If you want to write a function, sometimes functions in in code just don't emanate an interesting, useful value to us.
So I'm like the F of x equals x squared mathematical function that we talked about on Wednesday that's spitting out a result.
It's spitting on a value to you. Sometimes we just have utility functions when we're coding that just to do something useful,
but they don't send back a value to whoever called those functions.
They don't send back an interesting value that we maybe want to capture in a variable or print to the screen or anything like that.
They just do something. And if you have a function like that.
So for example, I'll just put question marks here for the data type. Maybe I have a greet function and it doesn't take any information.
All the greet function ever does is it says Hello, smiley face.
And then now like this, the greet function doesn't return to us.
An interesting value. And if you have a function like that in C++ that doesn't need to return a value,
we give it a data type of void that just says this thing isn't actually returning a value, it just does something and then terminates.
So this is a void function. It's not sending a value back to Main.
That's a data table use.
And if I want to call that from Main, I just do greet parentheses like this and you'll see that when I give this a compile and run, it gets that.
Hello. Now it doesn't remember the compiler in C++ starts at the very first line of your code and it works line by line
and it goes through each of those lines and just checks whether each of them is okay as it builds up your program.
When I run my program, though, I'm not getting this. Hello.
Just because the greet function says hello.
It's not that my program is going, oh, line by line by line, and then it hits line nine and then prints out.
Hello. Can someone raise their hand and remind us, What did I say happened?
On Wednesday, I said, we're not actually just executing sequentially here.
What thing is happening when we run a C++ program? Did you want to go for it?
You had your hand up in there. Yeah. It straight to the main and then it goes there.
It goes to the. Amazing. Perfect.
Perfect. So when we run a C++ program, regardless of the order in which you put things in your code, it always jumps straight to the main function.
So here it's something straight to mean. When I run my program and it says, the first thing you need to do is call the greet function.
And so then it goes to the Greek function and executes that code.
And once it's finished with that, it comes back to the main function and continues execution from there.
So that's what's happening there. And in terms of how that happens now, one of the interesting things about the compiler is if you do this,
if I take this function and move it down here, the program will no longer compile.
I just can control what is the control what in order to run the program, everyone control our to run the program.
Very good. And it's really tiny down here, but it's saying error by the Greek was not declared when I got to line nine over here because remember,
the compiler is going line by line by line checking out whether every line is valid legal syntax in C++.
So when the compiler when it goes through this version of the code hits line nine, it's like, what is Greek?
I've never heard of it before. I don't know if that's a thing. I don't know if you're calling it correctly.
I can't check up on you and see if this is the right syntax and then it just like freaks out and
fails to compile your program because it's never heard of Greek by the time it reaches line nine.
So you have two options for this. One is if you want to call some function, just define that function up here before it ever gets called.
And so now, by the time C++ compiler reaches line it'll be like, Oh yeah, great.
I heard about that a few lines ago when I was compiling the code.
Someone actually made that function and it looks like you're calling it correctly here.
And so this will now compile and run just fine. Another option here is to define this function below this one.
And some people like to do this in their code. They like to have mean first because their like main is the first thing that's going to happen.
And it just makes sense to me mentally to look at a piece of code and see main up top.
It's the main event. I want it up top. That's some people's philosophy on organizing their functions.
If you want to do it this way, what you need to do in order to make this compile is give C++ compiler a little bit of a
clue of what this function is going to look like before you actually define this function.
What we do in order to make that happen is you just copy and paste this first line of the function.
This first line of the function is called the function signature.
It has all of the identity of the function built into it in terms of what the return type is,
what the name of the function is, what parameters it takes, it takes no parameters.
We take that and copy and paste it above main at the top of our program here, if I can type and put a semicolon after it.
When you take a function signature and put a semicolon after it, we create what we call a functional prototype.
It's not a fully fleshed out version of this function. It's a little prototype.
And so here's what the second plus plus compiler does as it's going through.
It hits line eight and it's like, Ooh, there's this great thing.
It's like law or legend. It's like there's this legendary greet function.
And I don't know how it works. I don't know what it does yet, but I do know that the return type is void.
Its name is Greek. It's going to take no parameters. So it's like, Got it.
I'm now on a quest to find the Greeks function, and then it continues on with its quest.
And it's compiling main and fits to this line. It's like who someone is calling the legendary Greek function.
What does it do? I have no idea. No one's found it yet or I haven't found it yet.
I'm on a quest to uncover the Greek function, but I do know that it's supposed to return a void.
It returns nothing. I do know it's called greet, and I do know that it takes no parameters.
That's the law that I read, the legend that I read on line eight.
And so it looks like the person on line who's calling this,
trying to invoke this legendary function maybe through some ritualistic I don't know whether this is actually being invoked correctly.
And then it continues on its journey and it's like, holy crap, I found the Greek function.
Yes. And then it compiles the program successfully. So it doesn't get the Greek function definition until lines through 
But on line eight, it gets a little preview of the Greek function so that online it can verify that this is being called correctly,
despite not yet knowing exactly how that function can work. And when I hit control are indeed verification there that this is compiling and running.
So to reiterate two choices, if you want your program to compile before you call a function, define it above that second choice.
Define it after you call it, but put a functional prototype above where you're going to call that function.
But different people have different philosophies on this. Some people approach it this way, some people approach it the other way.
I don't really have a strong opinion on what you do in this class.
Let's write another function then. Let's write one that actually takes some parameters at this point.
So let's write that X squared function that I've been talking about a little bit here.
If I write an X squared function, so let me just write a function called Square that's going to take an integer parameter.
If I pass it an integer and it squares that integer, what data type is it returning?
Everyone just shouted out, Yeah, an integer squared. It's going to give you an integer.
You're not going to get some floating point number with anything other than a zero past that decimal.
So I'll say, okay, this is going to return an integer over here.
And if you want to pass a parameter to a function in C++, you just create that variable in these parentheses.
So I want this to have a variable called x. What I call it.
And so when I call this function, I'm responsible for filling in the parentheses with some value.
When I call the function, that value becomes x, and then I can do whatever I want with that X, so I maybe will return.
So remember, we use return statements to emanate a value, to spit a value out of a function like this.
So I want to return. Well, how do you square something?
What should I do with x? X squared is just. Yeah.
Yes. Some people are saying it. Maybe you're like nervous about that question because like, what is he getting at it?
It seems like it should be simple. Yeah, it's just x times x.
And the way you multiply two things together in C++ is you just use that ampersand symbol of the ampersand,
the asterisk symbol in order to multiply those together. And so then to call this down here, oh, everything is all borked and out of order.
Now let me get rid of all of this over here. This, huh?
Let me do. Oh, no. Why did the screen just go black behind me?
Okay, it's back. Nobody panic. Okay,
so notice that I moved the function above main because I want it to be defined before I get to line and then I need to pass the thing over here.
Like if I want to square the number five, I'll just put that in parentheses here. So five is getting past that function.
When I call it X becomes the number five, and then that function spits out the number five times five, which is 
I want to get this a compile and run. Nothing prints to the screen.
And that's because returning something from a function doesn't print to the screen.
I didn't use a code anywhere in this code to print to the screen.
This is just sending the value back to Main on the line where it's called the square function.
So line received the value We just didn't do anything with it.
And here are some options that we have for for getting that to print to the screen.
One is I could put it inside a variable. I could put I could do this like into result equals that thing and then see the result like that.
So when I call square five, it not only does the work associated with calling that function,
but that this square five, this then transforms into the number that I returned from this function.
This becomes the number and I put that in the variable result and now I'm printing result to the screen.
If I give this a compile and run, it prints the number and everything's okay.
Another way to get around that are to make this print to the screen is to actually just put this directly right here.
You could say, I want to print something to the screen. What do I want to print?
Whatever the result is, the return value from calling square of five.
And so this will print that to the screen and will be good to go over there.
So and actually, maybe it should show you that that's the case there.
So this just it evaluates the number and then at it gets shuttled over to you, to your terminal, to the output there.
So just some things there about functions and how functions work now.
And that's how you you create a function that can return values. And that's how you create a function that can take parameters.
And if you want to pass multiple parameters to function, we'll see that eventually.
I'll show you how to do that later. Let me show you something else with functions.
So let me do I want to do a void function void zero it out that takes some integer n and just sets an equal to zero.
And here in main, let me create some variable an intern and I'll do zero it out and pass under that function.
And then I'll print n to the screen. By the way, what did I say an integer contains in C++.
If we don't initialize it, we don't give it an initial value. It contains garbage, something random nonsense.
And in fact,
the creator with the project that I'm using is going to refuse to let me even build the program because it knows I haven't initialized this variable.
So let me set that equal to five. So I pass this up to that zero out function and I set an equal to zero.
Then I come back to Main because I've fallen off the end of my bi void function.
If you fall off the end of a void function, you just go back to whoever call to that.
So then I'll come back here and be like, okay, finish that and then I'll print out N and when I give this a compile and run,
it actually prints the number five online 
Even though I passed that n up to the zero it out function and set that equal to zero.
When I got back to Main and wasn't zeroed out, is anyone able does anyone want to raise their hand?
Can you explain? Do you know why that's happening that that's not getting zeroed out and make it loud so everyone can hear you?
Yeah. You're. Yeah, very good.
I actually have two different variables going on here.
So what's happening in memory is in mean I have this variable n that contains the number five, and when I pass that up to that function, zero it out.
What happens is the zero it out function gets its own copy of and I declared it online seven I said, and that creates a new integer called N.
And so on. My nine when I say end is equal to zero, that's changing this.
N. Within this. Within this function it's local copy of and gets changed to zero.
That does not change. N back in mean I have two copies of n going on over here.
This is referred to as variable scope. When you create a variable, it's it's only visible within that code block where it's getting created.
So on line that in its scope is main, it exists within main.
And then on line seven, when I create that new integer N that's part of the curly brace block right below it on lines eight through ten.
It has access to that. And so there are two separate ends going on here in memory.
And this function does not have the ability to change. And back in main, this is what we call a pass by value function.
I passed the value five up into zero it out and it got a copy of that value and
then it just it played with that value and then it moved on with its life.
That's that's a variable scope right there. If you want to empower a function and this happens a lot, actually.
If you want to write a function that can actually come back to Main and change that and you can't pass it by value,
you need to do this other thing called passing by reference.
And so this is a new topic that's perhaps a little bit tricky when you first see it.
Passing something by reference gives a function the power to change that thing back in the original calling function.
If I pass and from Main by reference to this zeroed out function, then I will empower the zero web function to come back.
Not to this copy of N over here, but back to this copy of N and change it.
And you've actually already seen something like this before. If you've worked with Python or Java,
which most of you said you've worked with either Python or Java or if you worked with C++, you've seen this before,
but if you've worked with Python or Java, you're probably familiar familiar with the idea of passing a list or an array to a function.
And when you pass that list of array to a function and change it,
then when you get back to wherever you were calling that function from that list or that array has changed over here also.
So in Python and Java, when you pass lists or arrays to functions, they're passed by reference.
We're empowering those functions to change. There's just one array or one list in memory that's getting changed over here.
And here's how you do that in C++.
If instead of passing this by value, you want to basically set this up so that that end is able to get back to Main.
What you do is you put a little ampersand after this data type over here.
And that ampersand, you can think of it as opening a crazy, swirly wormhole in the universe.
And it establishes a portal between this and right here and this and over here.
So that what happens ultimately here, I think I drew this out actually, at one point I did three diagrams.
Oh, no, I actually don't have that drawn out. I'll just try it out for you now. So this is one of 
Aha. I've opened a portal. And what happens here in zero out and isn't its own separate variable.
It's not its own separate copy of this integer. It's actually a portal that leads.
Oh, no, I can't not draw these. This whole little thing going all the way up here, but a bit bit like this.
It's a portal that actually leads all the way up here to this value right here.
So now in this function. So now in this function, when I change an online nine,
because I didn't just create a new variable end by saying it and I actually said this is what we call a reference to n.
I've opened up a portal so that this this actually end right here.
When I try to change it to zero, what happens is you can imagine that the program is going here and instead of putting
a zero right there and some new variable n it's reaching through the portal and
getting back to end in main and it's putting a zero there and then it comes back
through the portal and it's back in this zeroed out function over here like this.
And so when I get this a compile and run, you see indeed that that has turned into a zero there.
So this is a pass by reference function by putting a little ampersand there.
What I've said is this variable is not a new variable, it's not its own separate copy of, and it's actually a synonym for this variable back in main.
And so trying to change and locally is actually changing N back in main.
And similarly, if I printed it out over here,
if all it did was if I printed those and punched C out N and now what will happen is it will go through that portal find and in main and be like,
oh that contains the value five and it will bring it over here and print the
value five to the screen before we go back to Main and print the value zero.
And so this is called pass by reference. And we do this for a couple of reasons.
One, a function in C++ can only return a single value, and sometimes you want a function to give you multiple values as return results.
So for example, if you want to solve a quadratic equation and you pass A, B and C to some function,
you know that the quadratic equation has the plus or minus the square root of blah, blah, blah.
So it returns actually to or should produce two possible results when you solve a quadratic equation.
Well, you don't have a function in C that can return two separate results.
You can only return one thing from a function, and it's in C++.
And so sometimes what we'll do is we'll write a function that like if you want to try to solve quadratic equations,
write a function that takes A, B and C, and then give it result one by reference, result two by reference.
And then back in main you can retrieve two separate results from that function because it was doing stuff by reference.
We also sometimes pass stuff by reference just because like if you have something that has like a variable,
it has like a gig of data in it, passing it by value creates a whole extra gig.
It creates a whole separate copy of that thing in memory, and it can be more efficient to just like pass that thing by reference.
So you're not replicating a whole gig of information in two different places.
It can make stuff faster, but we'll play a little bit more with pass by reference as the quarter goes on.
A quick another quick example for this. Maybe let's go on a little bit of a treasure hunt.
So if I have in main this one, I actually think I have some diagrams over here for exactly what values that I want to use.
So suppose in main I have some variables Horde one hoards two and horde three and they contain some treasure.
So maybe that's gold pieces or whatever my unit of treasure is.
This is hoards, two equals in toward three equals 
And so we want to write a function that actually goes and reads these treasure words and takes this treasure.
So I'll say int our total booty is and we're going to go on the treasure hunt and we're going to rob hoard one,
two to export three and then see out and we'll be like yea or me total booty B And then we'll print out what the total booty is and I'll like that.
And so let me do the treasure hunt. I'm just going to pass it into this is one, into two, into three.
This is how you create multiple variables that you're passing to a function in C++.
You separate each declaration by a comma and you need to repeat the data type there.
So here, if I want to do total treasure, I can do set this equal to zero initially and then to total treasure.
If you want to add to total treasure, you've you've seen this plus equals operator before, whether you've done Java or Python before.
So I'm going to just like take treasure, hoard one,
hoards two and hoard three and then return that total treasure back to Main and print out how much treasure I store.
And if no party foul it needs to return it to, It's not a void function anymore.
So we're turning in it. So if I give that here, it's saying yea me total booty b
Well, the problem with this is we haven't actually zeroed out what's in those hoards.
This treasure hoards. When we took all of that treasure, if someone comes down here and they look at their treasure hoard,
like if we look in hoard one, let me just print out what's in all of the search rewards here really quickly.
If we look in hoard one hoards two and hoard three like this and give this a compile and run.
You see that those still have those values in them. We didn't actually steal that treasure.
And even if we go up here and we set those equal to zero and we're like, Oh, we're stealing that treasure now.
And we set each three in H to When I give this a compile and run back in mean,
it still says that I have not emptied out those treasure hoards over there because what's going on is
this I'm passing those what did I call this kind of function where I pass those integers in regularly,
It's pass by pass by value. Yeah. So locally, I'm just setting these things over here.
To zero. That has no impact on those values in Maine.
Those values in Maine. I have not emptied out those treasure hoards.
So what would I need to change about this code so that when I execute lines,
it's hard to see at this angle When I execute those lines that are emptying of the treasure,
hoards are attempting to empty out the treasure hoards that I actually zero this values out back in Maine.
Can someone raise their hand and tell me what do we need to change about the code in order to not pass by value?
But we're going to pass by reference. And so what we need to change syntactically go for it.
Wait. Say it loudly because I'm old. Yeah.
After the INS online seven. I love that you pointed out exactly the line number I need to go to.
Also, by putting these here, I'm opening a wormhole between these variables and the ones back on Main.
And so what I've done here is. Boom.
I've opened these portals from these three things. These three variables in treasure hunt are now synonymous with the ones back in Maine.
So when I set these to zero, I'm actually reaching through a portal and setting this to zero.
And I'm reaching through this portal and setting this to zero. And I'm reaching through a portal, and I'm setting this to zero.
Like that. And then I'm putting space there. So it's all nicely. Now let me give it a compile and run.
And indeed, you see, the treasure hoard got robbed and we have units of treasure.
Amazing. Okay, so that's pass by value versus pass by reference.
Let's let's shift gears a little bit here. I want to talk then about strings, which is kind of what I wanted the main topic for today to be.
We'll see how much we can get through over here before we get to strings in C++.
I want to mention something about character variables.
If you create a char variable in C++ and actually in every language, when you create a char variable.
So say char equals oops, char c h equals the letter.
Q Can someone raise their hand and remind us what's wrong with the way that I'm trying to put this character in this variable here right now?
Go for it, Daniel. Well, yeah, it thinks Q is a variable. So what do I need to do instead?
Yeah. Single quotes. Very good. Because it's a single character. We use single quotes.
Underlying every character is actually a number that represents that character.
Everything in your computer is represented using numbers. And many years ago, a council of of Old Wizard Geeks got together and said,
we need to come up with a standard like Q can't be represented using the number on some computers, but on some other computers.
Because then when I try to send one text file from one computer to another, it'll just get lost in translation.
We won't know what any of these numbers mean and that will be a disaster in terms of sharing information.
So there's a universal standard called ASCII that determines what numbers should underline.
Every character that we save in a text file like the lowercase value A And you don't need to know this.
I only know this because I've been talking about it for so many years that I kind of just accidentally memorized it along the way.
The number the letter A is represented using the number 
That's just the code that some people decided on many, many years ago when they created this ASCII standard.
And if you want to print that out, like if I do see out this character over here, if I want to point that out, I just get that character.
A It's just the character. And if you want to look at the integer value underlying that thing, you need to perform something that we call it typecast.
And this is what we call a functional style typecast in C++, where you basically whatever data type you want to to change this into,
you put that data type and then you kind of pass to it as if it's a function, the thing that you want to transform into that data type.
So this is saying take this character the letter A and actually treat it as an integer.
And if I print that thing out, I get that number 
So every every character has an integer value underlying it.
And so you can use that to your advantage for something like this.
You could do a for loop, you could say for I equals I is less than or equal to which I happen to is lowercase letter z, I plus plus.
And if I print all these out, see out I and now if I give that a compile and run, well I just get those numbers.
three But if I take those and put them and typecast them, that's still an integer.
If I typecast them instead as a char.
So you can test from integers to chars or from chars to integers, if I take this integer and I'm like make that a char,
give me the equivalent, then you'll see that when I run this I actually if I scroll up I get these values A through Z.
It's those are the values through 
So they're really synonymous with one another.
And so you can actually take an integer and force C++ to consider that a char and print out the equivalent char that's going with that.
You can also do kind of scary things like this. Then knowing that a char is just an integer behind the scenes, you can do something like this.
You can do char. My char equals the letter A and then you can do while my char is less than or equal to the letter Z.
And you might look at that be like, Whoa, how are you doing? And less than or equal to comparison between letters.
Well, they're just numbers behind the scenes. So it's going to ask is is the number here less than or equal to the letter Z.
And by the way, this goes sequentially. So A is B is C is D is and so on and so forth.
And so what would I type here to make this for loop?
Go on to the next character, the next iteration, you can just shout it out.
Yeah. My charm Plus. Plus. Very good. I'll just increment it like that.
And then because that's already cha, I can just print that out as this is my cha like that.
Oh, and give that a go and you'll see. Indeed it's printing out A through Z is what's going on here as we scroll through that.
Now if I wanted to print in parentheses, suppose I want it to print in parentheses the ordinal number for these characters.
So like a the ordinal number for that is one. It's the first letter of the alphabet.
B is to C is three. If I just do into my cha like this, what I get out of that is that a it has in parentheses.
How could I get in parentheses there. How could I get a one for a, two for B, a three for C?
What do you want to do for Jennifer? I could subtract 
You'll see that if I subtract from those values, then what I'll get is a sequence.
One, two, three, four, and I'll have the order in which each letter appears in the alphabet.
So I could do something like this. I could do -like that.
And what I get here is indeed Z is the th letter of the alphabet.
A is the first letter of the alphabet and so on. Online I have a philosophical complaint.
A lot of people in the fields just won't know what the number means, and we refer to that as a magic number.
When you hard code a value in your code where someone is like, what is that number?
Why does that actually make things happen? I don't know what's going on there.
We call it a magic number and it reduces the readability of our code. Someone who's not familiar with ASCII would look at this and be like 
How does this program even work? What's going on here? And they might give up on computer science.
So I want to replace that with something that has that is maybe a little bit more readable.
And to replace that with something a little bit more readable for someone who doesn't know what ASCII is,
what I'm effectively doing with the number remember, A is the number 
This is just the character, A minus one.
And so indeed here if you have the character A in my char and you subtract from that in parentheses, the character is minus one.
Well, that's the same thing as a minus a plus one, and that would just give us a one.
And then similarly, if you have the character B and you subtract from that the character A, the difference is one.
And then when you subtract a negative one, that's the same as adding one, that one becomes a two over there.
So I want you to think about avoiding magic numbers in your code as we go through class this semester.
Something that I want you to do there. So that's just a kind of brief introduction to ASCII.
You don't need to memorize that.
I just want you to know like there's an underlying numeric code and you can typecast between integers and chars to get access to that code.
What I really want to do though, and we're finally there is talk about how strings work in C++.
So C++ does have a string data type built into it, so I can do string S equals.
Hello. Like this. One of the things that I want you to see or notice straight away as I create this string here,
there's something fundamentally different about the string data type compared to all the other data types that I've used so far this quarter.
So I did like index equals five cha c h equals a double D equals like that.
What are you seeing that's different? Someone raised their hand about string compared to all those other data types.
Yeah. Yeah, it's colored purple. Very good.
This is the ideas way of communicating to us that the nature of this, it is fundamentally different from these other data types.
INT float double char are just what we call primitive data types built into the language.
String is something else. It's not just a regular data type.
String is what we refer to as a class.
I'm creating a string object with this thing called a string class, and we'll talk about classes a lot later this quarter.
But the main thing I want you to know right now is when I create s it doesn't just contain the data.
Hello. It contains a bunch of other stuff that's bundled together with it.
And that's why this data type is purple, because it's special.
It's got a bunch of stuff bundled together behind the scenes there and you can access that stuff.
I'll show you how to access that stuff in a second.
One of the things I also want you to know about strings really quickly in C++ is they are represented as arrays of characters.
So when I create a string like Hello there, what I actually have in memory is a block of characters laid out sequentially in memory.
H e, l, l o space, t h, e r e and they have indices associated with them.
The index for H, it's a index zero. In this data structure, we call this an array.
And if you've seen in python lists, it's very similar to a list. This array of characters is really how our string is represented and every
character is numbered zero through however many characters there are minus one.
So in Hello, there are five characters. The last one is index four.
It goes zero. One, two, three, four. Are you all okay?
Have you seen before that? We start counting at zero in C, such as the thing that we do.
Okay, so let's play with that a little bit. If you want to print, then the first well, first of all, you won't print the string.
You can just do this c out s like that. Let me get rid of all this garbage down here and let me get rid of this garbage up here.
So I'm just going to print out that string and it just prints that string to the screen.
When you create a string, you have to use double quotes around it. Those aren't actually stored in memory as part of the string.
That's just how we signify that this isn't a variable called hello. It's actually data we want to put into the string.
And if you want to access, say, the thing at index zero,
what you do in C++ is put square brackets after that variable name and this says give me the character index zero in the string.
Well, the character index is zero. In the string is the letter H.
And so if I give this a compile and run, it just prints the letter H, And the way that I read that line outloud that S brackets is zero.
I say s sub zero. That's how I read this.
When I'm communicating to someone out loud, what I have in code is subzero.
So if access is subzero over here, or if I want to print the last character, shout out everyone.
What index is that last character out again? The Oh, is that index or.
For very good. It's not an index five. Remember, we don't go one, two, three, four or five each low.
We start counting at two, three, four.
And so if we print that one out, indeed we're getting the letter.
Oh from that one over there. Now I mentioned that this purple thing, it's I've got an object here, it's got a bunch of goodies built into it.
So check this out. When you have a data type like that, that's purple.
Usually when you create a variable of that type, if you put a dot after it, dot, you get, oh no, it's not popping up.
There's a bunch of stuff that's built into this. And if you start typing, Oh no, it's not popping up at all.
That's a really sad day. I don't know why it's not popping up.
I've maybe tweets my ID a little bit so that it's not happy. Oh, no, that's.
Oh, well, at least I know what the length thing is.
So when you use DOT, that means go inside this variable and, and access some of the functions that are built into this variable.
And so this is kind of unusual compared to how I've used functions up until this point this quarter.
I'm not passing as to a function.
I'm saying s has a function inside of it and I'm using the dot operator here to go inside of s and pull that function out.
And so this, this will give me what the length of s is. I'm not passing as the length.
Length is a thing that is built into s And in your notes for today,
I'll actually give you this chart that gives you a list of interesting functions that are built in the strings and how you can call them.
Like there's the substring down here, substring where you can start at a particular index and get this number of characters out of it.
So if you do well, let me show you. First of all, it's not length, just returns the length of your string up the number five sub stir.
If I start it index zero and take just four characters out of this thing, then oh no, we're in [INAUDIBLE] if I.
Well, that's just what's happening there. Just takes the four. I guess if I just do a three then I have the old.
I think there's like a Nordic God named. I like that. So that's just a thing that I want you to be familiar with.
And I'll I'm not going to go through and give you examples of all of these functions and how to call them.
I just think that's going to be a waste of your time. I'll instead leave this index for you in your notes.
And then if you're working on programing assignments, oh, I forgot to mention I'm probably going to unlock assignment one,
your first coding assignment tonight, maybe around five, which means I'll probably be up at like p.m. posting it for you.
But I encourage you to work on that assignment this weekend and get as far through it as you can.
Next Wednesday we will cover some material that's required for like the last little bit that assignment,
but I think you'll just be in better shape if you knock that out as much as
you can and then you don't have it hanging over your head as we move forward. So this is stuff that's built into the string data type in C++.
The Stanford C++ Library has other functions built in that do common tasks that you might want to accomplish
on strings that just aren't as easy or conveniently implemented or not implemented at all in C++.
So check this out.
When you go to the course website, if you click up your own resources, the very first second link here is the Stanford Library documentation.
When you click to the library documentation, you can see all of the libraries that we've built for you.
And one of them down here is Star Lib, a string library that just has cool stuff built into it.
Like, I don't know,
you can take the string and convert that to the number by doing string two integer down here or find if it contains a particular substring.
And so do be sure that you check out this documentation and feel.
Feel free to refer to this as you're working on your programing assignments. Maybe let me just show you a quick example of that.
So one of those was this over here. It said if you have a string that you want to convert to an integer, call string to integer.
So let me do that over here. I'll make this the number and then check this out.
If I just do int X equals s, C++ does not like that.
It's going to be like, Wait, what are you how are you? Why?
It's like, how do you take you can't just take a string and expect me to make an integer for you.
So what you need to do is call that function that was string to integer.
And one of the things that I showed you before I clicked on this was this is from Star lib dot H, and it's from the Stanford C++ Libraries.
In order to call this function, I need to include SDR, lib dot H, and let me test your memory here really quickly.
It's coming from the Stanford C++ libraries. So do I use the angled brackets or do I use the double quotes?
Just shout it out. Yeah, double quotes is for stuff that's not built into C++.
And so, like, stuff that we've made for you that's extra like the Stanford C++ libraries.
And so now it compiles and runs and it can convert the number from the string form into an integer form.
And so that's just a neat thing that it can do there.
We can do other things, like you can change strings in C, So if you have something like in C++, so you have something like this string S equals.
Hello. You can say set the first character to Capital Y, and then when I go to print out this, the string,
um, if I print out like this, then we have, um, we have just yellow without a W at the end.
You can also, like, add stock to strings, so you can say s plus equals and add a single character.
W And now this will have transformed the string literally into the yellow.
The words the words yellow. If I changed the first character to a Y, I added to the end of it the character W and you can add entire strings.
This is called concatenation. You can add entire strings concatenation to your strings.
So you can say, Now that I've got yellow, I could add a whole string, a space, and say yellow squash is like that.
So this will just take the string squashes and add it to the end of the word yellow over there and we'll get yellow squashes.
So there's all kinds of neat stuff that you can do like that with strings.
I also showed you on Wednesday that you can loop through strings so you can do like four for each character in my string,
print that character, and you could do them each on their own line like that.
And then we'll get the yellow squashes all vertically like that.
You could do something like that when you use this loop here, by the way, call to the for each loop or the range based loop.
One of the things you lose is I don't have an index I that tells me how far I've gotten through the string.
If you want that index, I you could maybe do a different kind of for a loop like this.
You could say four int i equals zero is less than what did I type to get the length of the string.
Just shout it out. Yeah, it's got length like that.
Parentheses. Very good. It's a function that I'm calling that's inside the s variable and then I plus plus.
And then here I could in parentheses. Put what.
What index were on as I go through each index in this string.
Oh no. See was not defined. Okay, so what do I need to do here to get the ith character in my string as everyone as square brackets.
Very, very good like that. And I pronounce that s.
Sub. I very, very good. Okay, so now I've actually got.
So if I do the following, I actually have an index that I can keep track of where I am as I go through and loop through these strings.
So that's just something interesting that I can do there. There's another C++ library that I want to introduce you to.
And again,
the idea of these first two lectures isn't to show you this stuff in a way that's going to be memorable just from watching the lecture once.
Like, you are going to have to sit down and play with this, read through the notes and load up the Q t creator and actually write some code
and call these functions so that you start to get really comfortable with this.
If you don't do that before next Wednesday, we're going to get to a point where it's just like, Oh no,
all the C++ that I don't remember because I had a long weekend and things are just going to fall apart for you.
There's another library that's built in to C++ for processing, for processing individual characters, and it's the C, C type library.
So let me up here. This is a built in one. You include C, C type, and it has all kinds of and again, I'll post this in your notes for you.
Oh, here I'll put in your notes. Some interesting stuff from the Stanford C++ Library.
And if you're ever if you ever include a library and you want to know what's in there, you can control,
click on that in the Q t creator and it'll take you to that library so you can see an index of what all is in that library.
But from the c, C type library, the C C type library for processing, for processing individual characters,
the C, C type library functions they have a fetish for using the format is followed by five letters.
So if you want to know if something if a character is an alphabetical character, it's is alpha.
If you want to know if it is a lowercase character, it is lower if it's alpha numeric.
So either number or letter is alpha. And these return true false values.
So you could do something like this. You could say if x sub zero and I want to know if that is alpha.
Is s sub-zero an alpha character? Well, yeah, it's an alphabet.
It's the letter capital Y, So I'll see out. Yes.
Else. Out. No.
And they'll like this. And indeed, you'll see. Yes, that's an alphabetical character.
But if I change that to say, like a symbol, like if I want instead of yellow, I just put like a percent symbol there.
Then when I give this a compile and run, it's like, no, the percent symbol is not an actual alphabetic character.
So you can call those functions like that.
There is in both the CC type library for processing characters as well as as well as the Stanford C++ libraries.
We have functions for converting things into uppercase.
So we have this two uppercase function over here and watch what happens when I call this to uppercase.
So let me do two uppercase on my string and I give this a compile and run, and it didn't actually change my string to uppercase.
So what can you infer about the type of function to uppercase is based on something we
actually just discussed about two different types of functions that we can have in C++.
This must because it didn't actually change us to uppercase. This must be a pass by value function.
So it's not passed by reference. It can't change. S.
What it does is it returns the uppercase version of S, And so this can be very frustrating if, you know,
there's a function that turns something to uppercase and you call it and then you print it out and you don't have uppercase,
you're like, What's going on?
It's not a passed by reference function, it's a pass by value that returns, you need to say as equals and capture the uppercase thing.
It's returning. And now I have capital yellow squashes going on in there.
One of the final things that I want to mention is that when you get into extreme concatenation,
as I mentioned, you can add strings together in C++, and I'll put this in your notes for you.
C++ has two kinds of strings built into it.
When you use double quotes, that's what we call a string literal, and that's an old C type string.
And you cannot add to all of these type strings together.
If you try to do this, where have Sequals this C type string plus the C type string, C++ will freak out and be like, I don't know how to do that.
What are you doing? But if you take a string and put it into an actual C++ string variable, I've gone from an old C style string in double quotes.
It transforms that into a nice, robust, mature C++ string variable.
And when you take two string variables in C++ and add them together, that's totally fine.
Or if you take one string variable in C++ and add a C style literal in double quotes to it, saying C++ will be fine with that as well.
And I don't need you to memorize the nitpicky details about that.
What I want to do is expose you to this. So if you encounter an assignment, you have a reference for where you can go to to find that information.
Thanks for being here, everyone. I know it's a lot of information. Keep working hard.
I'll see you on Wednesday.
I just. All righty.
Good morning, everyone. Welcome back from your long weekend.
Let's go ahead and dig in and and a friendly a friendly reminder that I do expect the conversations,
like if people are chatting around you loudly enough that I can hear them back there.
I do expect those to die down as soon as I as I start going here. There's so many people like in this vicinity right here, just chatting very loudly.
So there's this this group back there that's just chatting obliviously to the fact that I'm trying to get them to quiet down.
They're just like not listening.
If you're if you're near that group, that's just like chatting, like there's just one person who just has no idea that we've started class.
If you want to, like, kind of poke at them and let them know, okay? Yeah.
Like, you're you're being called out for being disruptive right now. Thank you.
So it's kind of unusual at Stanford for me to have to take that long to start a class.
I'm used to classes just quieting down as soon as we begin and having kind of that sense of decorum
as we begin that there are other people who are really interested in hearing what I have to say. And we have a lot of material to get through.
And as you know, I use every second of class.
So the more time at the beginning of class that I have to do management like that and ask people repeatedly to kind of quiet down,
the more you're losing out on important tidbits that I might add, that would reinforce the material,
improve your, your success rates on the exams and so on and so forth as we go.
So you ask that you quiet down right away. And that's partly why I have a clock up here every day as we begin class.
So I'll ask you to manage that as appropriate and to do please, as people are talking around you at the beginning of class,
maybe just quietly and politely ask them to quiet down so we can begin if that's happening near you.
So if you announcements really quickly before we dig into some more content and continue to move at kind of a breakneck speed through this material,
there are three things that I want you to be sure that you're reading,
especially as we go into Monday's submission deadline for the first assignment, A-
So one is there is a submission checklist posted on the course website that just has a bunch of action items
you need to go through to ensure that you're going to maximize your score on that programing assignment.
There are things in there that we just don't have time to talk about in class,
and so I will rely on you to read those things and make sure that you're doing those things to maximize your score.
The other thing is when you go to the resources page on the course homepage,
there is a link there that talks about setting up the cute creator so that it's
just like a really good optimal development environment for you this quarter.
I do encourage you to work through those things that are just some quality of life things there where you can go into your settings,
check some things off, and this is going to make your development a lot smoother and more comfortable this quarter.
Be sure to check that out and then make sure you glance through the style guide and that you're
going to maximize the score that you earn on style points when you submit your assignments.
We want those to be pretty easy free points for each assignment, but you do need to kind of just glance through the style guide really quickly
to make sure that you're up on those some other announcements really quickly, some more logistical things.
So last night you should have been assigned to a section if you had met that sign up deadline p.m. this past Sunday.
And if that section doesn't work for you or if you didn't sign up for a section and you're not currently in a section,
remember section attendance is about % of your grade this quarter.
You do need to attend a section every week so you can go into paperless.
You can find that under the resources link in the course homepage and you can sign up for or move around to a section that isn't already filled up.
So be sure you get into a section and started attending section this week.
That is for credit. We do ask that you go to the section that you're signed up for.
What we don't want is that everyone kind of waits to the end of the week and then crams into a
late Friday section where the people who were registered for that section then have maybe 
people attending that section. If that happens, actually what will happen is that the sales will just start barring people from entry.
Once we reach kind of a number where they feel a little bit uncomfortable letting more people
in pass that number and then people just won't get credit for the section for that week.
So be sure you're going to the one that you registered for and don't wait till the very last one or two sections on the list.
Be sure that you're reading Clinton's weekly post on Ed, so he's going to post every week like you're all the things that are happening,
the deadlines, the things that need to be aware of this week. And you are responsible for all those things that he puts in there.
There is a new quiz series rolling out starting today.
So there was a quiz series due this morning at a.m. and then the other quizzes for next week's Wednesday deadline at a.m. start unlocking today.
And those roll out, of course, so that you'll have plenty of time to work on today's quiz.
But then come Monday, when I unlock a quiz at p.m., you'll have a short time periods to get that turned in.
By next Wednesday at a.m. Be sure that you're keeping on top of deadlines I mentioned last week.
That is a weird deadline, but it's up to you to manage that and make sure that you meet that deadline.
If you want those bonus points. And why would you not want these bonus points? Don't leave bonus points on the table.
And then I also want to mention Clinton has a mega thread going.
If you go to Ed during each lecture, he has a mega thread where you can ask questions.
If you have burning questions that just can't wait and you want to get some responses to those pretty immediately as we're going through lecture,
because I do often have a lot of material where I just don't have time to pause and take every question that might come up as we go.
But I will ask that you manage your attention in terms of whether you're paying attention to here or splitting your
attention and looking at stuff on Ed and just be judicious and conscientious of where you're devoting your attention.
So that's kind of where we are.
What I want to do next is a little bit of reinforcement slash review of concepts from last week, not a whole lot of stuff.
I just want to write a function that uses some of the stuff that we did last week.
I want to talk a little bit about our testing framework, which you're already reading about in Assignment one.
How many have started a one already? You're taking a look. Okay. So there's just a lot of, as you've seen,
a lot of text in that assignment where we'll sometimes introduce ideas there that we haven't talked about in class.
And we do expect that there's learning happening in lecture, but. Also, there's some reading happening as you go into those assignments.
We've tried to set them up so they're really friendly in terms of having access to all the information that you need right there in front of that,
in front of you as you're reading through the assignment.
But I want to talk a little bit about the testing framework today that you've been reading about already in Assignment one,
and then start getting into some abstract data types, particularly the vector.
And also talk about this thing called the grid.
But the vector, if you've been working through assignment one, you've seen the vector coming up already.
So I'm going to talk about what that's all about.
So let me head over straight to the Q creator, and I want to start coding it just to do a little bit of string manipulation function stuff.
So we talked last time about the string data type, so let me just create a string here.
You know, use double quotes with, with your strings.
And I talked last time too, about how the string, the name of that variable, that data type, the name of the data type actually turns purple.
When I complete one of those lines of code,
which is different from what I had for like int floats double char, which was kind of like a brownish color.
And I mentioned this is something different from those primitive data types that are built into C++.
This is does anyone remember what I had like two terms for what I was referring to this s variable or what the string was.
Does anyone remember one of those terms? Going to shout it out if you remember? Yeah.
So string is a class and when I create a string as the string variable, we call that a string object, as is the object string is the class.
And I'll talk more about what classes are later on this quarter. But if you want to create so let me create like a little password here.
This will just be like Shaun's password like this. One of the things I mentioned last time too,
is like this idea of of a class or an object built into s is a bunch of functions that you can call on it.
And so when you type what I need to type next to access the stuff inside s everyone the
the what was the operator I typed to get access to the functions but embedded in this.
Yeah. The period the dot very good.
And so if I type a dot, what happens is these all pop up and my Kuchi creator was just like not behaving last week.
So we didn't get to see this.
But there are all these built in functions called the member functions that are built into s things that you can call there.
But then there's and so this is all C++ standard stuff,
but then there's also the library of stuff that we've created with the Stanford string manipulation function.
So you have access to lots of functions that can do neat things and help you get tasks done efficiently and whatnot.
What I want to do here is just write some code that checks whether somebody.
So I have a username here, Sean And a password. Sean's password.
I want to just write a piece of code really quickly that checks if the username is part of the password.
That's a traditional thing for systems where you're creating a log in to actually
disallow to say that you cannot use your username as part of your password.
So I just want to write some code really quickly that would check that.
So if something, something, something I'll just see out here, Oh, no bad password like this, that's if this thing has that password.
Otherwise I'll come down here and I'll just say hooray.
This means that we had a good password like this.
And so if I want to write a function that checks whether one string is inside another string, I think that I might do.
I mean, I could, I could sit down and do that. I could check.
And the problem with this is like Sean could be embedded anywhere in that password.
So we need to check the first letter.
And if I don't see and at the very beginning, maybe just go to the next letter and see if that's us and keep on looking and looking, looking.
And they can get computationally inefficient,
especially if you have SCA throat this password on you keep getting faked out as you're looking to see if like Sean, if you have the ACA SCA,
you know as you're going through to see does this contain SCA and you just keep getting
staked out over and over again and wasting time searching and seeing if that thing is there?
It's actually kind of a tricky problem.
I'm not super tricky, but it's tricky to code up super efficiently checking for whether one string is part of another string.
And so I'm wondering if the Stanford C++ libraries have something that can help us with that.
So kind of your flow as you're working through a lot of assignments this quarter will be going to the resources page on the course homepage,
going to the Stanford Library documentation and then looking up all of the goodies that are part of the library that we've already introduced to you.
So we've talked a little bit about this store, Lib Liberty, each library.
And as I go through here, there are all kinds of functions that I can call to that I can call on and pass the strings to.
And I'm just wondering, as you're looking through this list, I want to know if one string appears inside another string.
Are you seeing any functions here where you're like, Oh,
that one sounds like whether you've read the descriptions or maybe you've just looked at the names, is anyone seeing the one we're going to use here?
You can just shout it out. Yeah. String contains very good. There's the string contains right here.
And you have this description. Also, it returns whether the substring is found inside the given string,
so it'll check whether the second argument is is found within this first argument over here.
So I want to call if string contains. So just do. If string contains and I want to pass it.
The second thing was the thing that I was searching for inside the first thing over here now it's read underlying string contains it's not happy.
It's saying, I don't know what that function is. Can someone raise their hand and tell us why would this be unhappy?
It can't find as the string contains function. Yeah, go for it. Yeah, very good.
It's coming from that this library that we've created the are live we need to pound include that pound
include and it's one of the Stanford libraries studio use angled brackets or double quotes everyone.
Yeah double quotes. Very good. So this is part of the string library like this.
And then when I control this, you see that that thing disappears over there. So it's saying hooray.
Actually, we got a good password here. So it's, it's failed to detect that.
I've actually used my username in my password. What's the next thing that I need to do?
Someone can raise their hand. What do we need to do to actually make this work then, and ensure that it can find that?
I've actually really use the word Sean in this password. And really, why is it not working right now?
Yeah, go for it in this work. In case there's a breakdown.
Yeah, perfect. And really good terminology there also. So it's case sensitive right now.
We need to make it case insensitive. I also like that you were like you projected really loudly so I could actually hear what you were saying.
And everyone around you probably heard also very you're going to get start for the day. That was amazing.
Thank you for that contribution. So it's case sensitive right now.
I have an uppercase and my username a lowercase s on my password, so I need some sort of function that will maybe change these both to the same case.
And we actually saw one of those already. But I'm wondering maybe limited scroll down a little bit there.
Are you seeing a function here that we could use to make our lives better?
Use shout it out if you're seeing it. Yeah, I could use to lower case and just convert both strings to lower case.
I like convert this to lowercase and convert this to lower case so that I have something like this.
If I convert both of them to lowercase, then I'll have lowercase sca and found here when this gets converted to lowercase s and it's
going to do to lower case like this and lower case returns the lowercase version of that string.
So that will just pass a lowercase version over here and we'll do two lowercase like this,
and I'll pass a lowercase version of that string over there. And I could give this a compile and run.
It's an it should now be detecting. Yeah, now it's detecting. Oh, no, this is about password.
Now there's a lot of stuff that's really bad about the way that I've written this program.
Or maybe I should say there are a few things that are really bad about the way that I've written this program.
Let's actually do let me modify this a little bit and then I'll and then I'll talk about some things that are bad here.
I also want to modify this so that like if somebody puts like random non alphabetic characters here inside the string,
I want it to be able to go through and detect that I do have E and,
and just kind of like strip away that number one and the apostrophe and the other number ones and just look at the
alphabetic portion of this password to see if the alphabetic only portion contains the username that this person has.
So let me actually just write some code that does that. I'm going to do another string here.
P zero. I'm going to loop through the first string P and just all of the alphabetic characters.
I'll add them all to this other thing called P zero, and then I'll check whether P zero.
So ultimately what I'm saying is I want P zero to have an S pass word stripped away.
I've stripped away here all the special non alphabetic characters. This is the string that I want to end up in p zero.
So I could just loop through P and start doing it. Oh, by the way, I mentioned last week that in C++ we need to initialize our variables.
If you don't initialize a variable in C++, what did I say it contains?
Garbage. Very good. But the cute creator is generally with the project files that we give you,
going to prevent you from compiling a program where you haven't initialized variables.
Here I haven't initialized the string p zero. But my code will actually compile and run just fine if I hit control R over here, let me save.
Oh, by the way, if you have this dialog coming up, save changes every time you go to compile and run your program.
Just hit this. Always save files before build and then you never have to hit that thing again.
It'll just go out of your way over there. Get out of your way over there. So this actually compiles and runs without having initialized p P
It's the it's the primitive data types that must be initialized.
If you create a string, C++ will, by default,
just make that an empty string with no characters in it and you won't get a weird you haven't initialized this variable.
Compile time error here. So let me loop through all the characters in this string P and I want to check if it's an alphabetic character.
Add it to the end of P zero. There are a few ways to do this.
I could do my traditional loop where I say four entirely equals zero is less than.
How do I get the length of this string so that I know how many indices to loop through in the string does?
What do you go for it? Yeah, very good P dot.
And then as you start to type here, it says, Oh, there's this, this function built into it called length that will give you the length of that string.
So I could do that. And then do you remember from last week that if I want to access a particular character,
you use these brackets like that to access the ith character of P and how do I read that out loud?
I don't say P brackets. I the way I say it out loud is possibly very, very good.
So I could do this way. But we also saw last week that there's another way to do this, which is to just the enhanced for loop,
the fancy for loop as I call it, and just say for every character, see H in this string.
P And so each iteration of this loop C, H, that local variable, it becomes the next letter in this string.
P So that's another way to do it there.
And then I could say if and this is what I'm going to ask you about in a second here, but if this is an alphabetic character,
so SCA and so on and so forth, what I'll do is I'll take that character and add it to the end of P zero.
And we saw last week that you can just use this to add a character to an end of a string.
You can just use the plus equals operator Here we saw last week a library of of functions that you can use on characters.
So we saw the string library for string processing stuff. Does anyone remember, if you like this, this may be more obscure.
Does anybody remember the name of the library that we had for processing character stuff?
Yeah. Go for it. Yeah. Amazing. Very, very good.
Very good record over there. Yeah. With CC type and this one goes into angled brackets.
It is a thing that is built into the C++, It's part of the standard goodies there and one of the functions that it has in it and by the way,
I mentioned last week, if you control click on one of these in the queue creator, you can go over here.
Oh my gosh, it's a list of functions. Does anyone see a handy function that you think just based on its name might tell us?
If a character is an alphabetical character, just shout it out if you see it, it is Alpha right here.
Okay, so that's going to return true if we have an alphabetic character false otherwise.
So control, click on those libraries is going to give you. Oh, now, now I'm lost.
Okay, now I'm back. Nobody panic is going to give you a list of the core functions that are there.
Or if it's a Stanford library, go see our documentation on the course website.
So if this is an alphabetic character, add it to the end of P zero.
And now when I give this a compile and run that's actually working again and detecting that embedded in that password,
even though there are numbers and symbols everywhere,
it detects that amongst the alphabetic sequence only there is the name SCA, and this person has put their username into their password.
So that's just kind of a refresher.
And you're doing some things like that as you're working on your current assignment and you're you're manipulating pieces of a string,
especially as you get to that sound X portion of your current assignment. This code is terrible.
Let me talk about a few things that are terrible about this code. One is I'm using really garbage variable names.
So I've got a string as a string P a string P zero.
What do those even mean? Someone who loads up this code now has an extra cognitive burden placed upon them because
they have to look at this code and figure out what was this person trying to do, what's going on here.
Whereas if you just do something like this, if I just called this username and I just called this password and I called this,
maybe this is the alpha portion of password like that,
do you see how this starts to make the code a whole lot more readable that someone
opens it up and they immediately know what those three variables stand for,
what these three variables do, And so they can start to parse the code a little bit more quickly and be more productive as a software developer.
And so I'll just do that down here for every character in my password.
If it's alphabetical, let's add that to the alpha portion of the password.
And then down here I want to check the alpha portion of the password, whether that contains the username.
And so the code that I have written here, what I have one, two, three.
So the code that I have written here is now just a little bit more readable in terms of
I have words that are actually explaining what's going on instead of just weird symbols,
P, zero and S and so on and so forth. So that's one thing.
Another thing that I don't really love about this code is I'm just dumping everything into Main instead of taking my problem and
breaking it up into its constituent components and then moving each of those constituent potent components to its own function.
So this is a task called functional decomposition.
And if you took one of six a here, what we often do in one of six eight is we just give you the functions that we want you to write in a program.
Well, in P, we're starting to move into the realm of we want you looking at a problem and saying, how can I break this up into functions?
What are the appropriate functions? And doing it yourself as you work through the sound X portion of assignment one,
there is actually a guide there that says Here are the main tasks you need to complete to solve this portion of the problem.
And then at the bottom it says break this up into a bunch of different functions. But as we go through the quarter,
that instruction will disappear and it will just become part of the culture of we break a sophisticated problem into individual pieces.
So first of all, I want to say that one of the problems I want to check is, or what I'm trying to solve here is, is the user name embedded in.
The password. So maybe I should just make that a function to begin with and it'll return a true or false.
So I'll say like. Password contains username and password a string.
I'll pass it. My username and my password. And I just want this to return.
True or false? Whether the username is contained within the password.
Well, I've identified two main tasks here. It's the two individual chunks of code that I have going on down there.
Two individual tasks that I want to complete in order to finish this overarching task.
One is I want to extract the alphabetic portion from my password.
That's what I was doing here in this piece of code. And so that becomes actually then its own function.
So let me do this. Let me just do a string and I'll call this alpha portion of password equals.
And I'll write an extract alpha that takes this password and it just extracts the alphabetic portion of that.
So let me write that as a function. This is extract Alpha. I'll pass it some string.
I'll just call that string s because this doesn't need to just operate on passwords.
This could operate on any string.
So here, I'm not using a meaningful variable name on my nine because when I extract the I've got a component of some string.
That string doesn't have to be a password. It could really be anything.
And so this function, by giving that variable name s, I'm saying, well, it's just a string.
I don't know what the string means necessarily.
If someone calls this function, maybe someone has to call this function for other purposes than what I'm using it for online currently.
And so just call that s locally. And then what I had here was this basically.
So I had some string I'll call this result and then I'll loop through all the characters and s if that's the thing there that I want to.
Oh no, it's doing this thing over here. Result plus equals that. And then down here I'll just return the result.
So I've taken this portion of the code and I've isolated it inside its own function.
And then the other piece that I wanted to do was once I have that, I wanted to do a string contains.
So let me just do a string contains on two lower. That's kind of a separate piece of this function over here.
So string contains to lower on.
I want to know if the alpha portion of this password lower case contains the username like that, and maybe return this result over here.
And then down here I can check and I can say if password contains username and I just type password
and username over here or I guess I actually refer to them in a different order up there.
I did username and password, so let me do that down here. This is username and then password like this.
So if the password contains a username then I have an issue over here.
So this code, there's actually there's some problems with the code and I'll talk about this in a second,
but this is starting to become a whole lot more readable that I'm 
I've stripped away the two lower calls and I've just written this out.
It's almost an English sentence at this point. I'm saying if password contains username, username, password.
So someone could reasonably look at that and say, Oh, you're checking if this,
if this password contains this username, that's what the function tells me it's doing over here.
And the person who reads this line of code isn't burdened by weight to lowercase to lowercase and having to ask what's going on there?
They're not having to read through this piece over here.
If they want to know the details about what this function does, then they come up here and they look at the details of what the function does,
and they get kind of English pros as they look at those pieces of the function.
Also, they're like, Oh, you've got this extract alpha function that I've got up here that it's yelling at me about this,
that it wasn't created when I started to write this piece of code here.
And then I'm checking if this thing is contained in that thing over there.
One of the things that's bad about this right now is so Extract Alpha was not declared in the scope.
Did you mean so string extract What extra alpha.
So it's, it's complaining actually about that thing over there. It's giving me.
Oh no. It's actually if the password contains the username it's saying oh no, the bad result.
So this is actually it's checking whether the password contains the username.
Oh yes. It's returning the right thing here. Right. Like if the string is contained in the other string, then the password does contain the username.
If you wanted to invert this, you could maybe do like bool is good password like that and then invert our logic is good password.
And then here we loop, loop and loop and then switch that around and write an is good password function and
what's nice about that now also about doing functional decomposition here and the fact
that we've repaired all of that stuff up to its own function up there is if we then want
to change what our requirements are for something to be considered a good password,
then we can just do that within this function and we don't have to maybe look at ten different places in code
where we were replicating all of those pieces of this code and then have to update those ten different pieces.
All of our good password functionality is now self contained within this one function.
If we want to change our password requirements, we just come to this one function and change everything that's here and we're good to go.
What's bad about the way that I just changed that? Yeah, I go for it.
Yeah, Very good. This is still returning true. If the password contains the username.
If the password contains the username, I actually want to return false and say that is not a good password.
So what can I do to line ? Can someone raise their hand?
What can I do to line to ensure that this actually returns false if the username is inside the password and true if it's not inside the password?
Yeah. Go for how you can put it. Actually. Very good. We'll use very, very good.
We'll use the boolean operator to invert that. True. False.
And so here we have Oh no about password.
And if I get rid of if I obliterate the existence of Sean in that password, then it goes hurray, that we have this thing over here.
So functional decomposition is all about writing code.
First of all, that is really easy to maintain, really easy to read, and to breaking things down into logical constituents and whatnot.
The other nice thing about using functional decomposition is if this function were not working and I were just if this code weren't working,
just had everything slopped into mean, we then have the problem of, well, why is this not working?
Which piece of the code is broken? Is that the part where I tried to extract the alphabetic letters for my password?
That's broken? Am I making a broken call to the string contains function?
Did I forget to lowercase everything? And that's why things are going badly.
Did I forget to invert my logic with the exclamation point there?
So by breaking things up in the functions,
we've also created a situation where we can now test individual components of the code a little bit more easily.
And for that, as you've seen working through Assignment one already, we have a testing framework built in for you in in the Stanford C++ libraries.
And for that we include simple test start H And I just want to show you a little bit of let's write some tests on this extract Alpha over here.
So to create a test of your own in your programing assignments this quarter, we'll do student test.
And then in double quotes, you give some description of that test.
So this is going to be various tests for extract.
Alpha like this. And then we call that function and see what its results are using another piece of the built in testing framework.
We have this thing that we've created for you called Expect equal, where you can make a call to a function.
Like if I call extract alpha and I pass it.
Something I can say then what I expect that to be equal to.
Let me actually copy and paste this down here and do a bunch of a bunch of test cases here.
So one thing that I want to check is when I extract alpha.
Oops. Actually, let me not do that. When I extract alpha on this extract up, it only takes one parameter.
What am I doing here? Okay.
When I extract Alpha on this. Oh, well, I expect x a and s password like that.
That was actually a little bit painful to do. So that's one test case.
And actually, if I just run this one test case, let me comment.
All of those things out there. If you want to run your test cases from Main, what you do is you do run simple tests.
Like this and then all tests like that and we should be able to run.
And you see, I get a green light here. It's happy that I passed all the tests for Extract Alpha.
There was only that one test there. My question for you is what are some things that you're thinking as you look at that function?
Extract Alpha. I've only got one test case so far.
What are some scenarios that I haven't tested that I should test?
So extracted the alphabetic portion of of this thing over here.
Any other thoughts for things that we should test? Situations that weren't accounted for before.
Yeah. What if I have no alphabetic characters at all in the string and it just looks like that?
Well, if I extract the alphabetic characters, there should be nothing left over there.
So I'll test that case as well. And I can actually just like, comment these out really quickly.
Give us a compile and run and hooray. It's still passing all those test cases.
I get that green light over there to say that everything is good. What's some other stuff that you're thinking that I haven't quite tested yet?
Go for it. Yeah. What if I just pass out the empty string and say, Hey, peel all the characters out of this?
So when I was working at Google,
we had a rule of thumb that any function that you could pass stuff to test it with inputs of length zero one, two and three.
So what you're getting at is I haven't tested it with an input of length zero a string as zero characters in it.
So yeah, I'll leave that there. The empty string. If I strip all the non alpha characters away, I should get the empty string.
What else are you seeing that I haven't tested for? So, yeah, go for it.
Yeah. What about a single character? So kind of building on what I was saying about zero one, two or three.
So what if it's an alpha character? What if you have a single character that is not an alpha character?
So we should test that as well. Another thing that I haven't tested for is what if the string started with a non alphabetic character?
And had alphabetic characters that came after that. So I've not tested that scenario.
I've I've I've tested with none of the characters at the beginning of the string, but none of that alpha after it.
So what if I did something like this? Does it manage to extract the A?
Sometimes we have bugs in our code where we start a loop and we do something weird
at the very beginning of the loop and miss something at the beginning there.
And then and then as we're moving forward that the thing just doesn't work.
Or conversely, what if we have a string that ends with an alpha, a non of a character, but it has alpha characters before it?
And is that going to actually work over there? And here we're passing all those tests, so I want you to be thinking of those things.
Or what are the men down, man down. Someone's falling asleep. Back in under the white shirt.
I wake up. Get up, get up. Oh, okay. I of having movement there is like, we've lost somebody.
Is he dead? Do they bore you to death? There's probably a lot of paperwork I have to fill out.
If I bore someone to death this semester. Sit up straight, if you don't mind, please.
And everybody take a chance to wiggle out your shoulders and get the blood flowing.
You need to do it especially. But it's. It's not hazing if everyone's doing it.
Okay, we're going to do that. All right.
Come back. Come back with a nice little break there. And we're all awake now and back.
I do that because I care. By the way, this is going to be on the exam and I want you to get a great score on the exam and be awake for that.
Okay. Let's shift gears a little bit then. What I what I want to talk about next is I want to move into abstract data types.
And I have two abstract data types that I want to introduce you to today.
So abstract data types, these are ADT is for short.
So I want to get into some of the stuff that's built into the Stanford C++ libraries that you can use to solve problems.
These are data types that you can use to collect and organize related pieces of data.
And I call them abstract because the data types we're going to look at,
we're actually going to take what we call the consumer view to begin with where these are just implemented.
And we don't necessarily look at the implementation details behind the scenes.
So these are an idea, an abstraction that are implemented in code,
but it won't be until the later half of the quarter that we actually look into the code behind these data structures.
To begin with, we're just kind of going to approach the ideas.
One of the reasons we look at abstract data types in a class like this is so that we develop a common
vocabulary that we can use when talking with other software engineers and we're talking about problem solving.
So the more abstract data types you're aware of, the easier it becomes for you to say to someone else in the field, Oh, instead of saying like, Oh,
I need to have a bunch of pieces of information that are stored in these variables
that are lined up together and and like give a really detailed explanation,
you can just be like, Oh, I'm going to use an array or I'm going to use a list to solve this problem.
So abstract data types, part of this unit of the course is just solving problems with new data types that we're going to introduce you to,
but also building up that vocabulary that enables you to communicate with other developers efficiently
and share ideas with other people because you have a common language that you use with them.
The first one that I want to introduce you to is the vector. This one again is built into the Stanford C++ Library.
A vector is actually if you've coded in Python, it's really similar to a list, and if you've coded in Java, it's very similar to an array list.
And so this is already where the power of abstract data types comes into play.
Those ideas are implemented differently across languages, but the abstraction, the idea itself is the same across languages.
So if you've used Java and you know what an ArrayList is, you already know what a vector is in C++,
or if you've used Python and you know what a list is, you kind of almost know what a vector is.
And C++, there's some interesting differences here, but a vector is just a list of elements, and it's ordered and ordered.
I mean, there's the semblance of what's the first element in this list?
What's the second element in this list? What's the third element in this list?
So it's some sort of ordered list of elements, and it expands automatically to accommodate new elements as you throw that into this data structure.
And so here's an example of what I mean by that.
If you create a vector that you want to put a bunch of integers into, you end up with something that looks like this in memory.
In C++, if you say, suppose you just want to have like three integers stored in a vector,
what I end up with are three boxes in memory that are indexed.
So again, there's some order. This idea of what's the zero element, what's the one element, what's the element of index two?
And I'll just put some numbers in here and like that.
So this is a vector. These are stored actually continuously in memory.
When you do this in C++, when you create a vector. And one of the nice effects of that because they're all right next to one another in memory,
is we know exactly where each element is located and C++ can jump to any element in the vector.
It can figure out the address where it's located in memory really,
really quickly and just jump there and get to that element and play with that thing really, really quickly.
The idea of a vector and then by the way, it expands automatically. So if I. Have a bunch of numbers.
Maybe these are just a bunch of, like, assignment scores or something, and someone completes another assignment in this class.
And then what I do is I just add to the end of the vector. I don't know, assume that the scores are out of 
I don't know why the scores are so low. I'm. So the yeah, I can just add to the end of this thing,
plunk a new one on there and it gets the next available index and vectors come up everywhere in the real world.
So we do use them in fact a lot to store numbers.
If you have a bunch of numbers that you're reading from a file, you don't know how many there are, just throw them into a vector.
The vector will expand automatically to accommodate all those numbers.
You want to read a bunch of strings from a file, maybe through the strings into a vector.
The vector will expand automatically to accommodate all the strings in that file.
You use vectors almost daily. One place where they come up in the real world to one place where they come
So these tabs are ordered this this idea of the TAB zero tab one, tab two, tab three and tab four.
And if you hit control T, because I know you're not moving your hand to your mouse and clicking this button over here,
you're optimizing your productivity and learning some hotkeys and control t to create a new tab that just adds a new one to the end of the specter.
And if you go to the open source for chromium actually and look into like how that browser window tab strip is represented,
when you jump down to that line,
you see it is actually a vector of this kind of custom class that they've created to hold all of the data that goes into a particular tab.
So this is actual real C++ code where you see vectors are used in the real world to solve this problem
of I don't know when someone opens their web browser each day how many tabs they're going to want.
Do they want one? Do they want three? Someone somewhere wants 
Someone somewhere wants more than that. I recently figured out how to count how many tabs I have open in my web browser on my phone at tabs open.
I probably. Yeah, it's tab. It's called I need to go through it and I close those, but I can't let go.
I feel like they were articles I really wanted to read anyway,
so you never know what kind of crazy person is going to want more than, say, like five tabs when they open their browser.
So you use a vector because it will expand automatically to accommodate new tabs.
Sorry, I keep moving around to the wrong where. Here's the queue creator over here.
Okay, so let's take a look at the syntax then for creating a new vector.
If you want to use the Stanford C++ built in vector, you have to include vector h like that in quotes.
And here's a weird gotcha. The vector dot h when you include that is a lowercase vector.
When you create a new vector down in main, we use capital vector like that.
With a capital V, there's a lowercase v vector that's built into C++ that isn't as cool as our vector.
And so you need to use the capital V four for the Stanford C++ vector.
The next thing you do, the other piece of syntax when you create a vector is in angled brackets.
You put what type of data you want to hold in that vector.
Now, if you've used python before, you're used to the idea of like a list can hold a string in one position and an integer in another position.
You can mix and match and it's just a free for all in Python.
In C++, our vectors are homogenous with respect to the data type.
If you create a vector that holds integers, it only holds integers.
If you create a vector that holds strings, it only holds strings. Let me create one that holds integers.
So you just put a data type. They're just the same kind of data type you would use to create a new variable.
You put that there, then you give the variable name for this vector that you want to create.
I'm just going to call mine V for now and you can put a semicolon there and then you've got an empty vector.
You don't need to initialize it, that's totally fine. Or you can use an equal and list the elements that you want to put in there.
And if you do that, you have to use curly braces and list those out with commas like this.
And now I've got a vector as indicated in the diagram above.
Let me get rid of a bunch of this code over here. Yeah.
So I have a vector as indicated in that one above. And if you want to print the elements in a vector,
you can access them just like that notation that you used to go through a
string so you could do four equals zero is less than I have for elements there.
I plus plus. And actually if you don't want to hurt code that you can do V dot ooh,
there's a little size function here that tells you exactly how many elements are in that thing.
And then you can do c out v sub I you can access those each element at that particular index.
So here max is and v sub-zero v sub one vs of two vs of three.
As I loop through it works a whole lot like a string as you go through that thing.
In terms of using this brackets to access something at a particular index there.
Now there is no index for in that. So if I did something like this v sub for well what you'll see is we get a crash and it actually tells
us like hey you tried to access index four in a vector that only had indices zero through three.
This is what the C++ vector does not do for you that the Stanford C++ vector does do for you in C++.
If you went out of bounds there and you access the index for C++ would just let you do it
and print some value to the screen and not tell you that you're like wrecking your life.
It would just let you carry on. And it's like, Good luck with that.
The Stanford C++ Library is like, No, we want you to be productive this quarter and actually, like,
not make your assignments feel impossible because you're running into weird glitches that you're not being made aware of.
And so it will tell you if you go out of bounds. That's the main reason we use the Stanford C++.
In this class instead of other vectors. So that's what's going on there. You can also use this with that fancy for loop.
So you could say for every integer I in this vector, print out that integer I this is a container.
And so I will become 
I is now the actual integers contained inside that vector.
And that works as well. You can use that kind of what we call the fence.
Well, I got the fancy for loop or the enhanced for whatever the case may be.
There are a bunch of functions built into the vector, as you could imagine.
And so for those functions I will refer you to actually in your notes for today,
I will give you a list of the most important functions that are built into the vector.
But remember, you can always go to the Stanford C++ libraries and take a look and be like, Let me go to the library documentation.
And oh, it's right at the top here. And we'll look at the vector and see all of these cool functions that are built into the vector.
One of the things that you'll see is there's an insert function and there is a remove function and and there's an add function.
I want to talk a little bit about those functions here really quickly.
So with the ADD function, if you want to do V dot add, that just adds something to the end of a vector.
And so if I do a V add up here before the loop.
All that's doing is it's going over here and plunking a at the end of the vector when to give this a compile and run.
You see it just kind of added a on at the end of the vector.
If you want to add something at a particular index, we use a function called insert.
And I, to me the word add sounds a little bit like just very casual.
I'm adding it in there in search, sounds a little bit more precise, a little bit more surgical, and that's how the insert function actually operates.
You give it an index like, say index one, and then a value that you want to insert into this vector.
And what it does is it goes and it puts that in index one and it scoots everything else over.
But this is actually a very slow operation. So check this out.
If I want to insert a index one, what I need to do over here is I need to take the and scooted over like that.
I need to take the and scoot it over to that position.
The is skewed over there and now that I skewed it, each of those elements over, I can go and put a here.
That's actually an expensive operation that would have to scoot each of those
elements over one by one to make room for this element at the very beginning.
And so I just want you to be aware of that. If you add something to the end of a vector, it's expected to be a fast operation.
We just Plunket at the end.
But if you want to insert something at the beginning that ends up being potentially a very slow operation to add to the beginning.
And our testing framework actually,
and this is again something that you're playing with an assignment one our testing framework actually reveals that to us.
So let me actually write a function that adds with the add function and a function that inserts with the insert function just really quickly here.
So do void vector add, and I'm going to take like some number of elements and just create a vector V
that holds integers and I'll say four I equals zero is less than an I plus plus.
Let's just add all those to the vector. So this is just adding in elements to some vector.
And then let me do that with insert. Vector insert and I'll say let's insert at position zero the element I.
This version of the function. The second version is so slow compared to the other version of the function.
The first version of the function. Just like punk, punk, punk, punk, punk. And it's finished.
The second version of the function, it functions like punk school punk.
And that's like scoot, scoot, punk, scoot, scoot, plunk in order.
Did it plunk something new into the beginning of the vector?
It keeps having to scoot, scoot, scoot so that by the time you insert the thousandth element using line it has to be continued.
Scoot a thousand elements over and then it can plunk something in the beginning. Are you following that idea of the insert function?
Has to scoot stuff over to make room and therefore is very slow.
If you want to then check that out, you can create a test case.
So let me create a test case down here. This is just going to be a maybe a provided test.
So we'll give you provide it to tests with your assignments that you don't want to modify. Those are tests we've created for you.
So this is runtime comparison. I'll do size equals like this, and then I'll do time operation and say how big the input is.
And then you just call any function that you want. This time operation is built into the Stanford C++ libraries.
So Time operation and I'm going to call vector vector ad like this and I'll pass
it just this size and then I want it to do the same thing with vector insert.
I don't know what I was thinking when I put this doo doo doo doo doo doo doo doo doo doo doo.
Okay. Ah, no. Yeah. Okay, So we'll do it over there.
And then when I run all tests, we should see. So this is going to be run simple tests.
All tests like this. When I give this to compile and run, you'll see that it actually takes some time over here.
And it says the add function finished in .seconds, The other one finished in .seconds.
So .to .
The second one was times slower than the first one.
Well, who do you think Google is hiring the person who wrote the first one or the second one?
The one that's really fast or the one that's times slower and it gets worse.
Actually, the bigger your input is. Suppose I make this and give the second pile and run.
It's still actually running over here. It hasn't even completed that second version of the function.
It's actually going to take a little while here. I think I timed it last night and it was taking about seconds on my system.
Okay, so it's seconds versus so let's do divide .
This was times slower. The larger your input, the greater the disparity between the two.
This is actually like a really, really slow, slow version of adding something.
Now, of course, I'm getting those elements in different order there, so maybe you need them at a different order.
I need to change your loop to make that happen. But the insert function is slow is my big takeaway there.
The other thing that I want to show you really quickly is this There's a grid that is built into the Stanford C++ libraries, so a grid.
And once again, if you create a grid, it's another data structure where you have to say what the data type is.
It's homogenous. So create a grid of integers over here. A grid like this, when you create a grid, you basically get this except two dimensions.
So let me do this over here.
Let me just create two rows. Oh, no, this is actually really hard.
Okay, so let me just create two rows. So the rows are also numbered.
Like I have rows. You're a row one and the columns that are numbered.
And by the way, the columns, just like a column in the real world, is like a vertical pillar.
The columns in a grid are vertical vertical entities.
So this is a column. This is a column. This is a column.
This column. This has two rows but four columns.
And when you create a new grid, one of the things that you need to specify when you create your new grid with the
standard C++ libraries is how many rows there are and how many columns there are.
And you put that at the end over here. So I'll do two rows and four columns.
The phrase that I want you to remember is row major.
The rows are the major event. When we talk about grids, the rows always come first.
So here the number two comes before the number four. I've created two rows and then four columns.
The columns come after. These are really good for all kinds of problems.
You can use this to represent a game board. You can use this to represent a map.
You can use this to represent a spreadsheet. There are all kinds of neat things that you can do with grids.
Yeah, there are all kinds of neat things that you can do with grids. And in order to access a particular cell within a grid,
you the syntax is something like is this you actually use two brackets and you
give the row you want to go to followed by the column that you want to go to.
So if I go to row one, that's this row here and column two is this column here.
So G sub one, sub two is accessing the element that I have indicated on the screen right there.
And if you wanted to go through and if you wanted to go through and actually like initialize these values, I think you can do this.
You can do. You can separate your rows like that.
You can be like, one, two, three, four, like that, five, six, seven, eight.
And so I've put two rows there within the curly brace notation,
and then we can just do a four loop that goes through four equals zero i's less than g dot.
And it has a function built in. It's oh no, it's not finding it because I haven't gone up here to include the Stanford grid.
I need to include h like that. And so now hopefully when I do the dot operator Yeah, it's like we have the number of rows,
so let me loop through all of the rows and then within this loop, let me loop through all of the columns.
Like this. And I can just see out. G sub I sub j and l like that.
And ono would expected a hoodie who before the thing.
Oh, I think you might just need to do that to create these.
Oh no. It's just not happy with that initialization syntax. Okay.
So that's just not a thing that we can do over there. Let me do this and just go through and print out all the values that are in that thing.
No, it's running the simple test. Take away the simple test bar like this.
Okay. And you see that we just have I guess we've gotten kind of lucky there.
We just have a bunch of a bunch of stuff in there.
Let me maybe. I don't know. Let me just put some stuff in there. G sub, I suppose.
J equals I plus J times nine.
And then when I go through and I print all those out, okay, you see that we're getting actual values in there in that grid as we loop through.
And I did have eight values in that grid, two rows and four columns.
The final thing that I want to mention to you is if I pass this vector to a function,
what happens when I pass that vector to a function by value is I get a whole extra copy of that vector in memory,
and that is going to take up extra memory, first of all.
But it also takes up extra time. If I have a function that operates on vectors and I do something like this,
I want to do like process vector and I pass it v like that, it creates a whole separate call.
So if that has a billion elements in the vector, what happens is I've got a billion elements in the spectrum.
When I pass it over to a process vector, I create another copy of those billion elements.
That takes time and space. What can I do to a function?
Maybe this is an unfair question. How can I write a function that won't duplicate all of the space associated with this thing?
So there's actually just one copy of that thing if I want to pass it to a function.
We saw last week we could write it. What kind of function? Yeah.
So if I want to do process vector and I want to process that positive vector, I would put an ampersand there after the data type like that.
And then this would actually when I pass this to the function, it just passes a little piece of data telling it where to find that vector.
This saves time and space. And check this out. This wasn't working last week, this piece.
Notice that this V, it's very subtle. Can you tell this V is italicized right here.
Okay. When you have a pass by reference function, when you call it your parameters get italicized so that you can actually tell in
the creator is your function passing receiving this by reference or by value.
Thanks for being here. I'll see you on Wednesday for more material.
And I'll now turn this on some quick announcements before we dig into course material.
So don't forget assignment one is due Monday, p.m. How many late days do you have to play with this quarter total Shout it out four.
And how many can you use that Most on one assignment? Two. Very good.
Remember you have those quizzes, those lecture quizzes that are due at a very weird time, Wednesdays a.m.
They're releasing every day after lecture round two to give me time to run back to my office and update things if I need to.
But those are due in batches. Typically Wednesdays a.m., so just kind of like minutes before class.
I just want to be sure everyone's kind of caught up on a certain amount of material each week before we dig in on Wednesdays.
And then the other thing I want to mention before we dig into material today is
section problem solutions will unlock automatically on the course website on Fridays.
So if there are a section problems that went a bit too fast for you or you didn't quite understand, be sure that you're checking those out.
Be sure you're coming to layer to ask questions about those things.
And then also with the section problems, be sure that, you know, you're such a leaders can't always get to.
Okay there's like a lot of chatting let's let's if someone's chatting next to you can just poke them really quickly and ask them to stop chatting.
So I've mentioned that a few times. That part of that is I just want people around you to be able to hear what I'm saying.
But also it's just distracting to me to try to talk as other people are talking.
And then when you're distracting me in that fashion, you're robbing other people of a really of a honed lecture experience where I'm actually,
like, focused and able to kind of be on top of my game.
You're robbing other students of that. If you're sitting here chatting through lectures, I'll ask you to not do that.
So the other thing about section problems is the section leaders can't get through all of those problems every week.
So we do rely on you to go and look at those and and work through any of the ones that the section leaders can't get through.
That's kind of that's kind of on you. So today we're continuing our discussion of eighties.
What were the new eighties? The new data structures that we looked at on Wednesday.
You can just shout out if you remember what those two where we saw the the vector and the grid.
Very good And what does the A so T the d t is data type.
What does the A stand for Abstract. So remember, we're looking at these from what I called on Wednesday, the client sides perspective.
We're looking at consuming these data structures. They already exist.
We haven't looked at a lot of implementation details behind the scenes for
these data structures and we're just looking at solving problems with these.
So that's the consumer or client side of using these eighties.
We will look later this quarter how they're actually implemented after we've solved some interesting problems with them.
We'll dig, we'll kind of look under the hood and dig into the weeds with those things there.
But for now, we're looking at these as just kind of like abstractions. So they exist.
Their idea is the implementation details are maybe a little bit hazy. One of the things that I mentioned with vectors that I really want to reinforce,
this is like a key concept that is kind of central to the themes of 
B is if you want to just add something to the end of the vector using the add function that's built into the vector class,
that's just usually a quick operation. Just go plunk and you've added something to the end of the vector.
But remember I mentioned that if you insert something at the beginning of the vector,
you have to scoot every element over one by one in order to make room for that new thing.
And that's a very slow operation. We timed that actually on Wednesday, and so that's much slower than just using AD repeatedly.
It's much slower to use insert repeatedly. And that's the kind of thing that we want to be aware of as we're writing programs.
And that's the kind of thing that distinguishes someone who really knows a lot about
software engineering from the kind of person who maybe took a boot camp somewhere,
learn some basic coding, pick up some basic code. It's like, Oh, I know how to call these functions,
but they don't know what's happening behind the scenes or what the runtime implications are for using certain functions.
So I want to be sure that I wanted to be sure that I reinforce that, that that's actually a really important concept.
The distinction between AD and Inserts runtime.
They're the two new data structures that I want to introduce you to today are called the Stack and the Q.
So we'll look at Stacks and Qs today. I'll start with the stack, and I'm going to tell you a little bit about how the operations work with the stack.
I don't think that either of these are particularly complicated when you start consuming them.
When we start to implement them, that's where the details start to get a little bit crazy.
But if you look at these and you're like,
this idea seems kind of straightforward and you're worried that you're missing something, no, you're not missing something.
The ideas themselves are kind of straightforward, but then using them in code can be a little bit more complicated.
So we'll look after I explain what these are, I'll tell you. Like, here's why we would want to use this abstract data type.
So let's kick it off with stacks. With stacks, we actually support a limited number of operations.
With any data structure, we typically want to be able to insert stuff into that data structure, and we call the insert operation.
When we're talking about stacks, which we call the insert operation Pop.
So the insert operation or sorry, the insert operation is called push to insert something into a stack.
If you want to remove something from your stock, that removal operation is called pop.
And beyond that, the stacks don't really support a whole lot of additional operations.
We can do things like check if they're full, check if the data structure is empty,
check the size of the data structure, how many elements we've put into the stack.
But. Do not support other operations that you might support with with a lot of other data structures, like there's no search operation.
So if you create a stack that you put a bunch of integers into,
there's traditionally no operation that will allow you to search through that data structure and see if the number is in there or not.
If you have some program you're writing where you're like, I need to be able to search to see if the number is in this collection of data.
Then the stack is probably not the way that you want to go. It just doesn't support that operation.
So it supports a limited set of operations. The insert and the removal are called push and pop.
And the way that a stack works, actually, it's very much just like stacks of anything that you've encountered in your life up until this point.
So you have a stack of papers. You just stack papers on top of one another.
Or if you have a stack of plates, you've seen plates stacked on top of one another.
And if you have a stack of plates and you want to, you maybe you're washing dishes and you put another plate onto that stack.
What nobody in their right mind does if given a big stack of plates, once they wash another plate, they want to add it to the stack.
No one is like lifting up that stack. And then like with their hip trying to, like, push another plate underneath that, that just wouldn't make sense.
If you want to add a plate to a stack of plates, you put it on the top of the stack.
And in terms of of eight stacks,
that's the same thing that we do with eight with this abstract state of type is you have a stack and you want to add something to that stack.
You only put it on the top. That's the only thing that you're allowed to do with the stack.
With this data type, you're not allowed to insert something like in the middle of the existing pile of data you have.
You're not allowed to go put it at the bottom. New elements just always go on the top.
And similarly, if you remove an element from a stack, you always just take the top element from that stack.
So again, if you think about a stack of plates,
unless you have like an attachment to a particular pattern of plate and you have a bunch of different fancy patterns or something.
Most people aren't like, Ooh, I need a plate to just go have a sandwich.
They're not like lifting the stack of plates and trying to take like that one that's like third from the bottom or something.
You just take a plate off the top of the stack. And that's how this data structure works.
Now, visually, here's how I actually wrote a little program for you to visualize what's happening with the stack.
Let me talk about these operations I've talked about like pushing pop. We can put things in and pull things out of these data structures.
I mean, with most data structures, you want to be able to do that.
There's actually a fun, exotic data structure called a bloom filter that doesn't allow you to remove elements.
Traditionally, once you've added elements to that data structure.
And and also sometimes when you ask a bloom filter, we won't talk about this one this quarter.
It's just neat. If you want to like to go back and see what it's all about.
If you ask a bloom filter like, Hey, is the number of in there, if it's in there, it'll tell you.
And if it's not in there, sometimes it'll lie to you and tell you, Yeah, the number is totally here.
And so, like, for like, hopefully as you go through your, your other if you go on to other computer science classes,
you'll see interesting exotic things like that, like data structures that lie to you sometimes.
The stack never lied to you though, so we can push and pop peek is what we use or top is a synonym for peak.
This is what we do to just kind of take a look at the top element of our stack and then we can check if it's empty for a look at the size,
clear that thing out. So let me actually get this going here. Let me add some elements to my stack.
So I've written this program that just kind of has like a command text driven
interface where I'm going to add stuff to the stack and just trigger This works. So suppose I create a stack of integers.
Well, when I add the number ten to my stack, this is what my stack looks like so far.
There's just the number ten and the top element of that stack.
You can imagine this is just like one plate with the number ten printed on it.
The top element of that stack of plates or stack of integers is just that element that we have right there.
And if I push another thing on here, like 
goes on the top of the stack and you can see that I have that little arrow in the top pointing that thing over there.
And if I push goes onto the top of the stack.
And so these operations push and pop are the only operations I have to insert and remove things from the stack.
There is no operation right now that I can run that just like pulls the ten out but leaves the rest of the stack in place.
I can't just pull the out and leave the rest of the stack intact and have the to spawn in the on the turn.
If I want to get to that I would have to remove the and then get to the 
And that's kind of an expensive thing to do.
If you want to go find an element, you'd probably use another data structure if you need to support that operation.
And so if I push a on top of this, then the forces on top of that.
Now, if I pop, remember the thing that I said is pop removes the top of the stack.
This is not a trick question. If I type pop, what element should come out of this if I've implemented this correctly?
Everyone. Yeah. So goes poof, it comes off the top.
So you easy. We popped and then beneath that we're still left with the ten.
And if I pop again what should come out everyone. Yeah. The is next.
And so on and so forth. And then if I want to look at the size, there are two elements in this stack is the stack for No, it's not full.
I just could add that function to always return false. I assume I've got more memory and I can add more elements to the stack.
Is it empty? No, there's stuff in there. It's not empty.
And then if I continue to pop, you see, the size has now become one.
And if I pop again, the ten should come out and the size is now zero.
And if I ask, is this empty? Yeah, it's empty. There's nothing in there.
So if I put some more stuff in there, let me get these elements back in here.
The other command that I had was peak or top.
Those are synonyms for one another. Peak or top. What peak or top does is it just peaks at the top of the stack.
So you can imagine a person is walking by a stack and looking at a stack of plates over here, like what's on top of the stack.
And they just see oh is on top of the stack. Or if you imagine these are some sort of silo,
you can imagine a person like climbing up the side of the silo and kind of peeking down into the silo and seeing what's on top there.
And so when we peek what you'll see here, I've got ton.
When I peek, it's like a little person dancing on the edge of the top of the stack.
And they peek down here in the element that they see on the top there is the 
The peak operation does not change what's in the stack.
It just looks at what the top element of the stock is. But nothing has changed here.
So you can peek all day long and just nothing is changing.
It's not until you pop the stack that you've actually removed that element and then if you continue a peek,
you're just seeing that peek does not remove anything. It just checks out what that top element is.
There is the idea, are you following the idea?
We're pushing stuff into the stack, popping stuff from the stock is that follow able So you might think then, well what can we use this for?
Like why would we want to use stacks? And this one is actually really ubiquitous in computer science.
It comes up in a lot of problems. And even actually in one of your upcoming assignments,
what we'll do is we have a problem that we're going to give you where you use a stack in the problem and you solve a particular problem with it.
And then when you switch it out to the sister data structure that we're talking about later today,
the Q it's the same algorithm, but you just replace the stack with the Q and it solves a completely different problem.
But there's two problems that you'll be seeing in an upcoming assignment using the Stacks and Qs rely on these data structures.
So one of the things that this is that these stacks are really good for is reversing things.
So if I clear out my stack and I put a string,
suppose I have a string like muffins and I want to I could do something with a stack like loop through and put
those characters into my stack so I could do actually let me switch over and actually start coding this up.
Do this for reals is with the Stanford stack. So let me create this is going to be stacks and I'll create this program here.
I'll show you. This is built into the Stanford C++ libraries. Let me just kind of show you a real example of this thing in action.
So first of all, if we want to use stacks, we need to include Stack H, and we're using double quotes because this comes from the Stanford Library.
There is a stack built into C++,
and I'll actually show you that stack in a minute and show you one thing that the Stanford stack does that the C++ stack does not do.
But for now, if I want to do this, this is my stack. The syntax for creating a new stack.
It's very much like vector or grid.
Let me say this, by the way, if I did vector like this vector V, can someone raise their hand?
And I mean, assuming I've included vector not h, what's wrong with this syntax for creating a vector right now?
What have I done incorrectly? What are you seeing here.
Yeah. Go for it in the in the jacket right here. Yeah. Yeah, Very good.
And what do we need? Like, what exactly should I type here to say? Like, if I want it to hold integers, what exactly should I type here?
You all can just shout it out if you remember right. Yeah. Angled brackets and then the data type in here.
So the syntax was vector and then you do a data type.
So by the way, you could create a vector that holds strings. You just take string here or if you want to hold a bunch of char.
So you type char here, you can put any all the data type that you want there.
And then the variable name. What else is wrong about the syntax right now for creating a vector?
There's a key issue for it. Yeah, we want to use a capital V for our vector.
So the vector built into C++, it doesn't need to have a vector built into it has a lowercase v.
The uppercase v is for the Stanford vector.
The libraries are all using lowercase there, but the actual data type, we need to use a capital V.
Okay,
so we follow a similar syntax to create a stack you stack and then whatever data type you want in that stack and then you give it a variable name,
I'll just call my stack.
S So actually I'll just uncomment this one here and now I've got a stack and if I want to push stuff into a stack, so check this out.
I started talking about the string muffins. So string. Oh, well, now I want to call my string s to I'll call str, so I'll call that muffin.
And let me loop through every character in the muffin for char c h in.
Can. So I need you to whisper quieter when you're chatting.
If you don't mind. I don't mind that you're having a conversation. But if I can hear it up here, that means you're bothering people around you.
Okay? Okay. Thank you. Okay, so if I.
One of them loop through every character in this string and put it in the in the stack I can do for char or c h in my string.
Let's just do start push. And you see that we're using this push operation here.
That's the name of the function. We'll push that individual character into the stack.
And then I want to loop through and just empty out the stack and print all these characters as they come up.
So I could do four or actually let me do a while loop here.
Just say while the stack is not empty. So there's an is empty function built into the stack.
And I'll say, while it is not the case that the stack is empty, that means there's some stuff in here.
So let me print out the stuff that comes out. So I'll do when I call pop.
It not only removes from the stack, but it returns to me what it removed and what it returns.
I'll just send that to C out to print that to the screen. I'll just do that there.
And then at the very end of it, I'll do see out and out like this.
And if I give this a compile and run, Oh no, I created this to hold integers instead of chars.
So I'm getting what was the,
what was the name of the encoding system that I mentioned is used to represent every character using an integer that began with a everyone ASCII.
So I'm getting these ASCII values here because I created a stack that holds integers.
If I change this to be of a char data type, then I actually get Oh no, I forgot to put an s at the end of muffins.
Okay. So muffin spokesman spelled backwards is sniffer.
That's important information for you. Does anyone else have a fun word that when you spell it backwards, does something fun but not palindromes?
I don't want a palindrome any any interesting words where you're like, Oh, if you reverse this word, it gives us an interesting result.
No one doesn't even want to raise their hand. What mirrors what happens if we do like MOOC like this?
We just get exhume. I genuinely don't know what that means or why that's funny.
Is this dirty? Is this, like, X-rated?
Is it someone over here said, Yeah, it is. I'd like someone to contact me after class and let me know what that means.
I kind of. Okay, we'll get well. I'll come back to that. I'd like to talk with you after class.
Okay. I don't know whether we're going to know if I'm saying a naughty word in another language now or what's you're like.
This guy's really old. He's not going to know what this means. You're right.
But that's concerning. Okay, So stocks are really good at reversing things.
Here's another thing that stocks are really good at how stocks are actually used in pretty much every program that you write behind the scenes.
There's this thing called the call stack that keeps track of where we are in functions that we write.
So check this out. Suppose in main I call the function X, and then up here in my X function, what I do is I call a function named Y.
And what I do up here in my Y function is I call a function named Z.
And what I do appear in my Z function is I call a function.
Well, maybe I'll just return at that point and say, I'm finished with this.
So when you have a program that from main calls X, an X then calls a function Y and Y calls a function Z,
and then Z terminates your system as it's executing your program needs to know like who Z is finished.
Where do I go back to What line do I continue execution of this program?
And to do that, your program uses something called the call stack or the program stack, the call stack or the program stack.
And so what happens here is these literally get placed into a data structure, a stack behind the scenes.
So main gets put on the stack when you call it,
then X gets put on top of that and then information about the Y function call and then information about the Z function call.
So when Z finishes what it's doing, we pop it off the stack and what do we get?
Then when we peak at the stack, what function was underneath that Z just finished?
What functions underneath that Y?
Okay, I was starting to worry about your cognitive visualization abilities and then if we pop y, what is underneath that X?
And when we pop x, we're back to what function mean. Okay, so the stack actually helps us keep track of what functions we're at in the execution of
our program and go back to whatever function called the function that just terminated.
So that's used there all the time in programs that you're writing, every time you call a function, you're actually using a stack behind the scenes.
So stacks are really good for reversing things and stacks are really good for managing function calls in a program.
And I have another application that I'll show you at the end of class. If we have time.
You might be looking at this stack, by the way, and thinking, Oh, maybe I'll do a couple of things with this.
First, let me say this.
One of the neat things that's built into the stack in the Stanford stack is you can actually just dump the stack contents to the screen.
And this is not built into C++ as a stack. So if I add all those characters, again, I don't know what's happening there.
Let's go back to muffins. I now know it's no longer safe to pull the class.
I thought maybe someone had, like, a fun a fun, a fun word that they could share.
That was interesting if you spelled it backwards. And now I don't know what's going on there,
but you'll see here that you can actually just dump the stack to the screen and we get that
first line of output there that says what each of the individual elements are in the stack.
This is not built into the C++ version of the stack, so let me use that one here really quickly.
So if you want to use the C++ stack, what you would and don't by the way, use the C++ stack in this class.
It's forbidden. And don't tell anyone in the department I'm showing this to you.
They want you using the fact that we've built in Stanford's library.
But if I use the stack over here to use the C++ stack, you use a lowercase s like this.
And the syntax beyond that was pretty much the same, except you'll see here, it's already giving me an error.
It's like we it just won't even let me compile and run this program because it's saying that there's no way to take a stack,
the C++ stack, and just dump it to the screen. And when you're using a stack this quarter and you're running into bugs in your code,
we want you to be able to print it to the screen in a really easy fashion without maybe having to write a for loop to do it.
And so we've created one of the reasons we've created the Stanford C++ stack is so that you can do that and it just
makes your debugging life easier and moves moves you a little bit more rapidly forward through your debugging process.
Let me undo all that. We'll go back to the Stanford stack like this. Okay.
So you might be looking at the stack. Let me actually use the stack in a different context Over here.
You might be looking at the stack and saying, Wait a second, I could actually build that myself.
So let me do this void, Do something that creates a stack.
So this is going to be a stack that holds integers s and I'll do squish and I'll just do ten 
And then I could say like while not stack is empty, we can go through the spike, pop everything out of here.
So see, out. Let's just use Stop pop like this and I'll like that.
And if I give this, Oh, I didn't even call that function. So if I give this a compile and run, I'll call.
Do something over here in Maine. We should get. Oh, no.
Hoo hoo hoo hoo! Before the birdie Burr semicolon. You see, we get those things in reverse order.
I went ten, Those things get reversed via the stack there.
You might be looking at this and thinking like, Oh, I could do that actually, with a vector.
So, I mean, if you think about how that stack is growing that I'm going ten, 
You could do that just with a vector. You could go ten, 
You could just add elements. Director add ten, adds at 
So I could actually switch this out for vector. So do vector.
So let, let me do this is like alt do something.
It's like an alternate function. It's not like the radical right or anything like that.
It's just the alternate approach to doing the same thing, which is I want to get this in a particular order over here.
So in order to add this thing I could do and maybe we should actually call it v v add like this.
No, come back like this. We have like that. And then as long as this vector is not empty, my question for you is here what index?
And there is a removed function built into the vector. The vector class.
What index would I want to go to if I wanted to implement a stack like behavior?
So remember I added ten because we're getting added to the end of the vector.
If I want to get a stack like behavior, I now need to get or ten and only get ten.
Can anyone raise their hand and say, What index should I go to and remove something from the vector?
Then how do I know what index to go to go for? Oh.
So in Python we would maybe do negative one to go to the end and go back by one.
And we can't do that in C++. So the indices go all the way up to a particular number there.
Do you want to go for it? Yeah, very good.
It's whatever the size is, minus one. So I have three elements that size three.
Take one away from that. That's two. And that's the last index. Right. They was 
So I can just do this, I can do V dot size minus one like that.
And so when this is of length three, I'll go to position two,
then it becomes of length to and I'll go to position one, then becomes of length one, I go to position zero.
And so this alternate approach to do something should give us the same result that we get the ten in our output and you get the ten.
So you might look at that and say, Well, why do I even need a stock?
I could actually get the same behavior with the vector by just adding to the end of the vector and then removing from the end of the vector.
That's a stack. And this is actually I'm kind of taking the A out of this ADT.
This is no longer just an abstraction. I'm actually showing you. One way to implement a stack is to just use a vector.
But the problem with the second approach here is that a software developer who's coming along and maybe you're working on a big
project in a big company and software developer on your team comes along and they read the second approach to the function.
The problem is they have to stop and think about what's going on here.
They have to look and they say, Oh, we don't add. What does that one do?
Oh, it adds to the end of the vector. And then they're going to remove and they're going to remove v size minus one.
So that's the end of the vector, right. Like v size when you subtract one.
Yeah. That's the index of the last thing in the vector.
So they're adding to the end and then they're pulling off from the end and they just have to think and be like, Is there a bug here?
Should it be minus one? Should it be V that size without the minus one?
And it just creates extra cognitive burden for the person who's looking at your code trying to figure out what it's doing.
But if they look at the first version of the function, it's just like, Oh yeah, they're using a stack.
I know what a stack is. Push, push, push, pop, pop, pop. And it's just a lot easier for them to look at that because we talk in computer science in
abstractions a lot like one of the things I mentioned Wednesday is part of the idea of
learning these abstractions is building up your vocabulary of abstractions so you can
communicate ideas and solutions to problems efficiently with other computer scientists.
So if you were working on an algorithm that you were used to stack, you would say, Oh, I'm just using a stack.
We push these things in there and then we pop these things out, and this is how the algorithm works.
You don't have to say, Well, oh, I'm using a vector and just be sure you always add to the end of the vector and
then I'm going to remove from the end of the vector like it's too many words. So say we're using a stack, push and pop and you're good to go.
Are you following that idea? This kind of lubricates that transaction, that discussion about how a solution is working to a particular problem.
So that's the stack. Any questions about the stack Before we move on to other things, before I talk about the queue.
Oh, go for it. What's your name, by the way? Sammy.
Okay. That reverses the characters.
That's it's not reversing. The character's like there was no reverse operation.
It's just a side effect of the mechanical process. So there's no one line of code.
What's happening is we're adding elements to the stack A, B, C, and then when we pull them out C,
b, A, it's a result of both the push and pop working in concert.
There's no one line that does it. It's the whole process that does it together.
Okay. Okay, great. Other questions? Yeah.
If you print an empty stack with with the CEO just using the Stanford stack and you'll just get the curly braces with nothing in it.
Yeah. Yeah. Good question. Other questions.
Is the stack making sensory following the ideas? Can I get some nods at this?
Okay, great. So let's take a look at another data structure here that I've got for you then.
Let's take a look at the queue. So I have. Um.
Where did it go? The queue was.
I thought that I already extracted this one over here this morning. Yeah, it is over here.
Where's the queue is. Okay, so let's take a look at this other one.
So the kind of system data structure that I have for this one, the queue similar to the stack, it supports only a limited number of operations.
We can add stuff to the queue, remove stuff from the queue, and then everything else is the same.
And of in terms of peaking it stuff, checking if it's empty, checking if it's full, looking at the size, clearing the queue.
And by the way, in your notes for today,
I will link the Stanford C++ Library documentation so you can look at all of the official functions built into those.
This is my own homebrewed version here and I'll actually post this program for you in the notes today too.
There's there's some other stuff that the Stanford C++ Library does, like allowing you to print the stack to the screen or a queue to the screen.
So for adding stuff to a queue, we call that operation and queue.
And for removing we call that operation queue a queue.
You might have heard the word queue before just in your day to day lives.
So sometimes in, in some parts of the US, if, if there's just like a line at a sandwich shop, people are getting in line to get a sandwich.
Sometimes there's some parts of the US where they call that the queue and people say,
Get in queue for your sandwich or you might have tried to order some Taylor Swift concert tickets and you got into like the digital queue online,
right? And it was like you're not your number and you're not getting any Taylor Swift concert tickets from this queue.
You're just like waiting there forever.
So the idea of a queue is it's really just people getting into a line and people come out of that line in the order in which they lined up there.
So it does kind of the opposite thing of the stack, the stack. I'll talk about that in a second.
So watch this with a queue. If we want to do in queue, say the number ten, we usually refer to what we have as the front or the back of the queue.
The you can think of this as the front or the back of a line of people lined up at a sandwich shop.
The first person in line is called the front. The last person in line is the back.
If there's only one person in line, they're both the front of the line and the back of the line.
If I then add another element to this,
what you'll see with the queue is we typically draw those sideways stacks are often drawn vertically, queues are drawn sideways.
And as we add things, as we in queue things here, they just line up behind the person who was in the front of the queue there to begin with.
So thank you. that person gets in line over there.
If we in queue this person gets I guess I'm granting personhood to these integers over here and calling them people.
I'm thinking of them as people in line at a sandwich shop. They're actually integers. Maybe we could grant them personhood.
I mean, if the Supreme Court can do it, then why can't we? I don't know if you've.
Never mind. Okay, so we're just adding to the back of the queue over here as we go.
Now, you saw the order in which these people got in line.
And if there was a big hold up at the sandwich shop as someone went in, they maybe got some more bread from the back or whatever they come back.
Who in a just world should be the first person serviced here?
Now that that person is back from the sandwich from the back of the sandwich shop to ten.
And so when we remove from this from this queue and what did I call the remove operation, we have NQ and to remove we have d Q Okay.
So when we remove the ten should be the one that comes out of here and you'll see the ten comes
out of there and then the line remains the same from there And then when we do queue,
who should come up next? Everyone. Here's your come up next.
The Yeah. And so the comes out and then and are lined up there.
So it's working just like a line of people who are lining up to get any sort of service or good.
And this is used actually a whole lot in the real world as well.
So I already mentioned like the queues are used for like online ordering systems where people,
they all click a button and they're put into this data structure that processes them in the order in which the requests
were received or depending on how quickly they click that button to get in to try to buy tickets or whatever.
Or if you're trying to log in to an online game, sometimes what you'll see if you're logging into an online game is, oh,
you're number in the queue and just taking a seconds to process everyone who's trying to log in to that online game.
The accused are used for processing printer jobs.
So if you have a lab on campus where you have a bunch of computers hooked up to a single printer and a bunch of people are trying to print things,
those go into what we call the printer queue.
You just have all these jobs lining up and typically they're just processed in the order in which they were received.
Maybe a better printer queue would take into account the number of pages someone is printing.
And so if someone if a bunch of people have like two pages to print and then there's someone who's trying to print pages,
maybe they should actually like not just like line up in that order and be serviced in that order.
Maybe a smarter queue would actually take that person with the pages and move them to the back of the queue.
I don't know about your personal sense of justice and whether that rankles you or not.
Anyway, that's what's going on there. So we can check if this is empty, we can check it.
This is full. It's neither empty nor full. We can look at its size. This is the idea of a Q.
Oh, and we can also peek in the queue. So if you peek, what we see is who's in the front of the line.
So someone in the back of the sandwich shop who's maybe having a rough day, they're tired of dealing with people.
They might just like peek out at the line and they see the first person in line who's angrily waiting to order their sandwich,
or maybe they're joyfully waiting to order their sandwich because they're about to get a sandwich because it depends on the quality of the sandwich.
Anyway, So that's the peak. And we call that operation.
The synonym for that with stacks was you could call that the top operation.
We call this with queues, the front operation. It's the same as just peeking at the front element there.
So with queues we call these a FIFO data structure.
First in, first out is what FIFO stands for.
So the first thing that gets into the queue should be the first thing that comes out of it.
Just like a line in the real world, the first person to line up for their sandwich should be the first person whose order is taken.
So that's the queue with stacks. We conversely, we call those a litho data structure.
The last thing in is the first thing out. So with the stack, if you're doing muffins, am you f f i n s s is the last thing that went in.
It's the first thing that is coming out of that stack, and that's the natural reversing behavior that is inherent to the stack.
If you want to coat something up with a queue, let's have so many windows open, let's start coding something up with a queue.
So this is going to be queues. Let me go over here.
This just a new project where we're playing with queues. The syntax is really between all these abstract data types we've talked about so far.
The syntax is really the same for all of them.
First of all, to pull in the Stanford queue volume to pull in the Stanford Queue Library, I'll do queue like that.
And then to come down here, why is it unhappy with me and underlining things?
Because nothing's used there. And then when I want to create one of these, a new capital queue like that,
I give the data type that I want to put into the queue and then a variable name and then I can do here queue dot NQ, maybe like ten.
Let me do that same example. Ten And so, so far, nothing interesting is happening.
I'm just adding stuff to a queue there behind the scenes. I want to talk about a few things here.
I want to talk one about how to loop through a queue.
There are some really broken ways to loop through a queue.
There's one in particular that I want to show you that's broken and just kind of have you see this idea and,
and, and know that you should never use this particular idea for looping through a queue.
Let me put some more stuff in here like and I'll put a in here.
Over here like this. Oh, by the way, before I forget. One of the hardest things about coding with queues is typing the word queue,
because when you go to type the word queue and you hit the letter queue on your keyboard and your heads, maybe you say the letter queue.
You've now said the entire speech sound associated with that data structure and
then you need to sit there in silence and remember to hit those letters there.
It's actually quite difficult and trippy as you start coding up with queues.
And so when I'm coding queues and I want to type that word in my head,
I say where that's probably the most important programing tip I'm going to give you all quarter is use query
and you can like follow and subscribe for more coding tips with some landscape is typing quickly there.
Okay. So and actually like in, in Java, if you've used Java before, you've maybe worked with the priority queue.
The priority queue when you create one of those in Java and you want in queue and you can start from it.
Those methods in Java are called add and remove, and I like to think that the people who created Java,
they were like, We just don't want people to have to type the words queue the queue you.
It's actually kind of trippy to say queue in your head and then have to silently go through the UUA.
So they actually just do add or remove. We have in queue and queue for the same for C++ library, but watch this.
So you might think like for I equals who how do I want to do this?
The size of this is six so I'll start with one. There should be six elements in here.
So I'll go one, two, three, four, five, six. Well AI is less than or equal to the queue size I plus plus.
I'll just go ahead and see out and I'll do queue remove.
Oh no, actually. Well sorry, my bad. It's query queue dot to query like that and put these things out here.
And by the way if I added things to my queue in that order, what's the first thing that should come out.
Everyone. The ten because I inserted ten first, it's a FIFO data structure.
Well when I give this a compile and run it by the way, this tells me the size of the queue.
So initially the size is six and so I'm going to identify a loop as a one, two, three, four, five, six.
This actually doesn't work. When I give this a compile and run, I only get the first three elements out of this queue.
It doesn't give me all six. Can anyone raise their hand and explain why that might be happening?
And this, by the way, is one of the really frustrating things about programing,
is when you look at a piece of code and you're like, I know I starting at one, I know the size of the queue is six.
I'm pretty sure the integers on that range are one, two, three, four, five, six.
But C++ is making me question my grasp on integers and basic math and reality at this point.
One thing you could do if you were uncertain about this is you could set a break point at 
run the debugger and watch the values change one by one to see why this is not actually working.
What's your thought on why this isn't working? I go for it. Oh, sorry.
Can you speak up? Because I'm just. I'm really old. Yeah.
Amazing. Very, very good. So the size of the queue is changing as we do each iteration of the loop.
So check this out. Initially, the size is six, I'd say is one less than or equal to six.
Yeah. So I'll print one element and then the size becomes five, but I becomes two at the second iteration loop.
So say it's two less than or equal to five. Yeah.
So print a second element, then I becomes three, but the size becomes four and I say is three less than or equal to four?
Yeah. So print the third element. But then there are only three elements left in the queue.
Once I printed three and I is four and we ask is four less than or equal to three?
No, it's not less than or equal to three. So that's where the loop stops.
I is marching up to but the size is marching down six, five, four, and then they cross over one another and that's where the loop stops.
So I'm going one, two, three, four.
And the size is going six, five, four, three.
And that's where they've crossed over. Four is not less than or equal to three. So this actually stops.
Does anyone want to raise their hands? Do you have any ideas on how to fix this situation?
How could we make how could we actually loop through and get all the elements out? Go for it.
Yeah, we can. I wouldn't call it a constant. I would just call it a variable because it can change depending on how many things are in there.
But that's exactly right. We can start with the OG size of this data structure and say OG size is the initial size and then use OG size like this.
So here in the loop we set OG size to six, and then in the loop OG size is always six.
OG sizes not getting is not getting updated as we go here, it's just always six.
So this will go through and remove six elements from our queue.
We get all six of those elements because I just pulled this thing initially for the size
and then always compared to that original size as I looped through this thing here.
How many are following that idea? Raise your hand and wiggle it around if you're following. Okay.
So this is actually really useful if you want to remove stuff from a queue and add stuff back into the
queue and leave those extra things that are things that you added back into the queue in there in place.
So check this out. One thing we might do with our queue is we could say let's put all of the even integers back into the back of the queue here.
So I could say if let me do this, let me do it.
This is what I just called the element equals queue dot d quickly like that and then I'll say if element is even I can put it back into the queue.
Q We, we that particular element. But either way I'm going to print out the element that I just pulled out of this.
That's the element right there. Ooh. And then when I get to the end here, I'll just do C out and I'll show you what's left in the queue.
Like that, we should have some elements that are left in the queue. So as we go through, check this out.
I've set this up so it only does six iterations. So it is going to pull out ten, 
All of those will come out and then we'll stop. But I am adding stuff back in.
So the ten is going to go back in, the is going to go back in, the is going to go back in,
but those aren't going to get processed and pulled out in this loop because this loop is set up to only do six iterations.
And so as I pull things out, I am adding a few elements back here,
but they're beyond the six original ones that I've decided I'm going to pull out of the queue here.
So what's going to happen here is I have ten, and I'm only going to pull six elements out.
So watch this. That's my first one. But it's even so, it goes back in there.
That's my second one. But it's even so it goes back. That's my third.
That's my fourth, that's my fifth and that's my sixth.
But it's even so, it goes back into the queue.
And after six iterations, this will stop and I'll still have the ten, in the queue, but I will have removed everything else.
So this is what we call an idiom, a common way of looping through a queue and processing and altering the queue.
This particular idiom where you save that original size will help you get all of those elements out,
but still allows you to put new elements back in and the loop still dies and doesn't process those elements that came afterwards.
My question for you is, I'm wondering if you've seen this.
This isn't code here. I don't know if you're looking at that. You're like, I didn't know you could take that.
And C++, you can't I'm sorry to, you know, drum up false hope there.
It's actually a little bit more tricky than this to check if an element is even.
We need to use what's called the mod operator. So the mod operator tells us how many of you have seen the mod operator before?
Has anyone not seen the mod operator before? I just needs to know whether I need to discuss this in depth.
Okay. So what does the mod operator give us? It gives us the remainder after doing division.
So if I want to know if an element is even, what do I want to mod by?
You can just shout it out too. And what should I expect the remainder to be if yeah.
Zero. So ten divided by two has a remainder of zero.
It's five. Remainder zero. Ten is even divided by two gives us a remainder of one.
It's not even so. I don't know. Let's give this a try and see if it works.
Ooh, hurray. So it processed those and then we ended up with ten, back in the back of the queue.
So this is one idiom for looping through a queue. Another thing you could do with the queue instead of this is for equals, blah, blah, blah.
Over here you just say as long as it is not the case that the queue is empty like that.
Keep doing this. Now the problem with this is this will actually get us into an infinite loop because I keep pulling stuff out of the queue,
but the ten, the and the keep going back in. We never get to a point where this queue is empty.
We're just going to keep pulling those out, putting them back in. So you can't do this like real time modification of the queue in that fashion there.
But we can use this paradigm to actually just loop through and pull elements out of the queue.
So you could do a query right here.
And so this says as long as the queue is not empty, just go through and pull elements out of the Q and print them to the screen.
And it's not happy over here as long as this is as long as not.
Q Dot is empty like that.
What's it unhappy about? Oh, [INAUDIBLE]. Yeah. I mean, I would sometimes leave errors in there deliberately just to see if you're paying attention.
That was not one of those times.
But okay, so this is going through and actually doing that thing over there so we can do it while this thing is not empty.
So that's a thing that we can do as well.
Um, another application for stacks that I think is well, actually let me shift gears and so, so these are cuz I mentioned what they're good for.
They're a FIFO data structure. We've talked about stacks, their life data structure.
You've now seen the syntax for employing these in a program.
This is really almost all there is to the syntax is these few things right here.
If you wanted to put other things in here, you can create like a queue, any data type, you can create a queue of strings.
You could get wild and create a queue of queues that hold integers.
Let's not do that. That's maybe a little bit too bendy for today. I want to shift gears a little bit and talk about the grid that we talked about on
Wednesday and just kind of show you one other little thing related to the grids.
So I call this gritty over here.
One other thing related to the grids that I want you to know, and this is going to come up in a programing assignment for you pretty soon.
So I'll include greater age. I'll create my grade over here. So this is Grid.
I'm going to put integers in it. Grid g, And then you remember here what comes first, The number of rows or the number of columns?
The number of rows. Remember, the phrase I used was row. Major rows are the main event, the first thing to happen.
So we create a two by three grid over here.
So it has two rows and three columns.
There are few ways to loop through this that I want to show you. Oh, by the way, let me say this.
When you create a grid by default, everything is initialized to zero or the zero equivalent.
So if you put floating point values in here, you get a bunch of zero point zeros.
If you put strings in here, you get a bunch of empty strings with nothing in them.
If you put integers, I just have a bunch of zeros. And there I want to do three ways to loop through a grid.
One is you can just do the for each loop, the fancy enhanced loop,
the range based loop so you can say for int I in my grid, let's just go ahead and print out all of the values in my grid.
And by the way, how many values should I have in this grid overall? Everyone six.
And you know that I can do something like this to set a value.
Actually, maybe let me set them all really quickly here just to actual.
So this is going to be and then I'll do here, I'll do 
Let me do 
And so you'll see like this is just one way to loop through a grid and it just prints out all the values.
And notice here it prints all the values in row zero, because again, these, this data structure is created in a row major way.
All the elements in a single row are clustered together in memory with the way that this is implemented here.
So all the elements of row zero print it out and then all the elements in row number one, print it out.
So that's one way to get through. We saw this other way to get through on Wednesday where you could actually do you could set some integer I to zero.
And then while that is zero, you could loop through zero one and two and print out every value for every column in row zero,
and then let I become one and loop through. And for every column while you're looking at row one, do that over there.
So you could use something like this for intro equals zero row is less than the number of rows, row plus plus.
And then inside that. So initially is going to be zero.
But for row zero, I want to go through each column.
So you're going to two so you could do something like this for InterCall equals zero column is less than g dot num calls call plus plus.
And then I can just print whatever's that that thing. So see out.
G What is the word that I use when I open brackets and I'm saying this out loud, It's G sub very good.
G sub ro sub call and I'll print out everything there and oh, like this.
Let me put just a new line here out and l so you can see that this is all like separated out over here and this has the same result.
I start in row zero and then here I'm looping through all those columns,
and then I loop back around and row moves on to one, and for row one I go with my columns.
So I'm getting these out here in the same order. So those are two ways to do it.
How many are feeling comfortable with that nested for loop? I just need to kind of know kind of where the classes are.
Okay. I never know if that's just moving too quickly or if you're like, Yeah, we saw this in our intercourse or what's going on there.
So I just wanted to pull and see where you were with that. There's a third way that I want you to be familiar with, which is a grid.
Another function that's built into here gives you a bunch of grid locations.
And so check this out. There's this thing called a grid location.
So for grid location, I'll call that look in my grid dot, this has all the locations.
There's a function that returns all the locations. Let me print these out for you and show you what these locations look like.
And what you'll see here for these grid locations is they're these grid locations.
It's it's a it's a special data type grid location that tracks different rows and columns.
And so the zero zero notation, they're saying row zero, column zero zero, column one zero column two, and then we move on to row one.
So we get these grid location objects and you can actually use these grid location objects as an index on your grid.
The grid location object actually has both the row and the column built together into one into one particular piece of data.
There are one particular variable, and so you can actually do something like this.
Let me do I'll draw a little arrow here and you can use that location as a single index to the grid.
And the reason I don't need again, the reason I don't need to indices down here is because this location object has a row and a column built into it.
And so I wanted you I want you to see this that when I group through it,
actually you can feed that here and use that to get all of those different values that those rows and columns.
And you can create a new grid location yourself.
You can do something like this grid location log and you can put like zero one and then do see out G at that.
Luke and L And this should give me the thing at row zero column one, which is the over here.
Let me do and I'll like this to do another line and you'll see indeed that prints out the 
So there's this, this grid location thing that I wanted you to be exposed to and have seen before you head into your next assignment, which,
by the way, the that the cadence this quarter is going to be assignments will be due on Mondays and will unlock a new assignment on Monday.
So it's really important not to fall behind. It's really important to go to layer right away as soon as those assignments open.
If you have any questions about those in your notes today, I'm going to post some notes about another interesting application of stacks
in case you're wanting to see kind of a more advanced application for stacks. I'll have that in your notes.
Have a great weekend. I'll see you all on Monday. Thanks for being here.
Saying hello. Hello? Testing.
Hey. All righty.
Hello. Welcome back and happy Monday, everyone.
There is those pretty decent in terms of quieting down right away. And so as the meme implies or you know, as someone told me in the front row,
passive aggressively states here, I do want to remind everyone to please use whispery voices throat lecture.
If I can hear you from where I'm sitting,
it's problematic in terms of disrupting me and probably people around you if I can hear you from where I'm standing.
Some quick announcements and then we have teams to jump into.
And before I forget, let me mention things are really going to heat up this week in terms of the topics that we're covering on Wednesday and Friday.
They're still in the middle area here, just a little bit too much chatter in terms of Wednesday and Friday.
The topics that we're getting into are going to be just a dramatic shift away from eighty's and we're going to pound
through like a bunch of material this Wednesday and then start talking about really tricky topic this Friday.
So if you're someone who's found these first couple of weeks kind of to review for you a little bit more straightforward,
you look at the lecture schedule and be aware that there is a big shift coming up on assignment.
One, of course, is due tonight. Assignment two will open up later tonight at some point.
I don't know exactly what time. I don't super love opening assignments before an assignment is due,
like opening eight two before assignment one is due because it's someone still working on assignment one till the deadline tonight.
I don't want them to feel super demoralized that they're like, Oh,
this other assignment is already on my plate, but we'll open that up sometime later tonight.
But not, not super, super early in the afternoon to be judicious with the late days.
Remember, you can use that most to the eight days per assignment. And those are supposed to be for emergencies.
So things like you got sick, you got hit by a bus.
Maybe if you get hit by a bus, there's probably some documentation we could give you some extra days behind with you.
But do hold on to those and don't just waste those for frivolous reasons and then get to a point later this quarter where you're like,
Oh, I'm deathly ill and I need more days.
And I used all my days because I was just like, you know, sleeping in because it was raining on Monday.
You do have a quiz series do this Wednesday at a.m. Don't forget, those are happening at weird times.
The quiz that opens today at two is actually do a.m. this Wednesday.
So you have a very short amount of time to do that one.
There's this like kind of weird moving window for how much time you have to do all of your quizzes this quarter.
And then the final announcement I have is your section leaders will be reaching out this
week or maybe they'll talk to you in section about setting up individual grading sessions.
Those are going to be due for them by this Sunday at p.m.
So they might look to set those up throughout the week with you.
They might book to meet with you on the weekends to go over your first assignment submission and do an individual
grading session where you get kind of a touch point there and some immediate feedback before assignment two is due.
Assignment two will be due next Monday. So in this cadence where assignment comes due, then one opens up and then they're all do an opening on Monday.
This is kind of where we are. I have two new abstract data types to share with you.
Of course, last Wednesday we started out with the vector and the grid, and then what were the two data structures that we saw on on Friday last week?
Can you just shout it out if you remember. Yeah, the Stacks and Qs.
Very good. And what were the operations for inserting and removing with a stack.
Everyone push and pop. Very good. And what were the operations for getting things into and out of a queue.
Everyone in queue and very very good. And then I shared that really important programing productivity tip with you about when you type the word queue.
If you say quickly in your head, that can help get all the letters out as you go.
The new data structures that I want to introduce to you today are the set and the map,
and I'll do the thing that I always do where I give you the syntax for these,
talk about how they work, and then we'll get into some problem solving with these. Talk a little bit about what these are good for.
Let's start with the set. A set is and in order to use the stands for set, I need to include setter H.
Remember, it's a lowercase set up there. But with these teams as we've been creating them in code, we always capitalize the first letter.
And so the syntax for creating one of these is capital set, and then you give the data type of what you want to put in that set.
And I've mentioned before, this is called the type parameter, the kind of data that it holds.
I mentioned that these are homogenous years that we have in the Stanford libraries.
For you. They hold one type of data for each one of these that you create that could be whatever you want string,
float, double char, int, whatever you want there, and then you give the variable name like this.
And this creates a set.
A set is a lot like the set that you've seen in the math world where you use curly brace notation and you have elements separated by commerce.
And one of the things that you might remember from your math classes is that a set doesn't allow duplicates.
So in the math world, we would say this isn't this doesn't really qualify as a set here in the math world.
A set wouldn't allow you to have multiple ones. So we don't have duplicates in our sets.
So knowing that we don't have duplicates in our sets,
one of the things that we're actually seeing a little bit here is sets can be pretty useful for removing duplicates.
If you have a vector that has a bunch of stuff in it, you're like, Oh,
I just have a bunch of records that I'm processing and some of these are repeated.
I need to get rid of the repeats. You can just throw them all into a set and the set naturally gets rid of any repeats that you have in there.
Another thing I want you to know about the set, in addition to the fact that it doesn't allow duplicates,
is that there's no inherent notion of what was the first element in the set.
What was the second element to enter the set? What was the third element to add to the set?
And that's diverging from our idea of what a vector is,
where the idea of a grid or even stacks and Qs that maintain some semblance of this is the first element,
This is the last element that doesn't happen with a set when we throw them in there.
It's just a jumbled order of of stuff when we throw stuff into a set.
So you can also think of a set as just kind of a binary membership device.
Something is either in the set. Or it's not in your set.
But there's no notion of ordering or indexing associated with these.
So check this out. If I wants to create a set that holds strings, I would do something like this.
I would say set string and then just give it a variable name. I'll just call this my set equals and then you can use the curly brace notation here.
If I want to put a bunch of strings into this set with strings, you know, in C++,
we double coat our strings and then I'll set all my separate all of my strings in the set with commas.
So maybe I'll throw a unicorn in there and then I'll throw a cupcake in there and then a swamp in there,
and then another cupcake and then two more unicorns.
If I put those in there. And as I mentioned, the set gets rid of duplicates for us.
So as I'm throwing in Unicorn at the beginning, and then I get to these extra two unicorns at the end,
what the set will say is like, Oh yeah, the unicorn is already in here.
It has no record or notion of the fact that I've placed three copies of the unicorn string in this set.
All this that keeps track of is Unicorn is here.
So let's take a look. If you print this out, you can actually, as with most of the Stanford C++ TS, you can just print them directly out.
And we have all of this set up so that they have nice output for you and you print those to the screen.
And you remember last week I showed you the C++,
the default vector that you can't print or I think I showed you the it was a stack or a Q that I showed you last Friday,
and I showed you that you can't just print that to the screen in the default C++ one,
but the Stanford stack and you have that nice behavior built in that you can print those, dump those to the screen.
And so what you'll see when I dumped these to the screen is it only has those three strings in there.
It has cupcake, it has swamp and it has unicorn. And again, this is all of the data on the screen right now.
That is all the data that is stored in the set.
There is nothing in here to indicate that unicorn was added to this set three times or that cupcake was added to this twice.
And also notice that the order has gotten jumbled up.
Unicorn was the first thing that I put in here, but this did not keep track of the fact that unicorn was the first element to go in.
It lost that information. It doesn't care about that information.
What are you actually observing about the order in which these elements appear in the set?
You can just shout it out if you see it.
Yeah, they're coming out in sorted in alphabetical order and that's actually a feature of this set is it will keep your elements in alphabetical well,
kind of alphabetical order. So actually watch this. Watch.
If I just kind of throw a wrench into this and maybe add zoologist into the set and I give this another compile and run.
Well, zoologist actually is coming before everything else in this set and I'm wondering if anyone sees what was maybe special about this,
what it would cause zoologist to appear perhaps before all those other elements in the set.
Someone want to raise their hands and even see it. Yeah. Go for it. Yeah, that's you.
You nailed it. That's super, super awesome. Okay, so we talked about ASCII, the numeric representation behind.
So we got a fist bump back there. I'm assuming that you whispered the correct answer to your friend.
Amazing. Get a gold star for both of you and everyone else who was sitting there quietly thinking the correct answer.
Everybody gets a gold star in a cupcake. No, sorry, You got a gold star.
There's no cupcakes because this costs money. The when we when we with the ASCII values that represent these characters,
it turns out that the capital letters have lower values than uppercase letters.
So the the the capital Z, there is something in like it's like or something is the value.
And the lowercase c has a value of 
And so the Z, it's numerically less than comes before the lowercase C's ASCII value there.
So we sometimes, instead of alphabetical, this is so nerdy, I'm sorry to do this to you.
And so in alphabetical order, we call this ASCII medical order that they're sorted by ASCII values underlying these things.
And so the set does that for us. It keeps that in that particular order. One of the functions that's built into this, built into the set is I mean,
we can hit this button here and see all the things that it has so we can add stuff to it,
we can clear it and maybe some other interesting things in there.
But one of the main ones that we'll maybe take a look at or that will capitalize on the quarter is this size,
this size function or method we sometimes call it, that's built into this thing.
So here you see that I have four elements in the set and when I print out the size, it says that we have four.
Now, if I want to remove something, or maybe I could add something more.
So let me actually, if I take this down here, let me just show you that I can use this syntax.
Also, I can add the string zoologist to my set using this add function like that and you'll see.
So that had the same impact there you can use the ADD and you can also do set remove to remove stuff.
And if I want to remove say unicorn, I really really I've said this like five times already,
so I really, really, really want you to know this unicorn is only represented in here once.
There's no notion of it being in there three times. So even though I added three unicorns to begin with,
and even if I sat here and did this actually if I said add unicorn over and over and over again, unicorn like that.
Da da da da da. There's only one unicorn in the set.
So when I call, remove on the set and then go ahead and print it out, you'll see that that one unicorn that was maintained in that set is gone.
Doesn't matter how many times you add it, it's only in there once, and when you remove it, it's gone.
You can also use there's this contains method, so you can say if a set dot contains and just check if it contains a particular thing.
So this is one of the things that sets are really good for is checking membership, checking.
Have we seen this value? Does this value exist? Is it a member of this data structure?
And so this this contains method returns true.
If that thing is in the set, it returns false otherwise.
And so we could do code unicorns, hooray and owl and otherwise if there are no unicorns see out.
No, no. All the unicorns are gone.
Feels a little bit like the post world is just filled with sadness and the magic is gone.
Oh, all the unicorns. Okay, sorry. Let me have them back in here. Okay.
Her a unicorn, sir. So that's what's going on there. If you of course, if you're working on a programing assignment,
one of the things that you want to get really comfortable doing is going over here to the library documentation.
Clicking on for this particular ADT, the set.
And you can see all of the functions that we've built in for you.
And one of the things that you'll use in the assignment that we're unlocking for you tonight, too, is that assignment.
We'll talk about these operators that are built into sets.
You'll see that there's some you can use, like the multiplication symbol to perform intersection on two sets.
Or you can use the minus to remove a value from a set.
Or look at the difference between two sets. Subtract all the elements of set two from set one.
So I'm not going to go through examples of all of these things in class. That's something you'll be exploring in your programing assignments,
but there's a lot of powerful functionality built into these sets behind the scenes.
And so that's what I mentioned, the sort of ness of all those things there.
Oh, in addition to just printing stuff out like that, this is a container. So you can do something like this, you can do for each string.
S in my set. You could just do C out and maybe do like a little fancy list with arrows in front of each of these elements.
And so you can use this this fancy for loop to iterate through the set as well,
instead of just like dumping all the contents to the screen like I was over here.
Let me comment that one out. You can just iterate through and maybe do some nice formatting with all of your
elements and put those in some sort of list as you put them to the screen.
So that kind of fancy for loop works there as well. Go for it. What's the keyboard shortcut?
Yeah. What I do is I highlight multiple lines and then I hit control slash and that comments out or uncomment all of those lines.
And on a mac, I think it's our commander option. It's I never remember which one is which on don't on that keyboard.
I actually I had a mac years ago and I it always messed me up that like the the option and command were reversed
from the control and alt and like how they map to normal keyboard so I actually pulled the keys off my keyboard,
swapped them and found a program that would actually remap those for me because I really never remembered which one is which.
It was like fumbling through foreign language. I was like, I kind of know what I'm doing, but I keep stumbling every time I try to speak in it.
But yeah, it's highlight and then control slash like that. Oh, and if you want to move, sometimes I do this where I like to.
Oh, I've lost the key. Sometimes I do.
Now she. Never mind. I've totally. I was doing a thing earlier where I got all of these lines to, to move up one by one.
And I've forgotten what the key was. I figured it out last week. Anyway, so we have this iterator that goes through the set like this.
Well, one of the things that you can do then is suppose you have, um.
Suppose you have a vector. Actually, let me put all of these into a vector called V, and I want to know what are all of the duplicates in this thing?
Well, I could use a set to keep track of all of the elements that I've seen in this vector as I
if I want to loop through it and maybe print out what are all the duplicates in this thing,
I could create a set that just keeps track of all the things that I've seen.
So let's let's solve this problem, which is actually a really common problem in computer science.
You have a collection of goodies and you're like, I want to know which of these are duplicated in this collection.
So I can I can maybe solve some problem like you're looking into you're looking into solving some problem where you're looking
for a cure for a disease or you're looking for a genetic marker that is indicative of some sort of inherited condition.
And so you keep going through and you're looking at all of this genomic data and you're like, what is this?
What are these signifiers that I keep seeing emerging over and over again in this population that does have this condition,
but they don't occur in these other conditions. So you're looking for those duplicates. It's a really common problem.
So I can use a set to drive that idea.
I can maybe create a set where I keep all of the things that I've seen and then I'll say for each string in my vector,
I want to loop through and check if I've seen this thing before.
So I'll check if I've put it into my set, I'll see if this scene set contains this string.
Then I'll say, Ooh, it's a duplicate code to duplicate and I'll print out what that thing is, that particular strain.
And then down here I'll do scene dot add, whatever that string was, I'll add that to my running set.
So let's trace through. Let's read through what's happening here.
So when I get to the can, I have all of this on the screen at once.
Since doing it, I feel like it's just going to be a little bit too high I want to do here.
So as I'm looping through this thing, I get to the first element.
I got to the first element unicorn.
And I say, Is that a member of the scene container? No, it's not in the scene container, so it's not a duplicate.
But then I add it to the scene container. So so far it contains the unicorn.
Then I get over here to cupcake and I'm like, Is that scene is in the set so far?
No, it's not in the set. So I just come and add the cupcake to the set.
Then I get the swamp. Is that in my set? Is it my set? Everyone know.
And so I just come down here and add swamp to the set. Then I get to cupcake.
Is Cupcake in my set at this point? Yes, I've seen it before.
So who Cupcake was a duplicate. And then I see the unicorn is a unicorn in my set.
Everyone. Yes, it got added that set. So I'll put that out and say that's in the.
Oh no, that's in the that's in the set over there.
And then the second unicorn also when I get to that one I'll say is that in the set.
Yes. So go ahead and print that out. And so what we see here are the cupcakes, the unicorn and the unicorn at the end of that vector.
Those are duplicate items of elements that came earlier. So I'm using this this idea of the set being a binary membership table or a binary
membership construct to keep track of things that I've seen before or not.
My question for you is how can I remove the duplicates from this list of duplicates?
So suppose I want to print out what are all the elements that occur in this vector multiple times?
So I want to print out that cupcake, it appears multiple times and then want to print out that unicorn appears multiple times.
But I don't want to print the unicorn twice just because it's appearing in there prolifically.
I want to just print out at once. Yeah. Unicorn is a thing that's occurring multiple times in this vector.
Does anyone have any ideas how I could? And you can raise your hand for this.
How can I modify this code so that it keeps track of the things that I've the things that I've seen multiple times in the specter,
but it only prints each of those duplicates once. Any thoughts on how to hold it, how to drive that in the black sweater here?
So like in the white jacket, there is someone right behind you. Do it for that set And then.
And where and where should I put that? Where. Where do you want me to do that?
Like, on what line do you want me to print it out on line there. When we.
When we at or out of place.
I would. Uh huh.
I. I see.
Like right here. So so basically the center said right here and I could I could do it in a fancy way.
Right. Loop through it. Right. Um, we're really, really, really close to the solution here.
What I'm expecting to happen here, though, because it's in the loop, we're going to loop around and keep printing that set out.
And so as the set grows, we're going to keep printing it over and over and over again.
We're really, really, really close. Does anyone want to do slight modification? Yeah.
Yeah. You're waiting. Aren't you able to account Variable.
I'm not I'm not sure that the counter is actually going to be really helpful for us right now,
because I need a way to store that for every single variable, every single value that I'm seeing in this vector in the white jacket here.
So create a new set for duplicates. And every time I see a duplicate, add it to my set.
So where do you want me to do that? Like, I'll create up here. Set.
This is our new set up here. And where do you want me to add things to it or what you want me to do?
We'd speak up. Inside the if statement.
Do what here? Say, What are you going to do?
What you're. Seen ads like this one already seen adding SE down here.
Does anyone. We were really close to a really great solution. This is going to go and there are many ways to do this.
But yeah, what's your thought here? Okay, put it in the.
It Exclamation mark. No.
Does anyone have a really tiny modification that you want to make to the secure part back there?
Yeah. Just move the print statement outside this loop over here like this.
Like that. And so the and then make sure that we're actually printing this set of things that I've seen.
So all I do in this case, in this particular example is just go through and add all of those elements.
Do set. Unicorn, cupcake, swamp, cupcake, unicorn, unicorn.
And the set absorbs all of those duplicates and is just like, I don't keep track of duplicates, so hope you didn't need those.
And then it moves on with its life.
And so this set, by the time we're finished with this, this set only has the unicorn, the cupcake and the swamp in it.
And when I go to print those elements, all the duplicates have been removed. And so what we don't want to do is reinvent the wheel.
When we have one of these abstract data structures that already has a particular behavior,
when we always want to do is try to capitalize that onto the to the degree, capitalize on that to the degree possible.
So the set is good at duping. So just throw stuff into the set, let it do by do by mean duplicate, remove duplicates, let it do for you like that.
There are certainly other ways to do this. So one thing you could do is you could you could have done this.
You could have said something like if scene dot contains. So that means we've seen this thing before.
It contains this thing over here. You could add that to the new set, and I think that might be what you were doing over here.
What you're what you were trying to tell me to do is come into this loop over here. We could add to that new set over there and say that we watch it.
Yeah, we could. We could do something like this. If it's in there, let's do.
Then we could say, if not and let me change this new set to the ones that are duplicates that have already been printed.
So we could say already print it like this, so we could say if we've seen this thing before, let's check.
If it's not already printed contains us, then let's go ahead and print it, see out that particular thing like that,
and add that to our already printed set like this, and then just go ahead and get rid of this stuff down here.
So what this is saying is every time I loop through, I'm coming to line 
I'm saying just add this thing to my set.
And when I come into this loop, I check and I say, Have I already seen this is a part of the set of things I've already seen.
So unicorn initially, no, it's not part of that set, but add it to the set then.
Cupcake No, it's not part of that set, but add it to the set and then Swamp.
No, it's not part of that set. So add it to the set. And what we end up with so far then is seen contains the unicorn, the cupcake in the swamp.
And then when I see this next cupcake over here, I say, Well, is that cupcake part of my scene?
Yes, it is actually in scene already. Is it in already printed?
No, already print. It doesn't contain anything. So go ahead and print out the cupcake and then add it to already printed.
So already printed contains the cupcake now and then. Unicorn, when I loop around.
Is it in scene? Yeah, I've seen it before. Has it already been printed?
No, it's not in that set of stuff I've already printed.
So go ahead and print out the unicorn and then add it to the set here, stuff that's already been printed.
And then when I see this final unicorn, is it in the scene set?
Yeah, I've seen it before. Is it in the already printed set?
Yes, it's in the already printed set. So it's not the case that it's not in the already printed set so we don't print it out again.
We only printed out that once I figured this to compile and run.
Yeah. We get the cupcake and the unicorn and it does the. So there are multiple ways to approach this.
You can use the two sets, you could use the one set. And always we're looking at these abstract data types and saying, what are they good for?
What's their inherent behavior like?
Stacks What did I say stacks like it's actually really good at what particular thing you just showed it out if you remember.
Yeah. Reversing things, right?
Because if you go ABC and you remove stuff from the stack, you get CBA sets are really good for removing duplicates for duping things.
So that's that particular example there. That's kind of all that I want to say.
Oh, the other thing I want to say is sets are super speedy. So here's what you don't want to do.
If you if you have a problem like this where you just want to know, have I seen this thing before?
This contains operation is super, super fast on the set.
What you don't want to do is maybe you have like a million records and you're like, Have I seen this person's record before?
Like, maybe you're the h.R. For some big tech company, and you're like, has this person applied to this company within the past six months?
Because if so, we're not going to process their application. This is common to companies.
We're not going to process their application. We're going to put them on kind of a holding period for six months.
Well, we don't want to do is maintain a vector with millions of people who've applied to your company.
And what have I seen this person before? I don't know.
Let me loop through this vector really, really slowly and look at every record, one by one, to see if that person has applied before.
That's a slow, sad operation. What you do is just throw stuff into a set and look up for the set is really
speedy and fast and we'll see how that's done in the second half of this quarter.
The other data structure I want to introduce you to then, by the way, like just let me plug really quickly one of the things you should be doing.
Of course,
every time I introduce something like this in class is then you'll see this in the assignment and so work through that stuff in the assignment.
But if the assignments are kind of tricky for you as you're starting out, you know, like this is just a little bit too much.
I feel a bit shaky with Seth's glance at the notes that I post and then close them down and try to replicate the set code.
I'll try to replicate something like this from scratch yourself there.
Many, many different ways to implement this and see if you could get a working version like this going and then maybe dig into the assignment.
If the assignment was a little bit too tricky to just dive into it right after seeing this lecture.
So some thoughts there.
Oh, the other thing you should be doing is writing a lot of code on paper as you're practicing with this material because your exams are on paper.
And what you don't want to do is you get into your midterm exam and all you've been doing all quarter
long is coding with an idea that autocomplete the stuff for you tells you where your errors are.
Formats, Everything nicely gives you the little menu of functions.
When you hit the dot operator, you want to be coding on paper at least once a week so that you get into that mode of like,
what's it going to feel like to be on the exam? So you can be at your best performance when you get into that exam.
The next data structure. Do you remember I said I was going introduce sets and maps.
Okay. So the idea behind a map is it's an associative data structure.
It associates what we call keys with a key, with a value.
So it's keys and values. And we use these all the time in the real world.
So things like like I think all of you probably have a Social Security number or most of you probably have a Social Security number.
That Social Security number is a unique identifier, a key that is mapped to information that the US government maintains about you like your name.
And really I think what they care about is getting your taxes home.
And the state of California has that database as well, right?
Or like Amazon has a map that takes a key, a unique identifier for you, your log in your account username,
and it maps it to a whole history of all the products that you've purchased.
They're really interesting in combing through that and seeing what are trends in terms of things that people buy so that they can recommend to you,
things that other people buy that have similar purchase histories to you and then they can use you for more money,
is one of the ideas there or like books in the real world, what's the unique identifier that every book has that's for sale on Amazon?
Yeah, the ISBN number. So you can imagine that Amazon has a map that maps ISBN numbers to information about the book.
And what Amazon would not do, by the way, is create a they wouldn't just have like one map in memory that maps an ISBN to
a book title and then another map in memory that maps an ISBN to the author,
and then another map in memory that maps the ISBN to how much that book costs on their website.
Probably they just have a single map and the ISBN is the input to that map.
It's the it's the key that you use to unlock some information and it maps to another data structure that has all that information about that book,
its title, the author, how much that book costs when it was published, and so who the publisher was, and so on and so forth.
So you can think of a map as something like this. It's this data structure where you feed it a key.
Let me draw a little data structure here. It's like a little box. Okay.
So it's like a little data structure that you feed a key into and it produces a value out of that.
The syntax for creating these is a little bit different from what we've done so far with our ADT.
So check this out. We have two data types.
There's the key data type and then the value data type.
So you can imagine a map that maps ISBN to book titles.
The key would probably be a number, an integer, and then the value that you get out of that associated with that integer is a string, a book title.
Except maybe not actually, because ESB NS used to have, I think, ten digits in them and an integer in C++ can have at most ten digits.
Do you remember reading about the long versus the integer? The integer can only have ten digits.
How do you see on these days? Have digits.
So maybe what we would use instead is a long to represent ISBN or maybe we would actually even just put it in a string that has characters,
one for each of those digits and map a string to a string. Let's see an actual example of this.
So let me get rid of just all of this code over here. Oh, it's our unicorn code.
We worked really hard on that and now it's gone. Oh, well, it's kind of a metaphor for life.
Let's do. Oh, interesting.
You all have a dark sense of humor. The interesting.
Once again, I've been.
So every new quarter, I play a little bit and see, like, what?
People giggle. And I think I've mentioned this to you before, like I actually have a spreadsheet going of like,
things that you giggle at and whatnot, but I unfortunately left it at home.
So that's why the lectures are sad and it's not funny.
Okay, so keep in mind you have a very dark sense of humor and you giggle about the uncomfortableness of existential dread.
And and anyway, let's create a map. So let's do this. A map.
I just want to create a map that maps first names, two last names to begin with.
So string to string. And I'll call this my name map.
Actually, no, I won't, because that's just a lot to type. Let me just call it my map. Oh, let me tell you this before I forget.
When naming a map variable, a very common convention in the real world is to do this,
is to say what the first what the key is and what the value is that's being mapped you.
So I might call this first name too. Last name map.
If if the keys are first names and the values they unlock or a corresponding last name, I might call it the first name to last name map.
What is being mapped to what over here. So let me just put some stuff into into the map.
The syntax for putting stuff into a map is you kind of treat it like it's kind of like we used for vector access.
You do map with square brackets and then your key. So let's put the course stuff into this map.
So I'm associating here. Remember, I set up above the map is an associated data structure.
I'm saying there's now a key in there. Clinton And the last name that's associated with is Kwarteng.
So if I fed the key Clinton into this thing and said, like, what's that associated with, Check this out.
I'm like, ooh, what's this first name here associated with?
You'll see that it prints out Kwarteng Clinton's last name. Amazing.
And you can put multiple things in the map like that. So let me put my name in there.
So, Sean, some landscape like that.
And when I give this a compile and run, if I print out what Sean is associated with.
You see that Sean is mapped to some? LINSKY So that first name, I'm feeding it into the map and I'm saying, what's associated with this?
And it spits out to me the result. The thing that I associated that thing with, one of the kind of interesting behaviors of maps is the keys.
And by the way, again, I'm just going to try to reinforce this terminology as I go.
The keys here are Clinton and Sean, the values they associate with our car and some landscape.
The keys in a map form are set. And what is one of the fundamental properties of a set that we just discussed besides the fact that
there's no inherent order to the set in terms of maintaining the order in which things were inserted.
The other big property of sets is that there are no duplicates.
Very good. So check out what happens here.
If I start to add, say, the computer science lecturers at Stanford to this map, we actually have a bunch of repeat for first names on the team.
So we have Chris Greg on the teaching team. We also have Chris Peach on the teaching team.
And if I give this a compile and run and let me actually just print the whole map to the screen like this.
And so we've seen this before that you can just dump one of these data structures to the screen.
And the Stanford C++ Library has a nice formatting thing that does that.
So what you see here is this syntax is saying Chris is a key associated with the value peach.
Clinton is a key associated with the value. Kwarteng and Sean is a key associated with the values of Lansky.
But Chris, Greg is nowhere to be seen in this map.
And that's again, because the value of the keys in a map form a asset.
So at first when I said map Chris to Greg, the map was like, sure, Chris is now associated with Greg.
But on the very next line I said, Map Chris to Peach.
And so it went to the map and it's like, Oh, Chris was mapped to Greg, but I guess you don't want that anymore.
You now want Chris to be mapped to Peach. There's only one Chris key in this map.
And when you try to set, when you try to map Chris to peach, it overwrites the idea of Chris previously being mapped to Greg.
So these don't allow duplicate keys. You could have duplicate values.
So let me go through this actually. So you know, Nick, that we have several well, a couple of Nick's on the teaching team.
So if Nick Berlanti and Nick colleague and if we and we have a couple of Julie's also,
so we have Julie Zelinski and we also have Julie, whose last name is Stanford.
Julie Stanford is part of our teaching team as well. So when I give this a compile and run, you know, Chris is going to be associated with Peach.
What last name is Nikki going to be associated with? Shout it out directly because we go line by line here.
So first, it was associated with Pawlenty that Nick became associated with your colleague.
And who is Julie going to be associated with in this map, everyone? Yes, Stanford.
And so when we get that to compile and run, you see that's exactly what we expected.
Chris Peach, Julie Stanford, Nick Jacoby. And of course, Quentin and I are in there with no collisions and whatnot.
Now there are a couple of different ways to look through this,
so you could actually do a fancy for loop the range based loop or for each loop you could say for each string s in my map dot keys like this,
you could print out just the keys. Let me just show you all the keys associated with this.
So, Chris, Clinton, Julie, Nick, Sean, those are all the keys and those keys map to values.
You can also loop through this set of values and see what all the values are in that map.
And as I loop through, you see those values that were retained were peach, Kwarteng, Stanford, chocolate and Zelinski over there.
So we have these these functions built into the map.
And again, you can go over here to the Stanford C++ libraries and look at all of the functions that are built in.
And you can check if the map contains a particular key.
You can get the value associated with a particular key. You can get the size.
That's the number of entries in the map. So over here, the size of the map was I had one, two, three, four, five unique keys.
And so if I do see out this is map dot size, it should say that there are five unique entries in there.
There are five keys each associated with a single value is what's going on there.
So that's one of the things that's happening there. Now, if you just try to say for every string in the map, what you'll see is by default,
what is it if you don't do dot values or dark keys, what's it doing by default over there?
The values, the kids, the keys, the things that unlock the values associated with them.
So if you just do, don't map. And that's usually what we want is you have an ISBN, you want to look up the book that's associated with that thing.
So that's one way to iterate through that map over there. There are some interesting gotchas that I want you to see associated with maps.
One is if you try to look at something that's not in there by default,
C++ gives you the zero equivalent of whatever the key, whatever the value type is.
So this zero equivalent of an integer is just the number of zero.
The zero equivalent of a string is just an empty string with no characters in it.
So if I say something like this, if I say C out and I'm going to say, What is Sophie mapped to over here?
And I'll just do map Sophie like this.
Actually, let me put some little arrows here so we can see that there are no characters in in the thing that this returns.
What you'll see is between this arrow, when we run the program and this arrow, there will be absolutely nothing printed in between those.
This will just return to us an empty string. And so that string, Sophia's just not associated with anything in that map.
This is different from, I believe, Java. In Java.
If you try to get something that's not in the map and print that to the screen,
it actually just I think Java will will crash if you try to actually print that value or maybe not,
maybe it'll just print the equivalent of a null reference.
But if you try to do something with that value to kind of freak out on you, there's also a get function built in so you can do something like this.
We can do Hanon and I'll do map Dot get in parentheses.
Hannan And this has almost the same behavior so it prints Oh no map dot get has almost the same behavior here.
It prints out the empty string. Those things are now associated with the empty strings.
This is really terrible about the map. And I'm so sorry that the Stanford map does this to you.
I didn't create that create the map or this behavior. If I go to print out the map now, check out what happens.
Sophie got added to the map. If I give this a compile and run, you'll see that Sophie is in there associated with the empty string.
You will see, however, Annan is not in there associated with the empty string.
And so this is just the thing that the Stanford map does to you. And here's what's going on.
When you use this brackets notation to look something up in your map, if it's not already there, the Stanford map just adds that entry for you.
And so it's just associating this with the empty string. This will ruin your life for about minutes as you're working on debugging your program.
If you use the bracketed notation to access something that's not in the map,
it gets added for you associated with the empty equivalent of whatever kinds of values we're adding this thing.
If you use DOT get, however, it just pulls that thing out.
It doesn't actually add an entry to the map for you. So one way around this is to just use DOT get if you're not sure if something is there.
Another way is to use contains to see if something is in there.
So you can do if map dot contains key. Sophie,
then go ahead and print out the result of the value associated with Sophie and we
give this a compile and run now because Sophie is actually not contained in the map.
We never ping it with those brackets and so it never actually gets added to the map.
So if you're going to use the brackets and you don't want to risk stuff being added to your map,
that's not actually associated with anything, then use a contains check or just use get instead to get around that.
So that's kind of just an interesting wild behavior that's embedded in the Stanford map.
And I would apologize for that, but I'm not responsible for creating that.
Now, one of the things that I've got going on here is I have multiple people with the same first name.
And so what if I wanted to actually associate Julie with both Zelinski and Stanford and have both of my colleagues represented in this map?
What if I wanted both the Chris's and both the Knicks to be represented in this map?
Well, then, instead of mapping a string to a string, since each of those keys can only map to a single output instead of mapping to a string,
what could I put here instead of mapping to a string in order to maintain those duplicate entries for the for those names.
Then when? Kind of seeing what I'm hinting at. Yeah. Go for it. Yeah. Yeah.
I could just put a vector in there.
I could say each string is going to map to a vector of strings of vector of last names associated with that first name.
So Clinton will map to a vector that just contains Kwarteng.
Shawn will map to a vector that just contains some landscape, but Chris will map to a vector that contains both peach and Greg.
Let's implement that. So there are a couple of ways to do this and a couple annoying gotchas as we go through.
Let me actually bring that size back because I want to talk about the size there.
So one thing I could do here is I know that if I call, I know that if I do this.
If I do map brackets. CLINTON This is going to return to me an empty vector that Clinton is associated with, and it's going to add that to the map.
Clinton so far. When I get to that mine, Clinton was associated with nothing.
So the piece that I've highlighted here will actually become a vector.
It will return to me a vector. And if this gives me a vector, an empty vector that it has added to the map.
And why is it adding to the map? Because I'm using the brackets syntax instead of that.
Well, if this is a vector, then I can call add on that vector just to add to this name over here.
So this returns to me the empty vector associated with Clinton, and I add to it Kwarteng.
And same here. This associate. This will give me an empty vector and I'll add to that vector some landscape.
This will give me an empty vector and I'll add to it. Greg.
Now, this will not give me an empty vector. This will give me the vector that Chris maps to.
It's the vector that already contains Greg Because I added that on the previous line.
So when I do map brackets, Chris, the piece I have highlighted, it returns to me.
It becomes that actual vector, it pulls it out of the map and then I can call add on it and get a peach in there.
And then same here dot add that creates a new vector that I'm adding to and then add here for tickly and then add here for Zelinski and Stanford.
Oh, no. Tara.
Okay. Let's see. Let's get rid of all this crap down here. And let's see what all is in this map.
And when we give this a compile and run, what we see is there are still five entries, five keys, but the keys are mapped to vectors.
Now Chris maps to a vector with Greek and peach Clinton maps of this vector with one element I map to a vector with one element.
Judy maps to a vector with two elements. NIC maps to a vector with two elements.
I'm kind of a weird gotcha here. Like another weird gotcha about this is you might think, well, oh, I could do this.
Then why don't I do why don't you do this? To add the crisis to the map?
I could say map. I could say vector r string, the Chris's equals map.
Chris, like this, that will add to that vector for me.
And then I'll say the Chris's add drag and the Chris's add peach.
And when I give this a compile and run, Chris is associated with absolutely nothing.
Online I know that because I used the brackets that added an empty vector associated with
Chris and then that vector I tried to add Greg and I tried to add peach to it,
but they didn't get back into my map.
And the reason that's happening is because I this this when this guy returned from the function, I put it in this value,
I put that value over here in this variable, and it actually just creates a copy of that vector.
So there is an empty vector over here in the map, and I just copied the empty vector over here to the critters.
And locally I added to this vector, but that vector was not actually bound to the vector in the map.
It just returned a copy of that vector. If you want a variable to actually be bound to another entity elsewhere, how do we accomplish that?
In C++, we use a point. A reference.
Yeah. So I'll just change this into a reference over here.
If I put an ampersand in front of or after this data type over here that says make this thing actually synonymous with the thing,
the vector that Chris is mapped to and then go through and add.
So this is opening a portal. This adds an empty vector to the map associated with Chris.
And then this opens a portal between this variable.
This is now a portal to the map that is r to the vector that is associated with Chris, and we give this a compile and run.
You see, indeed, now the Chris's are getting updated. I have Greg and Peach.
So if you don't have that ampersand there,
this value gets returned by value and it gets copied into a local vector and it's not actually bound to that other thing over there.
So it's just like a weird gotcha. And of course, this is, I understand, going very fast and there are a lot of nuances and details here to absorb.
And of course, these are in the notes that I've that have written for you for today.
Um, one of the things you'll notice, by the way, is the keys here are all in sorted order as well.
And that's just the thing that's happening for you. Oh, I also want to mention.
The map and I mentioned already the set lookup is very, very fast.
Same for the map. It's very, very, very fast.
If you start looking into the Stanford C++ library documentation, you'll see another thing called a hash set and a hash map.
And those things are actually even faster than these ones, but they don't maintain sorted order.
But they're both really, really blazingly lightning fast. I mean, the difference between the two is almost nothing.
But these are the only ones you want that you need to know for now. We'll talk about hashing later this quarter.
The final thing that I want to do is show you an application that maps are frequently used for.
So sets are frequently used to duplicate things.
Maps are frequently used to keep track of counting of things.
So what I want to do is just write a quick program that opens a poem that's in a
file on desk and then counts up how many times every word occurs in that poem.
And here's how I'm going to do that.
And I'm going to introduce you to a few extra functions as we go here and leave it to you to look into things like this.
There's a file library in the Stanford C++ libraries where you can use a bunch of file processing functions.
It's just kind of a neat thing there. So let me do avoid get frequencies.
It's going to take a file name we want to open, and then a map that maps strings to counts.
I want to count how many times each word occurs in this map. I'll just call this my map to open a file in C++.
So I'm going to do an input file stream. This is the data type that you used to create to open it.
Input files. I have stream input, file stream. I'm just gonna create a variable of that type.
And then we have a file open function that's built into maybe it's open file,
an open file function that is built into the Stanford C++ libraries that wants to take
a stream like that and then a file name that we want to open and it actually returns.
You can check if this fails to open.
If if it does not return true, we could maybe do code out o like that and and then, I don't know, return from the function and it just dies like that.
Then I want to loop through all the contents of this file to read the contents of the file in C++ is really easy.
Using the Stanford C++ libraries you just use,
there's a read file function that can go through and read all of the strings that are contained in a particular file.
And so I read lines function and it returns to you a vector.
You just pass it. This input file stream, this variable we create above and it gives you a vector of strings.
These are all the lines in the file.
So if I ever mentioned lines in the file that just returned all this to me and what I want to do is if I have a line in a file like Roses are Red,
I then want to split that up into three separate streams. Roses are red, and so let's do that.
Let's do this for string line in my mind's vector, this is all the individual lines.
There's a function built into the standard C++ libraries that also just split things up for you.
So I'll do this is for each. This is going to give me the words.
So we have a string split function that takes a vector and you just tell it what you want to split on.
So if you have something like Roses are red, it will split up into three.
Individual three individual a vector of three individual strings over here.
Oh, is that mean actually a vector of three individual strings?
And that's actually in the string library like this. So include.
Esther H. And then from there, once I have those each of those words, I can just loop through.
I can say for each word in my word vector. Let's go to my map.
And for that particular word, let's just plus plus the count there.
Because if I have if I see a word for the first time like roses, that's not in the map.
So that'll be associated with zero. And then I'll just plus plus that zero that just got added to the map, that'll become a one.
And so down here, when I call this function, get frequencies and I pass it poem and some map that I've created.
So let me do map. It's going to map strings to integers. This is my map.
And then I want to see out the map and down like this. What I need to do now is find the actual lets me just create a quick poem over here.
Poem to this is roses are red, butterflies are beautiful, Kathy.
And when I give this a compile and run. The word ah occurred twice in that poem R and R, but everything else occurred once.
And so this is counting how many times each thing occurs in a file. Thanks for being here.
I'll see you on Wednesday.
Everyone, welcome to see us on Hours. We're going over fun with collections that what is.
Yeah. Yes. Thanks for your early assignment. Help. It's just a way for you to get a head start on your assignments.
Get some tips and tricks, and also in person. Ask questions. But also feel free to ask questions on them after you participate.
If you still have questions. Now we're going to go over fund collections, which has four main parts.
The first is a warm up and debugging section. Next, we're going to be dealing with some mazes.
Then we're going to build our own search engine. And then lastly, we're going to have some algorithmic analysis questions.
But we're going to go beyond algorithmic analysis and start thinking of ethical considerations of everything that we're doing.
But let's start work with debugging. Now, debugging is the social practice of writing code.
You make a mistake. You want to be able to fix it. Debugging not only teaches you how to fix your mistakes,
but also makes you less likely to make that mistake again because, oh, I did this, it was wrong.
Now I know how to not do that. Now, luckily, the creator has an incredibly useful interface for debugging and it looks like this.
The queue to create a terminal. Now to go into the debugging session is sort of clicking this green run button at the top.
You're going to press this run button with the bug in the middle.
They'll start a debugging session. Now this will be your variables pane when you start debugging session.
And if you have a breakpoint, then a variables panel will show up in the top, right?
You'll be able to see the state of all your variables here. Now, if you don't see this by default, your debugger may not have it set.
So that means you're gonna want to follow these instructions for in the assignment
spec to configure your key debugger to get this pain to actually show up.
Another note is that the pain will start out it the first time you're running a function.
This queue may just be the queue and you see nothing else in order to expand it.
You want to click on this left arrow which will be facing right and then it will go to a dropdown and actually show the items in the queue.
One other thing to note is the step over button displays. You run code line by line over the function call.
It finishes running the function and goes on to the next line.
This is super helpful to see the variables change per line of code that you're written to see.
Maybe the variable to change that you want to. That's a line you should check out. The step into button.
Right next to it is a bit different. If the line has a function to call, you can actually go through that function line by line.
You don't call it for non functions though, because you're start going into some code that you aren't writing for your C++.
So make sure you only do this for function calls.
But essentially, this is the step over button when you're inside a function, because otherwise you're just gonna step over the entire function call.
Last is a step out. But if you're currently in a function because you step into it,
you can just step out to complete your function and returns back to the line by line page that you're working on before the super helpful.
Once you've found something where everything looks right, you can just step out of it really quickly.
Or if you've got to move the breakpoint instead of having to rerun the whole function again,
you can just step out of that function that you're running. So if you're ever in code, you do it right.
And if see, Oh, wait, I haven't seen this file before.
This is my toxic heap out I'm working on. Make sure click this button, step out of it, because otherwise you're going to have a really confusing time.
Lastly, as I alluded to earlier, you're going to want to set breakpoints, to set a break point.
You want to click on the left side of these numbers and you'll see a little red circle pop up.
Now, for every breakpoint you have, when you click the run in debugger, where we hit a breakpoint, your function is going to stop.
Otherwise it's going to run all the code above that breakpoint as normal as if you just clicked in a long run.
So some common mistakes we see when people are trying debug is that they click the regular
run button instead of running a debugger and also that they don't get any breakpoints.
So the run debugger isn't really going to do that much.
Lastly, if you want to exit your debugging, which you're going to want to do, eventually you have to click this red stop debugging session.
If you just click on this pause, it won't actually exit, which is slightly different than the normal run for cutting.
So make sure once you're done debugging, you click this red square and then you can start running your code as normal again.
This will run your code as normal until it's the next breakpoint, which is very different than running your code from the beginning again.
So this is useful if you're in the loop, if you want to get back to another breakpoint.
But it's not the same as exiting your code or running your entire program again.
So you have to click the red button first before you will be able to run your entire program again.
So if you have a stock program and you're not really debugging mode,
you can start the program by closing the console window or choosing quick from the menu bar.
This will force quit or forcibly exit the program.
But if you're in the debugging mode, you can interrupt the program by pressing the the oh my gosh, the blue pause button.
Now make sure that the tooltip actually says interrupt because clicking this program will pause program, execution and return control to debugger.
That is the same as debug interrupt from the application menu. But why is that when you can use the simpler path?
Now, overall with this whole process, this will allow you to gain a lot more information to diagnose what's wrong.
So the program state and all these variables will be exactly the same.
And you can look at them even once you've interrupted. So if you see some some variables that are what you think they should be,
then this is a good way to be able to get to the point where you can look at those variables and then change them.
Now, lastly for the warm up, we have a few extra parts after, you know generally how the debugger works.
We give you some exercises. The first is to make sure that you can look at all these sort of data types in the debugger.
That's what I just went over. But generally the main practice to use the debugger is you click on the red circle at the left to set a breakpoint.
You run a debug mode, which is that middle button in the bottom left, you open it up, analyze the variables,
panel in the top right, and then you step over until you see a certain number of items in the right and then expand to see values.
Your first exercise is just making sure you can see all these values in the top right.
Next, we give you an exercise to test duplicate negatives.
That's a function that takes in occupants and duplicates each negative number that they find there.
So three -will be changed to three negative five, duplicate it and then ten.
Your idea is to test the code if it outputs, see what returns the correct outputs and what doesn't.
This code ends up being buggy.
And that's the whole point is now that you have code that you know it's buggy user debugging skills and tools to try to find out where the bug is,
but only where the bug is. Try to find out what inputs cause an error because you'll find that some inputs work and some inputs don't.
So part three is using debugging to find the source of the issue and actually fix the code.
Now should only be one or two lines of code to fix the problem, so just keep that in mind.
But when you diagnosed the error exception, then you'll be done with the woman.
Now, one thing to note is that you may have an error pop up happen, and this is a bit different than just returning the wrong value.
So maybe wondering what's happening there.
Well, when error is called, that means that some code explicitly called the error function, your code essentially crashed.
This happens with an operation that is illegal. Most commonly when you're index is out of bounds,
you try to access or when you try to read a file that doesn't exist or modify collection while you're iterating over it.
Some things that are just known as in C++ know that this is not the same thing as returning an incorrect answer.
So if you see error, that means that something's wrong.
But it also means that something's wrong and you have a certain a sense of what you can check.
It's not just, Oh, something's wrong. I don't know why. You know, that's something a bit strange happened that a programmer wanted to avoid.
So maybe you start checking your indices, make sure that your files that you're reading actually exist,
or make sure that you're not modifying any collections while you're iterating over it. That's it for the moment.
We're going to dive into Maze. So Maze is a really cool exercise that uses grids, stacks and queues, all your sort of data types to solve masses.
It's going to be very helpful to check Stanford's library documentation as you're here.
If you look at this PDF, these are hyperlinks so you can actually look at them as you go.
But the idea here is that you have to implement the base program.
You're going to solve a program, write program that can solve a maze by checking every single path going to the end.
And it will do it like this. You see how it explores the path by that's incorrect and then explores a different path.
That's exactly the kind that you're going to write, and then you're going to do it slowly and steadily.
One idea is that the maze always starts in the top left and always ends in the top right.
All of these valid moves are the white spaces, and the black spaces that are visualized are walls, which means you can't move there.
So this deals with grids. So important grid nomenclature now, is that correct?
Inbounds Road column returns true If the row column position is inside the bounds of the grid,
it doesn't say anything about whether it's a wall or empty.
That's what you're going to do with grid row column or grid Duckett Row column that returns the value in the specified wrong column,
which will be either true or false In this case,
because we're dealing with the grid bulls, we're also going to be dealing with a collection of grid locations,
which is a new data type which will get there. The maze, as I said, is represented by grid bulls, which means true is a looking quarter.
You can walk there also as a wall, so you don't want to be walking there.
Grid location is what it sounds like. It's a location on the grid and if you're confused by the data type, don't be check the documentation.
It's a bit different than just doing the row column, so just keep that in mind.
Here's the documentation that might be relevant.
I won't be going over this, but this is some really good reference to look at to see that something works.
What I will be going over is that a vector of relocations is what we call a path.
So, for example, if you have a vector, great location, my path and it's far rows in the columns that goes all the way here.
You can see you start at and then row 
Assuming that all these are white, this would be a valid path.
Now, if you call my path zero, because my path is just a vector, it's going to return something that you can easily predict.
Now if you look at just amazing general where repeating individual rows and columns
May three two ends up being this note that it is rows first and column second.
And because this is a black square or a wall, it's the answer is going to be false for this.
So just generally getting more practice with all your stuff because it's going to be second hand nature by the time you're done.
No, I don't think of means that you're going to be doing stacks. That's the point of stack.
Functions are going to be push, which pushes the value onto the stack.
That adds it to the top part, which removes the top most or the most recently added value from the stack and returns it and then peak,
which returns the topmost most recently added value, but it does not remove it.
So some instances of you might want to pop, some instances we want to peek, so not remove it.
Make sure that you're doing what you want to do every point. You must be messing accuse.
Shoes are a bit different than stacks as you're going to lecture where you add value to the
back of the queue and then you queue and return the first item to the top of the queue.
You'll be dealing with queues of vectors here and a vector will be a part of the maze.
So you have queue vectors, you're going to be dealing with multiple different paths through the maze.
So to actually solve the maze, now that we've gone through the data types we'll be using,
you have three functions or three and a half you have generate valid news check solution and then solve may be it FS and DFS.
And although these are technically two different functions, they're actually very similar.
So you can just really treat them as one in the grand scheme of things.
So first we'll be doing will generate valid routes, which takes an operator, pulls our maze and a grid location cur.
So with a great location,
Kerr will be like your current great location and you don't be returning a set of great locations of value vacations that Kerr can move to.
Essentially, if you have a location that great. Where can you move?
If you look back at this maze that we have here at the beginning, if you're over here, for example, you have four places you can move on.
My right cursor. Northeast, south and west. But if you over here, you only have one place you can move, which is east.
So that's essentially what you're solving at this function. What makes a great location valid?
Well, either that directly north, south, east or west locations occur are valid and it's only one step away from current the grid.
So you can't have zero zero can validate move to three zero because it's not one step away.
The most important part is that it's an open corridor, not a wall.
That is the great location that you're looking at. Returns true instead of false.
So you can kind of think of, Oh, can I moved there? True or false?
As the output of some sort of function will be very helpful when you're working through and turning things up.
Another important thing that a lot of students may forget at first sight is that you cannot check out abouts.
For example, that second location that I pointed to, the north area was out of bounds.
Now you can't really check as out of bounds after you've done everything.
So make sure you use that in bounds before you do checks to make sure that you're not trying to index into an invalid or an invalid index.
Lastly, for very valid moving to try your own student tests, I need to provide to to actually make sure that your function works because
this function is going to be the crux of the whole reclamation assignment. So it's very important that you get it done the first time.
Now make sure that your test cases cover different cases, which isn't the most difficult to do.
And if you're happy with that, feel free to ask an estimate. Go to layer. Next, you're going to be validating pets.
So a given path is a valid solution.
If the path isn't empty, the path starts at the top left corner of the maze and ends at the bottom right corner, the place that is location.
The path is a valid move away for the previous location,
which means you're going to be wanting to use your helper function from the prior part of the silent.
And then you also need to keep track of two great locations here.
The path that you were currently at and the path that you're looking at.
Another thing is to make sure the pack contains no. That means a location appears at most once in the path.
This is to prevent you from going in circles, because otherwise you will infinitely penetrate your code and people solve anything.
So a valid path will only be valid if it only visits each location provided to it once.
So you're also going to be wanting to store that you want to try out a good way to store that.
So make sure to think about that as you go along. Now note that velvet path is a void function and will do nothing to provide a path is valid.
That's perfectly fine, but if the path isn't valid, you're going to run into an issue.
And even though it's a void function, that doesn't mean that you do nothing.
You just don't return anything. Instead, you're going to want to call an error.
The error should suggest the reason the path is faulty. So, for example, you might have error.
Here's my message about what has gone wrong.
So replace that with error access to place that was out of bounds or error access the path that's already been visited.
Something along those lines that makes it very clear what went wrong.
And then write your own test cases to make sure that you're calling your error correctly.
For example, if you have two errors, but one shows up after the other.
Which one do you think should happen in your past? Who knows? Lastly for Macy, you have some short answer questions.
Make sure to fill these out as you go. There should be short answer questions after each checkpoint in the maze.
Make sure you do that. Now the second part of Maze is the Solve Maze, DFS and DFS.
So this is really only one portion, even though it's actually two ideas.
So we're going to solve the maze using two different techniques. Start with breath first, search.
Breath for search means you take all the all the parts that are of certain length and then the certain like plus one plus two, etc., etc.
You're doing breath wise. You're just trying to find all the parts of a certain length.
So to do that, you keep track of many potential paths until we find a solution to our maze.
You think of using a cure paths because what's going to happen is you're going to be adding things over to the end of the path.
Idea here is that a nested data type like Q vector locations might be a bit intimidating,
but you can really just think of the vector locations as one data, two that were messing with, and then you just put some of that into Q.
So the way to start is to create a length one path containing just the entry location, and you want to increase that.
And our maze, the entry is always the location, the upper left corner and the exits in the bottom right corner.
So you are very clear on what you can do with these ones and you can technically hardcoded.
While there are still more parts to explore, you have some work to do.
So first want to dig through the front most elements of a queue. That's the path that you're exploring.
If it ends up the exit, you're done. The career path is a solution.
But if it doesn't need find all the viable neighbors by calling your helper functions for each the neighbor,
you need to make a copy of your current path and extend that path by adding the neighbor and cueing it.
Then you're going to go back to step three and repeat that process. So instead, you only have one path to explore.
Now you have maybe to type times that many paths to explore.
Now, if the queue path is empty, that means that you haven't reached a solution yet,
but you don't have any more valid moves to go to or any more passive check.
Then that means the maze has no solution. Now after divorce, you're going to be doing something similar for desperate search.
Now, as the corporate class stuff for search means you're choosing a single path,
going all the way to the end, seeing it as valid or not, and then it resetting from the beginning.
So this is very similar to BFS, where you're going to using stacks instead of cues.
And you kind of think of, oh, I add in on top and then remove it and then restart for the beginning is accused,
which is going to be exploring in a wide order. Think about why I kind of said it, but you can hopefully think of a different way to get to it.
And then lastly, after you've completed being a passenger, first, we shouldn't have too many changes between them.
You're gonna want to add graphics. Now this looks really cool, but the best part about it is it's only one line of code,
so you can get the very beautiful output without too much effort on your part. This is optional, so if you don't want to do it, you don't have to.
But I highly recommend doing it.
Now, another thing to note when you're doing all of Mars is that Section two problems, But it's very helpful for this portion of the assignment.
So if you're a bit confused on, oh, how is this work, what axis you can do?
You may want to look at the section problems again or for the first time, and then that might give you some big tips on this.
Now. Next is the search engine part. Part three.
So if your search engine the idea here is that each web page that you use on the Internet has a URL or a uniform resource locator.
Now, your L is like a page's unique ID to access it.
What we're going to do is we're going to use a string to contain the body of text on the page to create our own search engine,
essentially very similar to a unique ID or the URL.
They're the way we're going to do that is we're going to have a body text. We're going to process a body text and populate a data structure.
Now, one thing is the lines on your body text are grouped into two pairs.
The first line is the page URL, and the second line is the page's body text represented as a single strip.
So for example, if I had the URL shopping list dot com and then the second page is going to be the text represented as a single string.
So eggs, milk, fish, this is going to be the body text.
We might notice that there's some weird things here.
There's a lot of space there since at there's bread and cheese on the right that's a bit separated.
You might have these special characters here that you don't want to deal with, etc., etc.
So first, in order to mess with everything, we got to create an index that looking at all these inputs,
you may see that, oh, if you want to index nice and clean, we're going have to do some work on this.
So sorry. Explaining it in text is you're creating a mapping from content that is like the eggs, milk and fish to location.
So that's going to be the URL. This is complete opposite of how the data is presented to you.
So we're converting this in text. This is more similar to a science textbooks index where say you want to read about the mitochondria,
the next cells that you can find on pages or 
But in order to have created this index, they went to each page of the word mitochondria and added to that index exactly what you're going to do.
So create your inverted index as ABC to earlier.
We're going to have to clean tokens, gather all of our tokens and then build index, which are three helper functions that you'll be writing.
So first we'll start cleaning up will be talking to takes in the string token,
which is a string of characters from the body, text access from the file, and then it will turn value a clean version.
Now, for this function, you're just assuming that the token you provided is given to you,
but that's how you're going to call it the feature functions. Now the first thing you should do is remove all punctuation.
For example, while we in this form will become by removing vaccination points or even if it's in the middle,
you want to remove exclamation points and make sure there's no spaces between them.
Now, the thing is, if a character C fulfills is pump C, that's a function you can call that is considered punctuation.
So this function might come in handy. Let's make sure that a token contains at least one letter a number.
If it doesn't, then you want to return the empty strip. Very important to note.
The second part of clean token is to convert to lowercase. So, for example, you have capital.
Wow. You want to change the lowercase?
Well, make sure that your punctuation returned to lowercase and note that string lived has a function that can do this very easily.
The last part you're doing is if you are indexing, make sure the string you're using at this point is not empty.
Because when you add things to an index or a map,
you don't want to add an empty string because that will make your inputs and outputs for your index incorrect.
Next, you want to gather tokens. So gather tokens takes industry body text, which is the body text from a single webpage.
The return value is going to be all the unique clean tokens that appear in the body text.
So first you want to tokenize by whitespace. Take all the spaces and put those in the tokens by using string split.
Then you want to clean each token by using a helper function and he wants for this into a set.
After you've done all this, you'll just want to return the set and this will give you all the tokens related to what page?
Now last comes build index, which takes in your database file and then a map of strings to a set of strings named index.
Essentially, you can think of this set of strings to be the map to be populated.
So your key is going to be your token for your map, your values going to be the web pages that the token is found in.
And that index note is passed by reference. They may be wondering, bypassed by a reference.
You're populating this map as you go along. So it's going to be a lot easier to just add one at a time pass by reference,
make sure you're not making any bad changes to it that would delete it, but it makes things go a lot faster and is easier on you.
Now this function does return it, which is the number of documents processed. So keep that in mind.
You have to keep track the number of documents processed.
Hopefully not the hardest thing in the world, but the hard thing is probably gonna be reading the contents of the database file.
So this may not come as intuitively to most people, but luckily we provide read base file to you,
which has an example on how to open and read a file's contents and put it into a vector.
So read that file, maybe copy some of that code and that's perfectly fine.
Another thing to note is that your LS for every two bytes, so your else here and then it puts here.
So when you're going through everything, you want to go in groups of two.
And that's something that you can or should account for in your book conditions.
So keep that in mind. The idea here is that you're going to read a line,
gather to tokens by calling out for functions and for each token of the index to indicate the token can be found on the page's URL.
So when you're going through each of these lines,
you want to track the URL and then go through each token and then add that URL to that tokens index in the map.
None for a search engine. The last part is find query matches.
This is the last part. A search engine, I promise. I know there's a lot, but hopefully it just goes piece by piece.
So to query your matches, a query essentially is what you're searching for.
And this factual return a set of all your else that match your query.
So this is where the search engine part actually comes in. You built it, you built operations.
Now you want to make sure that you can type things in and actually get things from your index.
So note that a query can be a single term or a comparison with some multiple terms separated by a space.
The space is very important because it makes sure that you can tokenize all the inputs as you go through.
Search terms can or should be separated tokens using springs.
String split. Now find rematches can get a bit confusing, so provided some very helpful Venn diagram instructions here.
The idea here is that multiple search terms are union by default.
That means like if you have the word cat space fish, you're searching for about valid match that has any of those search terms.
Now search term starts of modifier such as plus the matches for this term are intersected with existing matches.
That means cat plus fish will only include the inputs that include both cat and fish instead of either them.
So needs to match her post. If it starts with the modifier minus, the matches for this term are removed from the existing matches.
So if you have cat minus fish, then you want to get all the inputs that have cat, and then from those inputs remove any of the inputs that have fish.
So a valid masked match must be matched for the query thus far and not a valid match for the next turn.
If you're doing the compliments, so keep that in mind as you're going through.
You have to make sure that you're keeping track of what matches happen in order that you get them.
So for example, if you have Quokka, then that's going to be quokka simple and cheap if you're looking for anything as simple or cheap.
Taste plus healthy only taste and healthy.
Tasty minus mushrooms means tasty and then remove all the files with mushrooms in them and the tasty nice mushrooms.
Simple plus cheap. Cheap lots. Tasty without mushrooms.
And then once that operation is done, then you would do that whole tasty without mushrooms.
And then. Or simple. Once that's done, then you're going to get all the files that also have that have cheap inside this structure here.
So that goes left to right. That's the order that you to do. You update the previous one with the new addition.
For a better representation. Here's the idea. Quokka is just a single circle symbol, and she can be either.
Tasting healthy are only the ones that contain both tasty might as mushrooms is only tasty without mushrooms.
Tasty mice.
Mushrooms, Simple, cheap may seem a bit complicated, which is why I'm very happy I did not draw this Venn diagram and I just stole from somebody else.
So it will be simple and tasty. But none of those contain mushrooms at all.
Then when you add cheap with the intersection, it's only going to be from the prior part that was yellow.
That also includes cheap. So that may have seemed like a lot.
Don't get too nervous by compound queries, regardless of how long your queries are.
Each query will meet either a case of union intersection or complement or exclusion.
Just tackle them one at a time like you did for this example where you have tasty mushrooms,
you add simple, you are cheap, and then you can kind of take the idea of,
Oh, after you've done a query,
you have the idea that you have a reduced set that you're looking through and then just look through that set or add more.
There's some things that you should keep in mind is that there are a lot of assumptions we make about the career that will make life easier.
For example, the is not empty and will include at least one search term.
So you don't have to worry about any of those cases. Now, search term has a modifier.
Then it will be the first character in that term. You're not going to have a plus or minus in the middle that you have to account for.
You can just check it. The first character of a new term is plus or minus to cover that case.
A modifier will not appear on its own as a search terms. That means not just minus or plus as the term is searching through.
So you don't have to worry about that. And the first search term in the query will never have a lot of fire.
So for the very first one, you can guarantee that you're not trying to add or subtract to a preexisting query.
You will always be able to get a query that you can search through first. Now, no search term will clean to the empty string.
That's very important. When you clean your tokens, you're not going to get an empty string for any of the search terms.
So to put all this together, you want to build the inverted index print.
How many web pages were processed to go that index and how many told us tickers were
found and for a loop to ask the user for query for each query entered by print,
the matching web pages were else and then understand the empty string indicates the end of the program.
And all this happens within your search engine function. Sounds like a lot, but you've actually built most of this already.
So the only things that are missing that haven't been defined by your helper functions so far are to plot the user for input.
And this will happen forever until the new line or enter button is pressed to input.
Indicate a break in your code and then accept that input, which means you're going to want to practice using get line from earlier,
which will be helpful to actually accept that input and then use it. Lastly, and I truly mean lastly now is beyond algorithmic analysis.
This is the last part. You're almost there. So algorithm analysis is the idea of looking at the bigger runtime in all your algorithms.
We're going to go beyond that and look at the ethical ideas of algorithm analysis.
Look at the real world impacts of what you code up, because ethics are very fundamental to education.
We want to think and foster of our ability to think critically about social impacts,
the programs we're discussing in class, just like Bitcoin classes, and then look at the idea of, oh, take a step back.
How does this impact people?
If you're wondering why this is important to learn and my still hasn't done enough for you as a sexual leader in sexual, there's me.
I'll give you a better answer. The idea of of beyond algorithmic analysis is is going to be open to questions.
And mostly we just want to understand your thinking how you think about these things.
But we do expect thoughtful responses that showcase you, engage with the questions,
problem, tail and ethical considerations that we're discussing and asking you about.
So there's no right or wrong answer necessarily, but we do expect you to put some thoughtful effort into this.
And I would not recommend just saving this until time is first mission and typing things up.
You probably will not get as good of a grade as you expect. But that's all.
I promise you, I got this. And good luck on this assignment.
Testing. All righty.
That's louder than I wanted. Happy whatever day it is.
Wednesday, everyone. Thanks for being here.
Just some quick announcements. So there's a Yale presentation that sends for your early assignment.
Towers posted an ad that talks a little bit about Assignment two that unlocked on Monday.
So if you want to take a look at that and get kind of an overview of what's going on there that's there for you, check out the pins notices in Edge.
The other thing I want to note is I'm moving my office hours.
The café just doesn't work for me, kind of being huddled around a little table, looking at someone's laptop with the sun reflecting on it.
So what I'm going to do is move my office hours to Turin, to my office.
Three, three, one. Be the building across the bridge over here.
So what I'll do is I'll walk back to Duran after class, and if anyone has questions that don't involve me looking at their laptop,
I'd be happy to discuss those as we move back to Duran. And then once I get to Duran,
that's where I'll start taking questions that required me to look at people's code
that maybe compiler questions or debugging questions or whatever the case may be.
So you could just like run over there and wait for me there. If you have a question that requires me to look at your laptop as we go.
So today we're diving into a new topic because my announcement on edX indicated we're
shifting gears from this consumption of ADT to something that's really just different.
So we're talking about this thing called recursion. So let me get a project going over here.
How many have seen recursion before? Let me just see show of hands.
How many have not seen recursion before? Okay. So the vast majority have not seen.
There are some who have seen it, some who. But but the vast majority have not the nature of a recursive function.
And so the word I'm saying there is recursion. That's the noun form, the recursive function, that's the adjectival form.
Recursive. A recursive function is just a function that calls itself.
And when you first see a function that calls itself, it looks like it might be kind of a useless or futile or absurdist practice as Let
me just give you a basic version of a recursive function just to kick things off.
If I have a function called FOO and what I do is I go into foo and the first thing I do is I call foo.
This is a recursive function. You don't need to do anything special to tell the compiler that your function is recursive.
You just write a function that is calling itself.
Now if I call this from main, if I call this function foo right now, what's kind of assuming that because some of you have seen recursion before,
but assuming someone is not seen recursion or if you've not seen recursion than whatever your logical answer is here,
what do you suppose the behavior would look like if you ran a program like this where I'm calling
foo from Main and then what Foo does is it calls foo and then food calls foo and then foo.
Once you call foo, what does it do? It calls foo and what does it do next? What does that sound like it's doing effectively?
You can just shout it out. Yeah. Feels like an infinite loop that it's just foo is calling.
Foo is calling. Foo is calling foo.
It's like having an instruction manual that says flip to page and do the instructions there and you flip to page and it's top of page 
It says Flip to page and then it just you flip to page 
It's like flipped to page and you're stuck in this kind of seemingly absurd, infinite loop.
The behavior that we get is actually slightly different than that.
So check out what happens. I'm going to hit control are here to run it. And did you see the terminal pop up there and then disappear?
It is pops up and disappears. But down here, I don't know if you can see this from where you're seated down here at the bottom.
This this number three application output, it started blinking red.
So. So hone in on that. Do you see it's blinking reds down there. It's a little bit difficult to see, perhaps.
But when you go to this application output over here, it's saying booty, booty boo.
And it's really hard to see this. The program crashed effectively, is what it's saying.
The reason the program crashed is because when we make these calls, we actually can't just make infinite calls on our system.
You all remember what data structure I said was driving, keeping track of of of function calls that we make as we execute a program.
You can just shout out if you remember. Yeah, there's this thing called the call stack.
And so I mentioned when we talked about stacks, if you have a bunch of functions that get called in some chain, then when they finish,
we remove them from the stack and uncover the function that we were at previously and then remove that one and go backwards like that.
So what's actually happening in this program is I'm filling up the call stack, so I'm doing main is on the call stack, which calls foo Foo calls foo.
It's another call the foo on the call stack. And then I call fu again, again, again and again and again.
And what's happening is the call stack in memory has a limited amount of space that it can play with.
And as I call foo seemingly infinitely, what happens is that stack fills up and then overflows and the program gets killed because it's used up.
All of the call stack space is like we just can't keep on going. And so if you've heard of this, like Stack Overflow,
not because you're Googling for solutions to code that you should be working on individually throughout the quarter for your programing assignment.
But maybe you've heard of Stack Overflow, which a lot of developers rely on to discuss all kinds of tech issues and coding issues.
And that's where the name comes from. That's that's infinite recursion isn't actually infinite leads to Stack Overflow.
That's when your call stack gets so. Or that your program crashes and burns.
So here, this is our first recursive function. It's seemingly infinitely recursive, but it actually crashes and burns.
Typically, what we do with a recursive function is we pass a parameter to it that lets us work towards solving some sort of problem.
So check this out. I could actually maybe inspect how many calls are happening to this thing before it dies.
Let me just add a parameter here int and when I call it from main I'll just pass it zero and then every time I call it I'll increment N.
So from main I'm calling foo of zero, then foo foo when I call them M plus one.
So loop zero copy of one through of one cost up to foo of two cost of three.
And if I try to print all those ends out as I make these calls, printing to the screen is kind of a slow operation.
And what you'll see is that just it's taking forever and ever and ever to actually get through to reach our crash just because of the slow operation.
So let me change this a little bit so that instead of printing every and every single time I make a recursive function call,
let me just print every time and then say a multiple of a thousand.
How would I check in code if N is a multiple of ?
I actually want to come print it out. So this instead of printing every single and it's going to go zero 
So we'll get actually to the crash a lot faster because it's not printing as many numbers for the screen.
What should I type in that if conditioned everyone in order to check if this is multiple thousand?
Yeah, I'll mod by and then see if the remainder is equal to zero there.
The remainder after division is what we get with the mod. And so this is checks if this thing is divisible by a thousand.
And so here what you see is okay, so it was actually printing much faster and it got down to 
So made about calls before the stack filled up.
So Stack issue seems to have maybe quite a lot of space in it.
I was able to make about calls before this program crashed and burned and stopped producing output.
This is a useless recursive function. All it's doing is is crashing and making our lives difficult.
What we typically do with the recursive function is take that parameter and there's usually a parameter that's changing as we make a recursive
calls if we want it useful because of the function and we have that builds toward some final ultimate input that we're trying to get towards.
So let me write a different function over here. Let me write a blastoff function.
So I'm going to do void Blast off, takes some integer n and I want this blastoff function to start a countdown.
If I start at five, I want it to go five, four, three, two, one, blast off.
So from Main I'm going to call this with five. This is blast off.
Actually, let me start with three to keep the example that simpler and and then if I want to work from three down towards down toward one,
what I would do over here is blast off and minus one I'll just decrement end with each call.
Now, this isn't a useful function yet. What happens is blast off of three calls, blast off of two, which calls blast off of one,
which goes blast off of zero, which calls blast off of negative one, negative two.
And it's going to go all the way down until we hit StackOverflow again because it's making so many recursive calls.
So with the recursive function, not only do we have this recursive portion that is making a call that it's
changing a parameter and working towards some ultimate terminating condition,
but we do indeed also then code up a terminating condition that we call the base case.
So the base case is our terminating condition.
It's where we say, Look, I've done enough recursion,
so if I start with blast off of three and it goes blast off the three, blast off of two, blast off of one.
Well when it calls blast off of zero, I would say, well, we're ready to just blast off.
So let's just check that. It's usually the base case is coded up as an if statement.
I'll say if an has reached zero, then I'll just do blast off like this.
I'll put that to the screen and then I'll leave the function when you return from a void function.
If you just type return semicolon that says leave this function and you don't need to return a number.
It's not the functions return type. It doesn't have us returning a number or an integer or string or anything like that.
And then before I make my recursive call, I'll print out what number we're on over here, followed by a dot, dot, dot.
So let's trace through let's take a look at the behavior here and trace through how we got this behavior.
And then we'll start maybe doing some more interesting things with the recursion.
So initially, when I call this function blast off, it says I'm coming with three, so it's three equal to zero.
No. So come down here and print three dot, dot, dot, and then call blast off of two.
And when I call blast off of two, it says, is two equal to zero? No.
So come here and print the two dot, dot, dot and then call. Blastoff of two is going to call blast off of.
One. Very good. And I say it's one equal to zero. No.
So it'll print out one, dot, dot, dot, and then blastoff of one is going to call recursively.
What, Every one blastoff of zero. Okay. And then I hit the space case, and I say, is zero equal to zero?
Yes. So I print blastoff, and then I return.
And what happens when I return is kind of silently behind the scenes.
What's happening was I mean, not silently.
I did this main called Blastoff of three, which called Blastoff of two, which got passed up of one which called Blastoff of zero.
And then finally, behind the scenes, when this one returns, I go back to this line from from Blastoff of Zero,
I return and I go back to this line that I was on in blastoff of one and blastoff of one is like a great you're finished.
And then it falls off the end of the function here at this curly brace. And I returned to blastoff of two.
And then when I do, it's back at this line and it's like, Oh great,
that call that I meant to blastoff of one return to blastoff of two, I'm finished and it falls off the end of the function.
It goes back to blastoff of three and blastoff of three returns that that one that I highlighted.
And it's like, oh my call the blast off of two. It's finished. I'm back in blastoff for three.
Let's go on to the next line. And the next line is just a curly brace and the function dies and returns to wherever it came from, which was me.
So I'm calling Blastoff of three, two, one, zero.
And then kind of silently behind the scenes, there's this chain of returns where it goes a loop and goes all the way back to me.
How many of your following that idea can you fit? You're seeing the chain and we're going in and we're following the chain out.
Good. Lots of hands going up there. So you might look at this and say, Well, how is this at all useful?
I could just write a for loop to do this. And you're right, you could just do this with a four loop.
The kind of contrasting term that we have for recursion is iteration,
or we'll maybe talk about coding a solution of iteratively instead of recursively.
You could just do a for loop that does many iterations to a to block off.
Many of the recursive examples that we'll see as we kind of start discussing recursion in this class, you could more easily do with a loop.
You could do them iteratively. And so you might look at, well, why are we doing these recursively?
And the answer is there are some problems that are really,
really hard to code up iteratively are much easier to code up recursively once you know recursion.
But I don't want to jump to those examples because they are really tricky if you're first seeing recursion.
So I'm going to play with some examples today where it doesn't actually make sense to use recursion,
but I'm using these as tools to kind of just introduce the idea of what the heck recursion is all about, and then we'll move forward from there.
So the next one, the next example that I want to look at here, the next recursive example that I want to do now that we've kind of seen the base case,
the basic the basic structure there of recursive function, I want to actually solve a real problem with recursion.
I want to solve the factorial problem. Write a function that computes factorial.
So this on the screen, this is five factorial.
Five factorial is five times, four times, three times two times one.
You all remember that definition of factorial fact n factorial just end times and minus one times n minus two all the way down to one.
I want to you could just code up an iterative function to solve this problem.
If someone said what's five factorial, you just maybe in a loop say five times four two and three times two times one.
But I want to do this recursively. And the trick to doing this recursively is this.
You have to look at the problem that you're trying to solve and find embedded with it within it an instance of that same problem.
So here I'm trying to figure out what five factorial is.
I'm trying to solve a factorial problem and my input is five embedded in this expression.
Can someone raise their hand? Do you see embedded in five factorial another instance of the factorial problem that isn't five factorial,
but what other factorial embedded in here in the in the adventure?
Yeah, yeah. Four factorial is embedded right within there.
That piece that I've got highlighted, there is four factorial.
So if you want to solve a problem recursively, the first thing you need to do is start decomposing that problem and saying to yourself,
this broader problem I want to solve like five factorial, is there a sub problem of the same type embedded within it?
And indeed within this one is a four factorial. And the nature of recursion is I'm going to given a big problem.
I'm going to peel a little piece off the top of that problem and then take the remainder of
that problem and just chuck it to my recursive function and have it spit the result back to me.
And I'll use that and combine it with this thing that I'm trying to peel off.
So five factorial, if I peel the five off of that, I've just got four factorial.
If I know it, four factorial is I just multiply that by five and I've got my five factorial total.
If I could get the yellow highlighted piece, if I could figure out what that is, I would just multiply it by five.
Then I'd have quite. Well, do you see within four factorial yet another sub problem of the same type embedded in there within four factorial?
What's the next sub problem you're seeing? Everyone. Yeah, there's a three factorial embedded in there.
In fact for factorial is. Three factorial times four and then embedded in three factorial.
Everyone, what's the next problem? Two factorial and embedded in two factorial.
What's the next problem, everyone? One factorial.
And what is one factorial? Everyone. One. And so are you seeing here?
Actually, when we get to the one factorial, are you seeing that maybe there isn't a sub problem embedded in that one?
And so if someone asks your recursive factorial function, what is factorial of one?
What kind of situation have we just hit in our recursive function?
The base case very good adaptation to that terminology in real time.
So here's my idea behind then the recursive recursive factorial function we saw five factorial is just five times four factorial, four factorial,
just a little piece off the top, the four and then chuck the three factorial, solve that one, chuck it to your function and get the result.
So all of these involve just peeling a little piece off the top one factorial is just equal to one now.
If we wanted to then write this as a function, we could mathematically, we could write this as a piecewise function and say in general,
and factorial is, well, how can someone raise their hand and give me the general formula?
I mean, I said five factorial is five times four factorial or, you know, factorial would be times factorial.
What's the generalization involving n yoga word? Yeah, Very good.
I actually stopped listening to you. Say it again and time to.
Okay. Yeah, I thought you started to say divided by something, and I was just like. I heard the end and the end minus one.
And I was like, Yes. And just like, I'm sorry, I tuned you up for a second. I'm sure you've done it to me, though, before.
Oh, tuning in. Anyway. So, I mean, I'm sure you all have like at some point you're just like, Shaun's not that interesting.
Who's more interesting than Jacob Elordi?
Maybe? I don't know. Um, what was I talking about?
Now I'm thinking. Never mind. Oh, so and then factorial.
Yes. And then, you know, the piecewise function would say, well, you know, if you are given an equal one, then the result of just one.
Otherwise use this formula. Now, there's actually something that's a little bit imprecise about this definition of factorial.
I wouldn't maybe expect you to know this. I certainly wouldn't throw this question to you on an exam.
But what's actually incomplete about this definition of factor that I say one is the base case.
One factorial is just one. Does anyone know what's incomplete there?
Yeah, go for. Well, if it's negative, it's not defined negative inputs for factorial, it's just not defined for negative.
And then what was the other thing that you said or. A non integer.
Yeah. Patrols is not defined for non integers, so I don't need to worry about it.
Yeah, go for it. Very good. Zero factorial is one.
So secret knowledge over there. Zero factorial is one. So one of the things you have to be on the lookout for is your writing.
A recursive function is sometimes you actually have multiple base cases.
Like if I did this right now, that's why I wrote my function.
Well, if someone puts a zero into that, they're like, Well, it's not your base case, so this must be zero times negative one factorial.
And what's negative one factorial? Well, according to this definition, that would be negative one times negative two factorial.
And we just get infinite recursion over there. So zero is actually a valid input.
And I'm not worried about what happens if someone passes. It's an invalid input. That's their problem.
I mean, we could maybe guard against that if we were nice, but and well, we are nice, but I mean,
we don't have time to guard against every weird thing that people could do to our programs this quarter.
So yeah, you could call this up as a second base case. You could say, well, if N is one or zero, you could just do it a conditional.
And if with a with an order statement there and say in both of those cases I would want to return one,
or you could actually just change your base case,
You could actually observe here that the formula works for one one factorial is one times zero, factorial zero factorial is just one.
And so I added this right here, one times zero factorial. Well, that's just one and one times one gives us one.
So this you could do it that way and just use zero as your base case.
Or you could have those two base cases. There are lots of different ways to go about it.
But here's one way to code this up there. I mean, the mathematical definition, it's recursive in nature and the end.
So it lends itself to this code pretty nicely. In factorial base case, if end is equal to zero, just return one because zero factorial is one,
Otherwise return end times the factorial of end minus one.
So let's take a look here at let's take a look at the I want to kind of trace through the
recursive calls then like what's really happening in this function when we call F of five.
So let me break out of this and I have actually another present that I want to go to over here for you.
So if we call if we call fawith this function, five is not zero.
So we've come to the bottom and say, well, return five times factorial of four.
So check this out. If, if in main we call factorial of five, here's what we would get and this is what I'm going to do over here.
I'm building the call stack and each of these individual components of the call stack is called a stack frame,
an individual frame, an individual call that has its own copy of and and these variables, the values are changing and whatnot.
So if I call factorial of five, what it says is, well, five is not equal to zero.
So come to the bottom line. We're going to return five times factorial of five minus one.
It's four. So it's going to make a recursive call up here, two factorial of four.
And what is factorial for two? It says, well, is four equal to zero? No.
So return four times. Factorial three.
So I make a recursive call from there it says, Well, let's figure out what factorial of three is.
Well, three is not equal to zero. So what is it going to return? Shout it out for factorial three, it's going to return.
Three times factorial of two. Very good. So we have to make that factorial of two recursive call.
Factorial of two two is not equal to zero. So we're going to return what everyone in a loud chorus of the correct answer.
It is two times factorial of one very, very good and then factorial of one one to make that recursive call, one is not equal to zero.
So this is going to return one time factorial of zero and factorial of zero.
Well, zero is equal to zero. So when I make that call, it hits the base case and it's like zero is equal to zero.
So let's return one. And that one, this arrow is maybe one of the key arrows in this diagram.
By the way, this took like hours to create this one little slide that is a little bit difficult to work with,
but I'm hoping these animations help you as you work through this on your own time after class.
When I return, the one down there that factorial is zero call.
It's like, Oh, I now know my nature.
I know who I am, I am one, it's been told and then it dies immediately as we return it back to the next call here one times one is equal to one.
And so that gets returned here. That's what factorial. If one is returning, it's one.
So I plug that into this formula and I get two times one is equal to two, which returns to the previous call.
That's what the factorial two is. It's equal to two. I just figured that out.
So this actually becomes the number two. That's what that return and I do three times two is six.
So factorial three is like, Oh, I have my final answer.
I am six and it returns it back here. And this functions like, Oh, I know what factorial three is now it's a six.
It plugs that into the formula. And this function factorial of four says, well,
six times four is and it returns that over here and factorial five is like, yes, I know what factorial of four is.
That's What's times five, everyone. Oh, very, very good.
It's rainy day Wednesday. Math problem for you.
What is five times ? And then we get a touch of energy.
Well, that was.
No, no. It's okay. I'll remember that when I grade your midterm.
That was the. That was the saddest. It was literally.
Yeah. Okay. Amazing.
That's the stack trace.
And so if you're writing recursive function, I encourage you to pull out a piece of paper and write down what all the calls are like that,
or use the debugger and step through and see what calls it's making and what it's returning.
But remember, on your exam you won't have access to the debugger, so keep that in mind.
Let's do. I've created basically three different ways of looking at this recursive function.
We decomposed it with the highlighted nested thing. We then did the stack trace and then I have a third way that you might think of.
What if I took this function and I called Factorial of five?
Well, if I call factorial five again, five is not equal to zero. So I'll come down here.
I'll be like, well, let's return five times factorial of four.
And what is factorial four? We'll make a recursive call and you can think of this as going in to that function.
It's a nested call inside that function. And now we're here where N is equal to four.
So this says we're now in factorial four. Well, four is not equal to zero.
So we come down here, we're like, let's return four times factorial three.
We make that call. We're going deeper into our recursive calls.
Now we're in factorial three and we're going to return three times factorial of two.
Let's go deeper into this and make another call. We're in factorial of two that's going to return two times factorial of one.
We're going to go deeper into this and say, what's factorial over one?
It's one times factorial of zero. We go even deeper into this and say, what is factorial of zero?
Well, zero is equal to zero. So we just return one and now we start coming out of these.
This is the little part of recursion. We just did the little part, and now we're doing the blue part and returning.
And if you're a caption test, who's doing this for someone who's hearing impaired?
I'm sorry. I don't know how to make that better for you. The So now this returns one.
We go back here, we're like, aha, that's equal to one and one times one is equal to one.
So this returns one. We now go back to the previous column like that just returned one to us two times, one is two, and now we return that two,
We go back to the previous call and right here you'll see we just returned a two here and we do three times two is six.
Let's now return back to the previous call and this right here is the number six and we get four times six is 
We return back to the previous call and the times the five gives us 
Oh yeah. And some people are getting A's.
I'm so excited. Oh, I'm also literally sweating to death as we do this.
I started wearing my jacket because I wanted to move the microphone down here
because I feel like when it's up here pinned to my to my collar like this,
then I get too loud and people start to feel comfortable talking because they're like, Oh, he's on the microphone, He's super loud.
And but you've all been like really, really great about quieting down also these past couple of days.
And, and, and also it was like, I think a small portion of the class that it's been really noisy and disruptive.
So I'm just in a mood to give everyone and it's so great.
Anyway, so that's the that's the factorial function and we've already seen the code for that.
So I'm not going to I'm not going to coat that up.
I mean that is on the slides and I'll let you call that and play with play with that.
And I don't know, trust me, it works. So let's actually do a different problem and this one will code up.
I want to talk about recursive palindrome detection.
So a palindrome is a string that is spelled the same forward as it is backward.
So racecar forward is our air and backward.
It's the same thing. Our CCAR. I want to write a function that detects palindromes and this is indeed a palindrome.
If I want to write a recursive function to check if something is a palindrome, remember,
one of the first steps is to observe a sub problem of the same type embedded within this problem.
And if I can do that, what I'll do is I'll just peel a little piece off the top of this problem and pass the rest of it to my recursive function,
because I'm writing a recursive function that presumably returns correct results for all kinds of sub problems.
So if I'm looking at race car and I want to know, is this a palindrome?
Does anyone see embedded within this just a slightly smaller instance of that question of race
car being a palindrome really depends on is it a palindrome you want to go for back here?
Yeah. Yeah.
So I'll check. First of all, if taking the first and last letters off, first of all, I'll check if they match.
If they don't match, it's not a palindrome.
If I have a string that starts with R but ends with X, not a palindrome, it's not the same forward as it is backwards.
But yeah, if they do match, I'll take those off. And once I've removed those I'll say, Well, is the thing in the center a palindrome?
Because it also needs to be a palindrome for the whole thing to be a palindrome.
So just repeat that process then I'll say, well is a c, e c a a palindrome?
Well, to figure that out, first of all, I'll check the first and last letters of the string and then I'll say, Yeah, lose match.
So let me look at this. Is this a palindrome? Well, to figure it out recursively, I'll say do the first and last letters match.
Yes. So then recursively, I'll say, is E a palindrome? Is E a palindrome?
Everyone. Yeah. That's string with just an E in it. It's the same forward as it is backwards.
It's just the string E forward. It's just the string E backward like that.
So that's the recursive idea. And one of the trippy things about recursion then is it's not like the eighties
where we just give you a mechanical tool that you can use to solve problems.
Recursion is this idea, and to solve problems with it, you first really need to examine the problem and say, We're embedded within this.
Do I see sub problems? Let's take a look at another example for palindrome.
Let's do that. Recursive idea. Is this a palindrome, everyone?
No racer is not a palindrome. Let's run through our function and see what it would do.
It would check our R is does our equal R? Yes.
So then it would come here and say is a palindrome. Well, to figure that out, it would say it's a equal to E no.
And so it would stop and say, nope, this is not a palindrome because that is substring that I was checking if that was palindrome.
The first and last letters don't match there. Let's do another example of traits of is palindrome is people palindrome everyone.
Yes but you're like we want an A.
The participation back there is glorious. Yes. So we look first do pap match.
Yes. So then I would recursively check the rest of the string, the e to this function and say, is this a palindrome?
Well here I would say do the E in the E match.
Yes, the E in the e match. If I pull the E in the e away.
What string in my left with. The empty string, the string with no characters.
This little piece that I've highlighted and read the string with absolutely nothing there, that's not really a space.
This is really nothing. There is an empty string, a string with no characters in it.
Is that a palindrome? Yeah. It's the same forward as it is backwards.
If you have nothing forward, well, then you have nothing backward.
Oh, that's really sad to think about. You don't have nothing.
You have me in my lectures. The you.
Never mind. Oh, okay. So that's my idea behind the palindrome.
So let's, let's coat this up.
Actually, in order to code this up, one of the things that we need to do is peel the first and last letter off of the string.
So let me do this is bool is palindrome takes a string like this and I want to first check if I've hit my base case.
Well, we actually saw two base cases. They're kind of we saw the case where we had just a single character in our string.
Like if just have the letter E, that's definitely a palindrome. We don't need to loop through, make recursive calls to figure it out.
Or if you have an empty string, that's definitely also a palindrome.
How could I check if I have those cases in code?
What property am I going to have to look at with respect to my string of work?
Yeah, the length, if s length is less than two or some people might feel more comfortable thinking of this as less than or equal to one zero or one.
I mean, that's the same as this zero or one because we're dealing with integers here.
So if it's less than two, if it's zero or one, then it's a palindrome.
The zero length string, empty palindrome, the one length string, it's got the letter Q in it palindrome.
So if so, return true array. Otherwise, what was the next thing I said I wanted to check even before making recursive calls?
Everyone. Yes, the first and last letters match.
So let me say, if the first letter. What position is that in the string?
Every one zero. If the first letter is not equal to the last letter.
Oh, how do I get to the last letter? Every one. That's length minus one.
Remember? Because if you have five characters there, index zero one, two, three, four is the last one, not five.
It's the length minus one. So if they don't match, I know the answer right away is that this is not a palindrome.
I'll return false if they do match. I need to peel away.
The first and last character I need to call is palindrome on the inner part.
And here's how we get the inner part of a string. The string has a substring function built into it and what it wants to know is, first of all,
so if I have a string like this, like race car, these are indexes indices three, substring.
So I want to pull this piece out. That's the substring I want. The first thing this function wants to know is what index should I start in the string?
Well, if I've got my race car string and I want to pull out a car, what index does that string start out?
Everyone. Not a trick question yet. Start to index one over here.
And then? And then what? C++ wants to know next.
I know this is really hard to see. It's really small. It wants to know the size of the substring.
You want to know how many characters do you want overall?
Well, the length of this string right here was seven.
What's the length of this inner string right here, then? Five.
And so what do I do to the length here, the overall string length, to figure out how many characters are in the substring?
Minus two. I'm taking away two characters, the first and last characters.
Those two are coming away. So this function says, Go to index one and get me five characters.
So it'll go here. Go. One, two, three, four. I got you those five characters and it'll recursively make a call with a car like this.
What have I not done correctly with this function?
And by the way, this is one of the common pitfalls and I'll mention this in your in your course notes that I released for you today,
one of the common pitfalls for recursive functions. I see it all the time on exams.
Yeah, go for it. Yeah. I'm making this recursive call right here and then ignoring the result of it.
I need to take that. I make a recursive call that comes back to me.
I then need to return that result back to the previous call.
I need a return statement in front of this over here.
So it's a really common error I see with recursive calls.
I brought a bunch of test cases with me. So that I could just plunk these in here.
So race car, kayak, civic radar road are step on No pets is actually a palindrome.
Step on no pets as well as just like good life advice.
B is a palindrome. This is a palindrome. This is not this is not.
So I'm expecting this to be false. Let me give those tests a run so I'm going to do down here.
Run. Simple. Tests and I'm going to do all tests.
Does it not have to include simple tests like that?
Okay. When you give it a compile and run. Oh no. Expect equal.
Who do you didn't? Somebody missed. Oh, somebody forgot to put a parentheses there.
That's so embarrassing and cringe. Oh, no.
It's too many arguments for the hoodie. Oh, I'm putting it in the wrong spot over here.
That's even more embarrassing. And currently you're like, I got out of bed on a Wednesday for this.
Okay? And it's passing all those test cases and it compiled and ran on the very first try.
Thank you. I know. I,
I did that at one point last quarter and I had a colleague sitting in on my class and afterwards that colleague came up and they were like you said,
it compiled and ran on the first try and they all clapped, but it did not run.
Then goodbye on the first try. And I was like, I know, stop stomping on my sparkle like I'm having a nice Wednesday over here.
Okay, So let me let me say this.
If this is going kind of quickly for you, as all lectures in one in sometimes seem to do, remember, not all of the learning happens here.
I'm here to expose you to ideas and then you run back to your dorm and I'm sure you're over
Ticktalk and TV and all the media that you're just interested in recursion these days.
And so the real reinforcement comes from going to section and seeing problems there.
Then working on any section problems your cell didn't get through as as you went through section in whatever given week,
and then working on the programing assignments where there are these big write ups that all of my colleagues have contributed to,
to make sure that you have this really rich set of information.
And I don't know if you know, by the way, all of the course notes that you have access to.
I wrote all of those from scratch for you. I mean, I did it last quarter, but it's like it's basically a whole a whole textbook.
It's like hundreds and hundreds of pages.
And just last quarter, I pumped that whole thing out so that you I foresaw that you would take one of six be And I was like,
yeah, the people last quarter were cool.
But this crowd, like just the joy that you're bringing to the class today, I was like, I want you to have these really good resources there.
But anyway, that's what's going on there. So here's what I want you to do.
Let's, let's give you an exercise really quickly. I want you to write a recursive function.
I want you to write a recursive function that prints a string.
And the restriction is one. It must be recursive.
And too, any given call can only print at most one character.
So you can't just print the whole string and be like, boom, I used to see out I'd finished, didn't even need to make a live call.
So I want you. So if you want to print Hello, you can only print an H and and you can only print an E within a call.
You can only print an L within a call. Give this a go.
And by the way, what's one of in addition to the recursive call, what's the other component we need in a recursive function, a base case.
And so I often think when I'm decomposing a problem like this, I look for the sub problem embedded within the problem.
And I also think, what's the base case? What's the most basic string someone could pass in here?
And I'm like, I know how to print that without having to exceed one character and without having to make any recursive calls.
Go ahead and take minutes and just play with this problem here for a little bit.
We want to print a string character by character, but do it recursively.
Okay. And then go ahead and submit that to paperless and we'll get that grade for you.
I'm just kidding with the take.
Take seconds to discuss with the person next to you. What did you come up with?
What's your base case? What are recursive calls? What's happening? I don't quite.
All righty. Let's let's bring it back together as a group now.
La, la la la la. Does anyone want to volunteer their base cases?
Tribute where you were like, if this situation happens, I know exactly what to do and I don't need to make any recursive calls.
Anyone want to raise their hands and volunteer their best cases tribute? Oh, no.
Maybe they go for it, I guess.
Oh, I forgot to pass the string. Hopefully you just figured that out. Okay.
Um. Yeah. Then what do you want to do? Yeah, if I start length equals equals zero, then there's nothing there to print.
We can just return.
Or another way to check if the length is zero as you could do equals equals double quotes with no space or anything in between them.
That just checks for the empty string. Both are equally valid. I'll go with the one that we received from the front row and then otherwise I
want to make my recursive call to print string and I need to print something.
Does anyone want to raise their hand? And you can give me either or both of these next pieces, whatever you want to want to volunteer to the group.
Any any thoughts anyone want to share? Oh, yeah.
In the back there. Good work. Amazing print, whatever's on the first index there.
So see out as subzero. Like that. And then so like, if I go, Hello, that's going to print the H and I mean, recursively.
That's the solution, right? If you want to print. Hello. The goal is to print each and then recursively pass.
Allo without the age to that function.
And if that function works, then after you print h and then you pass yolo to the function, it should get all that printed.
How is it going to do that? It's going to print E and then pass the to the function.
How is it going to print Lilo? It's going to print out and then pass low to the function.
How is it going Print low. It's going to print out and then pass over the function.
And, and then we hit the base case and in my head shot, he got low, low, low.
We're working toward the base case. We got low at the end, the low, and also we hit the base case anyway.
So what we need to do is somehow peel that first character off this string.
What function do you suppose I'm going to call over here? Everyone shut it out. Sub stir.
Okay. If I want to peel the first character off, then the substring I want starts at what index one.
And if there were length characters in the string, how many are there? When I pull one off, there's one less.
And so when I give this a compile and run, I didn't even call it in main.
Let me do print string like this and I'll pass it.
Hello? Like that. And we get it printed out.
Hello? We printed the string. It printed each character. Character?
My character. My character. If you wanted to debug this because you're working on a function where you're like, I don't know, it's not working.
One thing you do is be you could use your debugger,
but you could also do this like called print string, and then you could do in parentheses what that is.
And you can actually see these recursive I mean, the the yellow is over here now.
But you can see I call. Hello, Hello, hello, hello. Oh, like that.
And you could put print statements that show you all the recursive calls and you
could put a print statement before the return to see what was going on there.
Can anyone think of a small modification that I could make to this to make the string print in reverse?
And let me just say, one of the ways to do that is I could just go to the last character here.
I could do length minus one, print the last character, and then peel the last.
So start at the beginning to get my substring and peel the last character off the end.
I could do something like that. That gets it in reverse order. Hello is backwards there.
Does anyone see a simple way to get this function recursively to print my string in reverse order?
There's a little tiny modification I could make. Yeah. With your thought. Very good.
I'll just swap the order because check this out if you want to. Hello.
In reverse. And you say first print this out in reverse and then print the H.
Well, if you print Olé OLED in reverse, then in H, you've got the thing in reverse order.
And if you want to put this in reverse and you do first, print this in reverse, then print e first, print this in reverse,
then print L first, print this in reverse, then print another L and then and over here we get this in reverse order like that.
One of the problems with this is that there's no new line character after that output.
If we want to put a new line character because maybe we only want to call this multiple times and have this print the function reversed.
Oh, by the way, why is it reversing? We're using a call stack. And remember, a stack is good at reversing things.
If you call this with HD yellow and then you print on like as you leave the function,
you go lleh you're getting those characters when you print them reversing instead of going through and printing that way,
you're printing as you open the loop, the LDH, you're getting those in reverse order using your call stack there.
If I want to do this, you'll notice that these are all crammed together.
And so if I wanted to do a new line, sometimes people will say this, Oh, put your new line here and l like that.
This doesn't actually solve our problem, though. It puts the new line in front of in front of the first.
Because this, this base case is actually the first thing. We hit it before we print anything out.
So we make our recursive calls, and then this prints new line, and then it prints.
lleh. If you want to print the new line after the H instead, you can't do it in your base case.
This is actually as we go through here, this is the first thing that's printing.
And then I print other stuff as I return. So you might think, well, one way to get around that is to put down here C out and L like this.
And you would be right if you thought that that would fix this. You see, there's no blank line above.
Okay, this time. The problem with that is you never want to write a function in the real world where you're like,
Oh, after you call this function, you need to do this extra thing because I didn't do it for you.
Print the new line.
So oftentimes with recursive functions, we write what we call a wrapper function or a gateway function that leads into the recursive function.
So check this out. I'll do void print string like this that takes a string s and then I'll call my recursive function on that string print string.
For real Z's on s and then I'll do my new line character here in this wrapper function.
Let me get rid of this. Let me get rid of this and then I'll just call this one print string for reals is.
And when you rename a recursive function, don't forget to rename the recursive call that you make over here.
So print string is acting now is a wrapper. It calls the recursive function behind the scenes.
And then when I'm finished with the recursion, I come back to my regular print string and I printed new line character there.
This is a really common paradigm in the real world.
Have a have a function that you call that actually does the recursive call over here and then comes back and does this extra thing.
And I'll put that in your course notes for you to play with an explorer.
The final thing that I want to talk about then is I want to talk briefly about a coin flip problem,
which is suppose we wanted to know what's the sequence of what are all possible sequences of three coin flips that you could get?
Like if you flip a coin three times, you could get heads, heads, heads, you could get tails, tails, tails you get heads, tails, heads.
How can we generate all possible coin flip sequences?
And that's actually kind of a pain in the butt to do iteratively.
And I challenge you to try to do that iteratively tonight or tomorrow or when you have everybody have some time and see how much of a pain it is.
This is one of the first problems we're going to play with where there's actually a really compact, recursive way to do it.
But it's a little bit tricky to learn recursion when you first see it.
I think it's just really if you're sitting here today thinking, this is wild, I don't know if I'm cut out for this now.
It's just wild. Any time anyone sees recursion for the first time, here's my idea.
If I want to make three coin flips and see what are all the results, I'll write a recursive function.
This represents a function call that makes two recursive calls.
One of it's recursive calls. We'll put an H at the beginning of the string,
and then the other recursive call will put a tail at the end of the string and those two recursive calls will spawn.
From there. This one will spawn all the sequences that begin with H, and this one spawns all the sequences that begin with a tail.
So from there I'll make two more recursive calls. And as this keeps on going, so from H, I'll make two recursive calls.
I'll add an H to the end of H and I'll add a T to the end of H. I'll get my h h in my t that way.
And then from all other h to the end of that, to get this,
my other recursive call will add a t to the end of that to get this and I'll leave for you in your notes today.
You can actually see as you flip through here, you can see the order in which the calls are made.
They're going to be made like this. This is the order in which this function and about two.
Right, is going to make its calls and you'll see you can actually click through and see how those all work.
But what I want to do is actually write that up with you really quickly and give you a little bit of a taste of this.
This is a voyage coin flip, and I tell it the number of coins I want to play with.
And then what I'm going to do is call my recursive coin flip function and say
initially I have no coins in my string and I want to flip this number of coins.
So let me right up here. This is my recursive coin flip function.
It takes a string that I've built up so far, and then the number of coins remaining to be flipped.
I don't see if there are no more coins to be flipped then whatever string I've built up so far, that must be a valid coin flip scenario.
So let me point that out and return.
Otherwise, I want to make two recursive calls. One where I take the sequence I've got so far and add a new H to the end of it,
and one where I add the sequence that if I take the sequence I've got so far and add a tail to it.
So two recursive calls in one, it's like parallel universes.
One of them has an H that I flip one as a tail in the same position and I'm just building new strings.
Every recursive call gets its own copy of this string where I've added stuff to it,
and if I flip a coin, then I have one less coin that I need to flip in each of these recursive calls.
So I'll say simulate flipping ahead. If I had three coins, well now I've got two left or flip a tail.
If I had three coins, I've now got two left that I need to flip. And if I give this a compile and run, you never know what prints there should be.
Actually eight possibilities of. Oh, my gosh.
Amazing. It does all eight of those.
And what I'm doing here, by the way, is called function overloading, where I've reused the same name of the function.
But it's two different versions because it takes like this takes two parameters, this takes one.
So when I call this with one parameter, C++ is like, Oh, you mean this function?
And then when I call this with two, it means, oh, it looks at that says, Oh, you mean this function here?
But you can also think this is what I was doing earlier where it's like flip coin for reals is like this is really what's going on there.
And it's printing. Oh, no.
Flip coin. Oh, I need to do this one over here, flip coin for real Z's.
And I get all eight of those possibilities there. Thanks for being here.
I'll see you on Friday, everyone.
Mike, check. Testing. Hmm.
Testing. Testing. That's pretty good. Testing has.
Huh? All righty.
Hello. Happy Friday. Welcome, Welcome.
Welcome. Hello.
Hello. Hello, Hello.
Hello. Welcome and happy Friday.
We're shifting gears a little bit today.
Instead of talking about recursion, I'm going to let that idea kind of percolate for you a little bit in the background.
And I'll let you think about in practice some problems with that and whatnot.
Today, I'm actually shifting gears and we'll come back to recursion on Monday.
And I actually spent quite a lot of time doing a lot of recursive stuff starting
Monday and then moving through all of next week and then part of the following week.
What we're talking about today, actually, as we shift gears, is this thing called bigger runtime analysis.
So today we're talking about what is the tool that we use to evaluate and compare the
runtimes of two functions that are maybe trying to save and solve the same problem.
And so I'm going to that's kind of like one of the themes of this class is runtime efficiency,
writing efficient solutions to our problems and and examining how efficient those solutions are.
So what I want to do is start actually with a bit of a broken idea.
And this so this first idea that I'm going to start with is indeed a little bit broken and I'm going to use
it to actually build up to the way that we actually really do runtime analysis in the field and and and.
We'll talk based on this broken idea, how use it to kind of like motivate where we're going from there.
So the broken idea here, the thing that you might be tempted to do if you wanted to analyze how quick
two solutions are to some problem is just do a direct run time comparison.
So suppose you and I are solving some problem when we're both independently coding up our solutions to
that problem and you run a program and you time it and it takes seconds to run on some input.
And I write my program and I time and it takes seconds to run on that same input.
Why would it be unfair? Like raise your hand if you have an idea on this.
Why would it be unfair to say your solution was faster than mine just based on
this basic run time comparison where in fact your runtime is faster than mine?
Why would that be a bad comparison? You know what? Your thought. Yeah, we're.
Good morning. Yeah, very, very good.
So you might have, like a newer, faster system, Right?
And I might be running on some old system, maybe some old crappy system that I've been using to code for decades and decades now.
So that's a bit of an unfair comparison. Why else might it be unfair to this kind of like user use a system timer to run it on your computer?
See that it's .seconds? I run mine on my computer.
It's .seconds for this, for the whatever the input is that we're running it on, go for it.
So it could just be that the small data set is causing one to run really quickly and the other is a little bit slower.
But as the data set gets really, really huge, maybe we'll see an inversion there in terms of which one is running faster,
which one of which is related to another problem,
which is did we just run it on one test case based on the the way that I was articulating that problem?
Did we run it on a variety of test cases?
Maybe the test case we ran it on revealed a situation where your solution is actually really fast and mine is a bit slower.
But in other test cases or other scenarios, maybe mine is really fast and you're starting to get a little bit slower.
And also what we can't do is just have you send me your code and I compile and run it on my machine.
So like at that point, if I were running your code and my code on the same machine and maybe I'd run
it through a wider array of test cases and look at the differences there.
I mean, one of the things that could even happen is, especially if we're running it on maybe a Windows system is as I'm running my code,
maybe Adobe in the background every time I boot into Windows, I swear Adobe is like update, update, update.
Is it time to update its?
Adobe is checking for an update and it's like it's taking processor cycles and slowing down what my system would be doing otherwise.
And so maybe that's happening as I run my program and as I run your program,
I don't have background processes that are kind of preempting the process that I'm trying to time.
So that would make the comparison unfair there.
And another thing is, if we want to compare or talk about run times and we have people across the globe working on some problem,
what we don't want is maybe a thousand people across the globe to be like,
okay, we need to see like who's the fastest, so let's all send them to Shawn.
And Shawn has to sit there and run all of them and time them, and we're going to trust them to do it.
So we want a more independent way of a platform, independent way of looking at how fast solutions are and talking about how fast those solutions are.
So this approach is very system dependent. There can be test case bias.
We could have background processes slowing down things as we're trying to test how long a process takes.
So I want to talk then about a different idea. And I want to be really clear about this.
This next idea is also still broken, but this really leads into the actual way that we do run time comparisons in our field.
It's still a little bit broken, but it's a lot it's a lot better, which is we could look at a program and instead of timing it on a stopwatch,
we could count up the number of operations there are in some function that we're using to solve some problems.
So what I mean is we could look at a function and again, so like you've written some solution to a problem, I've written my solution.
We could look at both of them and just count up how many equal statements, assignment statements are there in the code,
how many comparison less than equal to greater than operations are there?
How many arithmetic operations are there like plus times, divide, subtraction, modulus.
And then we could also look at the cost of any function calls that we make from within our functions.
And this is actually starting to look a bit platform agnostic, right?
Like whether you have a brand new computer or a decades old computer that just kind of like on its last legs,
the function that you put on that computer. If it has five assignment statements, it has five assignment statements,
and it doesn't matter what computer you're running it on, and there's just five assignment statements there.
So we can start to just count up all these operations and it looks system independent, kind of agnostic to the system that we're running on.
So, for example, suppose I have this function, it takes a vector and it just sums up all of the integers in some vector,
so it goes through its sum, its initial initialize to zero.
We just loop through the vector and for every element in the vector v sub I we add that to our stock and then we return our sum.
Let's take a look at how this approach to runtime analysis would be used to evaluate the runtime.
For this function. We would look for assignment comparison arithmetic operations and the costs of various function calls.
So first of all, I've highlighted up here in Green there's an assignment statement when I call this functions and I set some equal to zero.
How many times does that line get executed? When I call this function, just shout it out.
Yeah, just once. Okay, so I've done one operation there and then I go into this loop and I set equal to zero when I call this function.
How many times does that statement get executed? Everyone also wants.
Very good. And then a here's a comparison statement. Remember, I'm interested in comparisons also when I run this this program,
assuming there are an element in my vector, how many times will this comparison operation happen?
It's actually not on time. It's not at minus one either yet one plus one.
So it's like, let's just add one, remove one. It's probably somewhere nearby.
Yeah. So think about that. Suppose end is three. Watch how many comparisons happen.
I as initial initially zero is zero. Less than three. Yeah.
Then it becomes one. It's one less than three. Yeah. Then it becomes two. Is two less than three.
Yeah. Then it becomes three. Is three less than three. No, but I did four comparisons when N was three.
It's actually n plus one comparisons that happen over here. Now suppose or let's take a look next at this v dot size.
How many times does v dot size, how many times does that function get called when I call this function here?
And plus one times it's once for every comparison operation that happens there.
Every time I look at that less than sign, I call that size. And to take a look at what the size of that vector is.
Now, the size, by the way, in some languages with some data structures,
what happens is that size function will actually loop through the data structure and see how big it is in C++ that size.
It's just storing the size of the vector behind the scenes and it basically immediately returns to that number.
It's a very fast function in this I plus plus operation.
How many times does I plus plus get executed? Exactly.
End times. Right. So I starts at zero I plus plus it to one plus plus it to two plus plus it to three.
And that's where we terminate. So it's exactly end times over there. How many times do some plus equal get executed?
Exactly and times that I come into the loop. Very good.
So if you add all this up and you say, Well, it looks like the number of operations I did was four and plus four operations,
you can say, Well, that's my runtime for this function. That's how long it's going to take to execute.
It's four inputs for operations, whether we run it on my computer or your computer.
Do you see that that's now a system agnostic way of discussing the runtime for a function?
It doesn't matter anymore whether this is yours or mine. I mean, look, the actual clock time will differ just based on how fast our computers are.
But if I've written a solution, I'm like, it takes four and plus four step steps to run.
And maybe you've written a solution where you're like, Well, mine takes three n plus four steps to run.
Well, then we would maybe say yours is faster, except that's still actually a bogus comparison.
One of the reasons that's a bogus comparison is because they're hidden operations.
Does anyone see any operations I didn't account for here based on the list of things I wanted to count for assignment statements,
comparisons, arithmetic, operations. What did I not take into account?
Go for it. What's one thing you say? Louder, please.
Yeah. If I knew the value of pizza by actually does a hidden arithmetic operation behind
the scenes where your system goes to that vector and it computes based on ie,
how far forward it needs to jump in memory to find the value there.
There's actually a hidden multiplication operation that happens in order for us to get there, and we didn't take that into account.
What other hidden operations were there that I didn't actually account for? Did you go for it?
Yeah, The return there's probably there's some assignment where that gets put into a register somewhere and sent back to another function.
And similarly we passing the vector in here needed to do some work.
What other hidden operations that actually count up when I did this?
Okay, but please raise your hand if you want to contribute. But what about setting up the for the.
That the time? Is it an assignment or comparison or an automatic operation?
When we set up before that, which of those three are you worried about?
But that's what we're counting up is I said, what are the assignment comparison Arithmetic operations that aren't being counted for here.
Does anyone see any other hidden operations that you want to call out?
Yeah, go for it. Yeah.
When I start the function, I have to assign the vector and it actually copies make the new copy of the vector, the whole thing gets copied over.
The other thing that I'm that I'm thinking of here is the plus plus operation. I counted the plus plus.
And so that happens end times. But that's actually two operations. I'm doing arithmetic and I'm assigning the value to I.
So I should really say there are two and steps of work involved with that.
And similarly with the sum plus equals, it's an additional operation and it's an equals operation.
So they're end additions and then there are n equals operations there.
So that should be that. There are two things happening, not just n things happening there.
So one of the problems with this approach is it becomes really tricky to count every single operation with precision.
And then if someone comes to you and they're like, Well, I have a function that solves this with five and plus two steps of work,
and you're like, Well, mine takes four and plus three steps of work.
The problem is you have to sit and have maybe like a half hour debate with them about like,
did you count plus plus two operations or did you count that as one operation?
And then the other thing that happens here that's even more crazy is this is
actually not really a system agnostic way of measuring the runtime for a function,
because on one system, just depending on how your your processor architecture works,
when you compile and run this code on some systems, a plus plus operation might take, say,
three processor cycles to execute on another system, it might take four processor cycles to execute.
So there's actually still some architecture dependency here depending on what system you run this on.
And then we have, as I mentioned, we have to have this whole discussion about like what counts as an operation.
So this is a really tedious approach to runtime analysis, is trying to count up every single little operation and get a precise answer.
And it's a lot of tedium and a lot of work to just not actually get a precise answer that it would be universally agreed upon.
As you know, if five different people looked at this function and tried to figure out all the things up,
they would get probably five different answers there. So here's what we actually do.
This It's really related to what was on the last slide here. This is called order analysis or big O analysis,
and this will haunt you for the rest of your life As a computer scientist is the idea of always looking at a function and thinking,
what is the bigger runtime for this function? Here's how we actually analyze runtime in our field.
It's first we identify the operation or operations plural that are executed the most In our code.
We look at and figure out what one that is. We count up how many times those statements occur,
and then we drop any lower order terms or constant coefficients involved with that addition that we did.
So if we go back to this, this piece of code over here, what is the statement that is being executed the most?
I mean, it's certainly not some equal to zero. It's certainly not equal zero.
It's certainly not returns. What is the statement that's executed the most here?
Just shout it out. I'm hearing some people say the plus equals is getting executed the most.
What we initially thought was it's not less than. OPERATOR That's that's being that's being pinged to the most.
Right. It's being pinged and plus one times instead of end times.
So you can maybe hone in on that one and say, well, that's being executed in plus one times.
And by the way, here, when I say t of n t of n represents the time capital T that it takes to run this function.
And you see that the time, the amount of time it takes is a function of n the number of elements in the vector.
If and it's really big, it takes more time. If it's really small, it takes less time.
So capital T, the time it takes to run this function, that is a function of N the size of your input.
And I would say, oh, it's and plus one. That's how many times the statement is executed.
Now if I drop my lower order terms,
tell me which one of those is the bigger term and or one which is the bigger term that I'm going to keep and the lower term is one.
I just drop that and then I wrap my result n in parentheses and put a big O in front of it.
And the way that I say this out loud is I say my runtime is big o n, or I might say it's order.
And those are two ways to say this. And what that means is when I tell someone, Hey, I have an order and solution to this problem,
what I'm saying is I have a solution that really just does a for loop of length.
N And that's like the worst thing that happens in this, in this solution.
You could look at different instructions so you could say, Well, wait a second, what if we said this?
What if we kind of made a mistake and said, Well, that's the most deeply nested statement.
I think that's the one being executed the most. Well, take a look at what happens.
How many times, again, is that? Is that green highlighted line executed?
Exactly. Just shout it out ten times. Okay.
So if I say my runtime is n, if I dropped my lower order terms, what's what's the highest order term that I'm left with in that expression?
Everyone. And, and so I would just wrap that in parentheses and say, this is order n and this is great.
We have actually now a process where if someone sees that comparison is done and
plus one times they get the same answer as the person who doesn't see that is like,
Oh, the statement being exceeded the most is this plus equal statement.
We still get that it's order n. The big idea is I've got a for loop that string about n steps of work or someone might say,
well, wait, let's count up all the statements that are being executed approximately the most.
We've got that comparison. We've got that plus plus we've got that plus equals.
Those are the things that are being executed the most. And if you add up those three things, the two up top there are done n plus one times each.
That's two N plus two and then another n for the sum plus equals gives me a total of three and plus one and same thing.
What's the highest order term here? Three n or n?
And then there's this piece here that says we drop any constant coefficients.
So you drop the three in front of that and we just say that this is order.
N And one of the reasons we drop that three is again because trying to get a precise count of the exact number of instructions is a fool's errand.
It's going to be very, very hard. And then even then we don't know the exact number of processor cycles it would take to execute those instructions.
So we drop these constant coefficients and say, it doesn't matter, we're not going to debate it, we just want to communicate the big idea.
So this approach is now architecture agnostic.
If your processor takes, say, three cycles and mine takes two to execute some instruction, who cares?
We're dropping the three in the two. And just looking at the N that's left over and it communicates the big idea.
So let's take a look at some examples. Suppose I have some runtime, I've looked at some function.
I have determined that as n plus four and cubed plus two and squared plus steps of work.
What would you say is the big O runtime? And we have to identify the highest order term and then drop any constant coefficients, shout it out.
The bigger runtime would be big o end to the third power.
Is that high sort of term that well, excellent. So we would maybe call that we could say big o n cubed.
You could say order and cubed or you could say we have a cubic runtime here.
What about this next one, a sixth of n squared or a thousand n?
Which of those is the dominant highest order term? You can shout it out.
Yeah. Good. You didn't follow for my trick that I was trying to emphasize a thousand n a sixth of n
squared is actually the dominant term for small inputs like one times one is a thousand.
The six times one squared is just a sixth for small inputs.
The N is actually the dominant term. But who cares about small inputs?
If you call a function that has like one element in a vector and you loop through it, it's going to execute like that.
What we care about is what happens when N gets really, really big.
And if you graphed these out a sixth then squared versus a thousand N, there's some point at which that sixth n squared actually dominates.
And from that point forward that would be higher on your graph than a thousand N.
So that is the dominant term and we call this a quadratic runtime.
So you can say big o n squared order and squared or hey, I have a quadratic solution to this problem here.
This next one, the log of an or regular n What's the highest sort of term here everyone?
Yeah. End is the larger term over there.
So we would say that this this runtime is bigger and and you know that if you graph out what you just like f of n equals n on on a graph,
what you get is a straight line. So we call that a. Linear runtime.
What about this one end times the log of end or just regular and all by itself not multiplied by anything?
What's the bigger runtime here? Yeah, and log n and we call that one a linear rhythmic runtime.
That's the dominant term. What about this one?
Just regular or the log of N? Who's the bigger term?
Here you have a log event. And so we would say that this runtime is ordered log of n or logarithmic is another way to say that.
What about this one six times n or two to the end power.
Yeah, to to the end power gets really, really big really, really quickly.
And we call that an exponential runtime.
And here I'm not dropping the two, it's not a coefficient, it's actually the thing being raised to the nth power.
And then this one's actually a little bit tricky. If I take my five, remember I want to drop constant coefficients.
If I factor a five out of five, what am I left with that that's multiplied by Yeah.
One. And so we would say this is if you have something that has five steps of work, we say the runtime is order one.
You never say like order five, order seven because that count is probably not precise.
So we say that or we call it a constant runtime.
This function, if you passed, if you have a function that always does five steps and you pass it a huge vector versus a small vector,
it's still doing the same amount of work. Apparently it's like ignoring that vector.
So those are our runtimes, and I want you be familiar with that language that I'm using there for each of those.
Let's take a look at some actual functions, analyze the runtimes together.
So I have a function here. I just pass it to integers.
I swap them around and I return. What's your thought on the bigger runtime for this?
Just shout it out if you see it. This is big.
Oh yeah, it's order one.
I'm just passing it to little integers, doing some comparisons and stopping it does like five little operations and then it terminates.
There's no vector here that we're looping through. There's nothing that causes us to be like faster or slower.
And by the way, I don't know if you know this, but like,
if you have the number million and the number two and you like if you set an integer to million versus setting an integer to two,
it's the same runtime for both of those operations. The million doesn't take more time.
They're actually represented using the same number of zeros and ones in your system.
And so it's the same amount of time. So this is just an order one, a constant runtime function.
There's nothing slowing that thing down there. What about this one that we actually already saw that it just goes it lives through a vector.
It has a for loop of length. And what would you say the runtime is here?
Order. And then the other term for that was linear. Very good.
So by the way, there's no end in this function.
So on an exam, if I said, What's the runtime here, I mean, I'd like you, if you want to use order, end that.
You would say order end where end is the length of the vector or end equals the size in more complex functions.
Don't leave it to me to puzzle out what end is. I'll just assume the worst in terms of what you meant by end.
So check this one out. So in this one I have a for loop of length n again for the whole lecture.
Actually obvious assume n is the length of this vector and then I have another for loop of length.
N. What's your thought about the bigger runtime for this one?
You can just shout it out if you if you have to. Yes, it's actually so it's, it's to order and loop.
So it's like n plus another n So that's two n, you just drop that too and it's still order.
N So this is still a linear function and this actually highlights one of maybe the pitfalls of using big O notation.
We're just communicating the big idea, but losing some of the nitty gritty.
So this is this problem here.
I mean, it's actually solving a different problem, but this function here is order N but it's twice the runtime of that one.
But we saw both of them just use order and the idea is they both have linear runtimes,
their growth rates and we'll see you in a second what linear growth looks like versus exponential growth and so on.
Their growth rates are the same even though one is slower than the other.
You might have looked at this. If you looked at this and you were thinking, Oh, let me multiply end by end and getting an end squared over there,
I'm not multiplying them, I'm doing order and work.
And then in addition to that, another order and amount of work where you get the multiplicative factor is something like this.
If you just looked at this inner loop here, this j goes from zero to end J plus plus.
What's the runtime of just this loop in isolation?
Everyone Yeah, this would be order n and, but it's inside another loop that does end iterations.
So you have this order engine loop, but it's happening end times because it's in my order and I loop.
What's the overall bigger runtime here, everyone? Yeah, end times end isn't squared.
How many are following that one? The nested thing is okay, so order n squared over there.
Let's take a look. And so what's happening here is this one is doing an amount of work.
Then I becomes one and this does another amount of work.
Then I becomes two. This does another amount of work. I get an amount of work.
What about this one that I just come into and I return the size immediate?
And for that you would need to know what the bigger runtime is for my size function.
What did I say? Or actually, I said the bigger. I said the size function just returns immediately the actual size of the vector.
So what's the bigger runtime then?
Using my big O notation, what would I have said a minute ago if I'd already taught you Big O, what would I have said?
The bigger runtime is for V that size it's an order one function.
So then what's the bigger runtime for this vector size function? Everyone.
It's actually not order one. Can anyone raise their hand and tell us why this wouldn't be an ordered one function?
And based on something I said really quickly a minute ago when someone had had mentioned something else about another function.
Yeah, You want. You look like you want to raise your hand. Yeah. Yeah. What's it like? Yeah, very good.
When I pass a vector like this, I'm passing it by value.
I create a whole new copy of the vector, and I have to copy all the elements into that new copy of the vector.
Just calling this function is an order and operation.
It creates a whole new vector. And that's actually this is the dominant term up here, not this sneaky thing right here.
This is an order end function. The runtime here is order.
And because we create a new vector, how could I prevent this function from creating a new vector?
Showed it out pass by reference. Okay, so if I pass this by reference, what a reference is is a little tiny memory address that just says,
Hey, this is where to go in memory to find that vector. It's a fast order, one operation to pass a reference to a function.
So now what's the overall runtime for this bottom function? Everyone?
Yeah. Order one. It's just super, super fast. I've just got a fast reference establishment and a fast size method called It Gets Returned.
Amazing. Ooh. Now we need.
We need to start remembering like what the bigger runtime was for certain vector operations.
And when I talked about vectors initially, we didn't have the verbiage of bigger runtime.
But you know that adding something on the end I mentioned with the vector adding something to the end when you call out, it just that's the end.
So that does a quick operation. Just go punk, punk, punk, add something to the end.
What does a single call to add sound like then in terms of its runtime, it sounds like it's order.
Yeah, we expect it to be an order one runtime. You just add something to the end.
It can get worse sometimes, so usually it's an order of one operation. Well, I'm calling that function end times.
So what's the overall runtime for this function, Everyone.
Yeah, it's order n, I'm calling that order one add function and amount of times.
So I've got an amount of work total. It's an order end function over there.
This one's trickier. My insert at zero function.
Do you remember the insert at zero? You've got this vector, you want to insert it zero.
Do you remember? That was the one that had to go boop, boop, boop, boop, boop, boop, boop and move everything over before you could insert it.
Zero. So the question here is what's the runtime for inserting a bunch of elements at position zero?
Check this out. The first element that I want to insert here is the overall amount of work
that happens the first time in certain elements into an empty vector position.
Zero just as bloop that took one operation.
The next element that goes in to insert IT positions here though, it has to scooch this over and then add an element so it goes boop boop.
That was two steps. Now I've got two elements and to add a third one, I have to go bloop, bloop and add that third one.
That was three more steps. So I'm adding up the steps. One step four, the first insertion, two for the next, three for the next.
And if I got three elements to insert the fourth, I have to go boop, boop, boop, boop.
And put that fourth one in there. That was four steps of work. If you had all of that up, one plus two plus three steps of work plus four more.
And finally, when you get to the end, you have and minus one elements to move over, plus an Fone to add to that thing, you do end steps of work.
If you add all those up, does anyone know off the top of their head what the bigger would be?
If you add it all those up, it ends up being and squared.
And let me show you what these all add up to this summation here. Let me call that sum s.
I've got one plus two plus three plus not all the way up to n.
I could rearrange those terms using the which property of addition did I just use to move those terms around on the next line?
That's the commutative property of addition. They commute it, they journey to a new place.
Check this out. This is so wild. I want to solve for x and I actually have now two equations.
I have this equals this and I have that equals that.
So what I can do is add up both sides of the equation. If this equals this and that equals that, then this plus that should equal this plus that.
I can add that adding up the left sides of the equal statement should equals adding up the right sides of equal statement.
When I add x plus x on the left side, what do I get everyone to?
S amazing what I had up n plus one.
What do I get for just this. And plus one right here. And plus one.
What's n minus one plus two everyone and plus one.
What's n minus two plus three and plus one. What's n plus one and plus one.
Do you see that? Those terms on the right hand side, they all add up to end plus ones.
How many and plus ones are there? Everyone there, end of them total.
So what I have is end times and plus one. Now this next part solving process is really tricky.
How many have gotten through differential equations already? How many have not taken differential equations?
Okay, so this next part, you have to follow really carefully on this.
So sorry if you haven't taken Jiffy Q to solve for SE, I'm going to divide both sides by two and then the two disappears on the left hand side in the.
Okay, thank you. They're like three people here who wants an A? I appreciate you all.
And if you multiply that through, that's n squared plus n on the top, that's an order end squared term.
So when by the way, this summation comes up all the time in computer science, I want you to know when you see it,
one plus two plus three plus stoplight thought plus n, that adds up to end times and plus one over two, which gives us an order n squared term.
That end times and plus one that's n squared plus n all divided by two.
Drop the coefficients, take the highs for a term that's squared. You should have.
Did you learn this in? I forget if it's like first or second grade. They cover this in the US education system.
There's like a poem for it. You're like magic for the air. Love it. Oh, roses are.
There's a poem, roses are red, violets are blue. The sum of one through end is end times end plus one over two.
That's just the You should have its first grade anyway.
What is? Let's talk about what linear growth looks like. So.
Okay, check this out, everyone. This is important.
Let's take a look. This function is just going through a vector to find the biggest thing in the vector.
So I started a max value at negative one. I said, anytime you see something bigger than that, go ahead and set max equal to that.
By the way, this function is broken because if your vector only contains negative integers, then it's possible Max actually never gets updated to it.
The biggest thing in the vector is, but if we just have non-negative integers, this function would work.
So one of my colleagues, Chris Greg,
ran this experiment with this and shared this data and and observed that I have two lines here, the red line and the blue line.
So the blue line is what if the maximum is actually the very first value in the vector?
So what you do is the very first in the vector you set max equal to that. You're like, Oh, that's bigger than max set equal.
And then everything else, you look out, you're like, Is it bigger? Is it bigger? Is a bigger No, no, no.
So you never update Max again. So that's the blue line is how long this takes.
And notice it forms a straight line. It's a linear runtime. This is an order end function.
I'm just doing end iterations, and in each iteration there are bunch of order One statements that happen.
The red line is what if the max?
Like what if this vector is actually in sorted order that it's always increasing so we don't just look and compare, but ignore a bunch of values.
But every time we look at a new value, oh, that's bigger. So we set max equal to that and then we look at the next one that's bigger.
So we set max equal to that, then the next one that's bigger. So we set max equal to that.
So we keep going and having to this is a slower version. And then if the Max were at the beginning and we never updated Max,
this version is updating Max Every single time we see a new value, that's the red line.
That's slower, but it's still linear run time. The we still have a straight line when we map out what these runtimes look like.
And so the idea behind linear runtime is this. So check this out.
This right here is about million was the size of the vector, and that took about milliseconds.
Well, when you doubled that to million, the runtime was about milliseconds.
So with a linear runtime, if you double the input size, you're doubling your runtime.
That's the proportion that we're dealing with.
Or here this for for million, it was taking about milliseconds and for for million elements in our vector, it took about milliseconds.
So again, doubling the input double to the runtime, regardless of which of those versions we were looking at,
we have a linear runtime, so doubling the input doubled the runtime.
So check this out. If you have a linear function that takes milliseconds to run when you give it an input of of equals 
how long would you expect it to take if you give it an input of n equals ?
So just shout out how long that function should take. Yeah, is double the input, which means that that should double the runtime.
So I would expect that this takes milliseconds to run.
That's what linear runtime does. Double your input, double the runtime, it gets worse from there.
So check this out. What about quadratic growth? What about an end squared function?
If you have an N squared function, suppose it's the same data as before, but now it's end squared instead of order end for the runtime.
If you have an order and squared function that takes milliseconds to run when the input is an equal and then you double that input to 
the question then becomes, well, what's the runtime here? And the thing is, we don't just divide by 
It'd be like, Oh, we're doubling the input and so we must be doubling the runtime.
The runtime growth proportional to it's an end squared runtime, so it grows proportional to the input squared,
divides the one by the other and look at the proportional increase there.
So if you square your input and divide by squared, the original input that's for divided by gives you four.
So we're actually looking at ax increase. When you double your input to a quadratic function, you actually quadruple the runtime.
So this one would take, I would expect milliseconds to run if that were the end squared case and that might not look so bad.
You're like, well, milliseconds, milliseconds. They're both that quick, effectively.
But take a look at what happens as our input gets bigger. What if N is a million?
Well, to figure out the runtime based on our initial timing and squared algorithm that took milliseconds when n was equal to
because the the the increase in the runtime is proportional to the the increase of from one squared term to the other.
What we do is you square a million divide by squared.
That's a million. Time increase.
So if you go from elements to a million with this ordering function, your runtime becomes million times milliseconds.
That's crazy. That means we're expecting to take milliseconds, which is seconds, which is days.
Right. That's a really long time for our run time.
So to think about like how many of you've written a nested order and squared for loop before.
Yeah. That thing if you have that should be everyone raising their hands If you pass that
a million elements we're looking at taking over a year to solve that problem. So suppose the IRS for example, suppose the IRS for example,
they have a vector of everyone who's submitted income tax for the year and they want to know,
did any did I get two returns for the same person because maybe someone's
committing fraud if they set that up in a double for loop where they're like,
I'll just loop through this vector and for each element I'll loop and see if I see that person's name again.
And then I'll look at this next one and see if I see that person's name again.
And then look at this next one and see if I see that person's name again.
If they take that end squared approach to looking for duplicates and they only had a million tax returns to evaluate,
it would take them over a year to get through all that data. And last year they had about million tax returns to process, not just million.
So it's just an astronomical amount of time.
They would never they would never finish don't commit tax fraud. The message here isn't to the commit tax fraud.
The message is the IRS probably has faster ways of checking whether and so then with cubic growth it's even worse.
So with with squared growth that red line there,
that's how quickly this is increasing the runtime for cubic growth is just growing dramatically like that in fact.
This is not even drawn to scale. It's even it's really even worse than this.
I found it's really hard to find really clear comparisons of runtimes in in a nice chart online and in your notes
today I'll actually I've sat down with a graphing calculator and taken a look at what these these actually look like.
What happens is to to the end really is almost a straight vertical line.
Those are really sucky runtimes and even like end squared is dramatically worse than Megan and LOL given it's actually much closer to order one.
But this kind of gives you the lay of the land order one Runtimes Awesome.
Logarithmic runtimes awesome order and runtime.
Starting to look a little sketchy, but as soon as we get to and then log in, they are there but n squared and true to the end,
those runtimes actually for large inputs start starting to look really, really, really bad.
So what about exponential growth? Exponential growth is so bad.
I want to give you a taste of how bad this is. Suppose we had a function that just for a tiny input like N equals five.
Suppose that took milliseconds, but it's an exponential algorithm.
It's a two to the end runtime. How long would that take for just a tiny input, like ?
Well, the difference there,
the rate of the proportion of growth there is you have to take two to the th power and divide that by two to the fifth power.
What's two to the th power divided by two to the fifth power that gives us two to the th power, which is a million times increase.
An exponential function runtime if you bump your input from to 
And we started with milliseconds runtime, we're looking at three point milliseconds,
which is that number there, seconds, which is days.
This an exponential runtime is so bad you don't want it.
First of all, input like five. It might execute like that.
But then for a small input, like it's taking over a month to execute exponential runtimes.
Oh, and you might think like, well, where do those come up?
And we've seen one already with that coin flip problem we looked at on Wednesday when I flipped three coins, I got eight results.
If you flip a fourth coin, what you have to do is take these eight results and add heads to all of them.
That's eight results there. But then also take all eight results and add a tail to the end.
And eight plus eight is We've doubled the number of results that we have.
So this is actually an exponential function. You've already seen one in class.
When N gets really, really large, it starts pitting is spitting out just tons and tons of coin flip operations or coin flip possibilities there.
It takes forever and ever.
In fact, a fun fact that I like to throw around is that if you so two to the th power, if you want to know how many coin flips are there,
if you're flipping three coins, how much are coins, how many possible outcomes are there?
There are about a billion possible outcomes due to the th is about a billion.
I have another one I want to show you. This is a bit of a runtime puzzle and this one is harder than the other ones that we've looked at so far.
So check this out and kind of hone in on this. I have some input J JS equal to end the thing that I passed to this function initially.
And so as long as J is bigger than zero J divided equals, that means J equals J divided by two.
I divide it in half and then I loop back around. So if n is initially, J gets set to I say to bigger than than than zero.
Yeah. Then it becomes Is bigger than zero? Yeah. Then it becomes divided by two is what everyone eight is bigger than zero.
Yeah. Then it becomes four, then it becomes two. That becomes one.
What is one divided by two has an integer that'll just give us zero because it's point five, but the point five gets truncated as an integer.
So then we'll say zero, bigger than zero. No. So this will terminate the runtime here.
Here's how I'm going to figure out what the runtime is. I'm going to just look at how many times we go into the loop.
Because when I go into the loop, I just do some order one operations, I divide something,
I set something equal and then I plus plus a result that's getting returned at the end of this function.
So if I go into this loop, say end times, then my runtime is order n.
If I go into this loop and squared times, then my runtime is and squared.
If I go into this loop two to the end times, then my runtime is due to the end.
If I only go into this loop eight times, then my runtime is order one, if it's just always eight.
So let's see how many times we go in the loop. The first time I come into the loop, I want to look at what J is doing here.
So the first time I come into the loop J is just n the second time I come into the loop.
What is J equal to? It's not just n anymore. It's now.
What is it? So people said something, but I honestly couldn't make it because everyone was saying it at once in a different tempo.
And AJ becomes an over two and divided by two.
It got divided in half there. Now, the third time I come into the loop, J has been divided in half.
Again. What's end divided by two divided by two? Everyone end over for the fourth time.
I come into the loop. What is J Everyone and over eight and the fifth time into the loop.
I get that J is equal to and over and this goes on until j effectively stops us from coming into the loop,
supposedly come into the loop k number of times. I'm just introducing a new variable.
K and I want to know what is K? What is the number of times I come into the loop?
Again, if I can figure out what that number is, then I found my run time.
If it's end, then I've got an order end run time. If done squared, I've got an order and squared run time.
Well, I want to figure out what K is and so I need to be able to set it equal to something and solve for it.
I see actually on the right hand side, I see a pattern there of n divided by things.
What am I dividing end by repeatedly here?
Yeah, go for it.
It's to test some power so that first and by itself that's just divided by one and two to what power gives us one, everyone, two to the zero.
So that's an over two to the zero.
The next one is an over two to the what first, then have an over two squared, then and over two to the third then and over two to the fourth.
What do you see in terms of the relationship between my power of two on the right
hand side and the number of times I've entered the loop on the left hand side,
the power is. Yeah, that number of times minus one.
So the case time that I come into the loop J would be equal to and divided by two to the K minus one.
It's this number. Right. Like five minus one gives us this four.
Four minus one. Good. This is three K minus one gives us K minus one.
Well that's the last time I entered the loop. What is J?
What is the smallest value of J that actually lets me into the loop?
What's the smallest integer that would let me into the loop? And that's what would be the last time I come into the loop.
What is that value? What's that? Say it louder.
The smallest integer that does let me into the loop is one.
One is bigger than zero. Would let me into this loop.
And so if I just say, Well, the last time I come into this loop, the smallest value that would let me in.
I mean, I know if I've come in here K times, that's what J should be equal to is an over two to the K minus one.
But I know what that integer is that lets me in here the last time.
It's when that's equal to one, when J is equal to one.
So I've got two formulas for J. I just know the last value that could let me into this is JS equal to one.
That's the last integer that would let me in the loop.
And then I came up with this formula that last iteration J is equal to and over two to the K minus one.
I've got a formula now where I can solve for K, let's do it, let's solve for K here.
And over two to the minus one is equal to one is what we had on the screen a second ago.
Well, let me move over to two. Sorry, let me move to the K minus one to the other side, just using my algebra.
Now how do I get that K down? Can someone raise their hand and tell us how can I pull the K down to the exponent?
Go for it. Yeah, yeah, yeah.
Awesome. Take the log base too of both sides.
If you take the log base two of two to some power, you just get that power or log base br of bird the who d who is just who d who.
Okay. So on the right hand side, we just get that power pole down is the K minus one, and you can do the same thing to both sides of an equation.
You can add five to both sides. You can take the log base to both sides.
So if I take the log base to both sides over here, I get K minus one is equal to that.
Can anyone raise their hand and do the hard part? This is again, differential equations knowledge.
How do I solve for K? Does anyone want to raise their hands and give that one to us?
Yeah, go for it. I mean, you're up. You were.
Yeah. I'll add one to both sides. So if I add one to both sides, I've got K is equal to the log base.
Two of N plus one. That's K, that's the number of times in the loop.
That's my runtime. Which of these is the dominant term log of n or tiny little constant one?
The log of n and fun fact when we give big O run times using logs, we drop the base like a D.J. we just put log of N and you don't need to put logs.
You think someone's covering their face. They're ashamed for me. I'll be here.
I'll be bringing my full cringe every day. So anyway, the log, the logarithm content.
So check this out. The pattern that led to that logarithmic runtime was my input kept getting divided in half when you how?
That's the pattern that I want you to be able to identify when you see it in the real world, you have a function who,
if you pass this initially j is equal to we divide that in half, we divide it in half.
Again divide it in half again divide again eight, then four, then two, then one, then zero.
When your input is just being divided in half and that's just leading you towards your final iteration of whatever you're doing.
That's the pattern that we have a logarithmic runtime. Here's how amazing logarithmic runtimes are.
The log is really the inverse of an exponential operation.
So I mentioned earlier two to the th power is about billion.
That means the log base two of a billion. That's saying two to what power gives me a billion, two to the th power gives me a billion.
If you have a logarithmic runtime function and you feed it a vector with a billion elements in it,
it's going to solve your problem in like steps of work that's mind blowing.
So like, I just imagine that comparison there for a second.
You have a vector with a billion elements. A linear solution to some problem would go boop, boop, boop,
boop boop through a billion elements and just take its sweet time forever and ever and ever and ever.
And if you throw it into a logarithmic function instead of vector with a billion elements, it's just like a loop.
And then it's finished in steps of work. It's going to execute like that.
I sometimes talk to people who are like, Yeah, we've got order one runtimes over here,
order end runtimes over here, And Logarithmic Runtimes are in the middle.
La, la la la la. No order one runtimes are over here.
Order and Runtimes are over here. And Logarithmic Runtimes, they're like right over here next to our order one runtimes.
They're super juicy and delicious and fantastic.
We love to see them because again, if I feed a vector of length billion into a logarithmic runtime function,
about how many steps of work is it going to do? Everyone We are amazed.
You should a little bit pee yourself when you see a logarithmic function and just get very excited about it.
I have an aside about exponential.
Oh, and by the way, if someone raised their hand, what was the pattern that I said indicates to us that we have a logarithmic runtime,
the pattern that indicates a log in the very back corner there. Yeah. Go for it. Be loud.
Yeah that our inputs the repeatedly dividing by two.
Very good And we'll see an example of that actually on Monday a really handy logarithmic runtime function and and I
mean I keep talking about like companies like Google and what not like you're processing say billions of accounts,
you don't have time for a linear function for that you need logarithmic or constant runtimes.
There's a really famous problem in our field called the traveling salesperson problem.
And effectively one flavor of that problem is I've got states, capitals in the US and I want to take a road trip to visit every single city.
How do I minimize the distance in that road trip?
So I don't want to start in Tallahassee, Florida, and drive to Sacramento, California, and then drive over to Columbus, Ohio.
That's going to take too long. So how do I minimize that path?
Should we actually go up the East Coast and then back down and actually go across and do like a weird diagonal pattern?
How do we do it? And the fastest solution we have to this problem is an order end squared times two to the end solution.
So it's even worse than exponential. Check this out.
If we could get it down to just an exponential and I got this example from my colleague Cynthia Lee, who's such a badass.
She's advising Congress right now. She's taking a leave for a year to from from teaching at Stanford to advise Congress on a policy.
She's like living in DC, being super, super awesome and representing our university.
We're super well. But I got this example from her, so if we could get that runtime down to exponential,
She computed this and said to solve this problem with state capitals would take four days.
And then she said, Well, imagine that we added Puerto Rico and San Juan to this list.
How could it? Maybe we're flying at that point to get around to these different these different cities?
Well, if we did that, it bumps our runtime up to days because think about this exponential runtimes double when you bump the input up by one.
So we had four days. So for it becomes eight days and for it becomes eight times two is days.
Actually, it's days because there was some decimal position where we were just dropping what was after the four and using an integer.
But imagine we just added to that more of like the largest non-capital cities in the US just to spice up our trip.
So we go from this to up to 
It would take years to compute the solution to this problem and figure out the shortest path to visit all of those cities.
So exponential runtimes are super, super, super bad and we're already playing with them with the coin flip example.
So that's what's going on there. I'm going to let you out seconds early today because I know you have lots of recursion to study this weekend.
Thanks for being awesome. I'll see you on Monday.
Welcome. Welcome to week four of one of six BE Hello.
Hello. Okay, thank you for quieting down like that. I really appreciate that. I have some quick announcements and then we have so much to do.
You know, we talked last week about recursion for the first time that we took a little mental break from it,
but as we were taking a mental break, we just pounded through all that big stuff.
I have some stuff today that brings all of that together,
and I want to get back into recursion because it's really trippy when you're first seeing it.
Some announcements here. So I posted some more section problems on the website and Clinton actually put all of these together for us.
If you go to the section page on the website, one of the Jewish things that you'll see is the star right here.
It says, Are you looking for additional exercises? Then click this link. And there are just tons of extra exercises.
Now there's some stuff at the bottom that mentions backtracking.
We of course, haven't talked about that topic yet, but everything else there as we're looking for more practice as you get ready for the midterm exam,
that's going to be, I think, a really cool resource for you there.
Assignment three drops sometime tonight, possibly pretty late, possibly close to midnight.
Assignment two is due tonight as well. So, you know, that cadence that we're in, things become do on Mondays and open up on Mondays.
You have a quiz series due this Wednesday. Let me play this. Please, please, please do that quiz series.
I mean, it's just bonus points, first of all.
But the other thing about it is you've got to get some more practice in with the recursion of concepts we're talking about.
And those quizzes are going to really help check whether you are understanding some details that are critical moving forward.
You're getting ready for that midterm exam. Another announcement done here is like when you're signing in for their some of
the athletes have had trouble finding people when they signed in for labor.
And so they're implementing a new policy where if they come to where you say that you are when you're signed in,
in the letter for you and you're not there after minutes, they're going to just remove you and boot you from the queue.
So be sure when you're signing in to get help at later that you actually are using an accurate location.
And if you're not sure where you are, go to You just ask someone, Hey, what's this location over here?
How should I sign in for that? And be sure that you've got that thing, that you've got that thing taken care of there.
And remind me to talk about the box of chocolates. I have a box of chocolates, chocolate later.
If that doesn't come up naturally today. Um, let me get some, some code going.
What I want to do is start out by writing a function and talking a little bit about the bigger runtime.
And as I write this function, I'm going introduce you to some new functionality and new libraries.
I want to just write a basic function that takes a vector of integers and some key that we want to search for,
and it returns true if the key is in that vector false, if it's not in that vector and it's a rather simple problem to start out with,
you can move through a vector and see if the thing you're looking for is there or not.
But there's actually a lot of empty structure that goes into creating something like that.
So let me actually just kick it off by saying let's, let's write a search function.
So I'm going to do a Boolean search that takes a vector of integers, I'll call that V and it goes through.
Well, now it needs to include vector dot H in order to be able to do that.
It just loops through and looks for some key. So let me pass in separately an integer key that we're searching for a loop through.
And if I find that return true, otherwise return false. So four equals zero is less than v that size.
Hopefully you're at a point where you're doing a lot of coding and something like that for loop is second nature to you at this point.
If that doesn't feel comfortable, we need to talk about strategizing and making sure you're not falling so far behind.
This is my PSA to say you have fallen so far behind that the midterm is going to be a problem for you.
So if that felt uncomfortable, let's talk about what's going on in your approach to the course.
So I'll just check. I'll see if I at this particular index is the key that I'm looking for.
Go ahead and return true. Hurray.
I count the thing I was looking for, and if I get through that whole loop and don't end up returning true in that loop,
that means the key that I'm looking for is not in the vector. So return false and say it wasn't there.
Well, in order to give this a test run, I need to create a vector.
So let me create a vector down here, a vector of integers.
And I want every time I run this to have just a randomized vector of integers.
So let me I could in main just write the code to do that.
But then main starts to become cluttered with all of this different code.
Like I'm going to create a vector that has random integers that I'm going to call the search
function and test that if I want to do some activity like create a vector with random integers,
I typically think about outsourcing something like that. Like if I have a verb phrase that describes exactly what I want to do,
create a vector of random integers, I think about outsourcing that to a function.
So let me just do that. I'll do create random vector and I'll pass it some number.
The number of random integers that I want to put in here. And so I'll create a function that returns a vector of integers.
The functions name is create random vector, and it takes some integer n and let me create a vector in there.
If I can get this thing to go up there, I'll create a vector of integers, I'll call it v.
Ultimately, I want to return that vector and now I just want to go through four equals zero is
less than and I plus plus and add some random stuff V to add random stuff here.
Now, to nobody's surprise, we've created a function for you as part of the standard C++ libraries that generates random integer.
And so if you include random H that has the Stanford C++ random integer function and so you can type your
random random integer like this and random integer wants to know what the range is for that you want.
So maybe like we'll put those zero through It was red underline I was starting to like, Is the name wrong over here?
Okay, it's totally fine. So if I do this, it just gives me a random integer on the range zero through and puts that into my vector.
Let me just dump the vector to the screen really quickly. Make sure that I'm getting a random integer vector every time I call this run this program.
So seven, blah, blah, blah, to blah blah, blah.
So I'm getting some nice random looking behaviors here so I can run kind of multiple test cases.
Well, now I want to search through that vector. So let me set up a loop here, and that will do that for me.
I've created the vector. I'm going to put that to the screen, and then I want to do something like this.
Like while true, I'm just going to get input from the user at the keyboard.
And this is really familiar to you based on having worked on your programing assignments where you're prompting
for things like keep going until someone just hits enter and they have nothing else to enter over here.
So let me just see. I printed the vector above and then I'll do a prompt.
Like what integer shall we search for? And then maybe I'll say negative one to quit like that.
I'll print that out, and then I want to get someone's input, get an integer for them.
So we have this simple esempio include simple bio, which stands for simple IO simple input output stuff.
So simple IO has a great function in it that allows us to get an integer from our user.
So I can do get integer like this and it just reads what they're typing at the command line or at the at the keyboard,
what they're typing there and pulls that in as an integer. So do it and equals get this integer.
And I said it negative one to quit. So I'll just type that here. Like if PN is equal to negative one, what do I type?
If I'm in a loop and I want to kill the loop dead and go down like maybe down here, I want to do like see out array finished like this.
What would I type in that if statement to kill the loop and come down here and continue executing code every one.
Yeah. Break breaks out of that loop over there. Okay. Otherwise what I want to do is print the result here.
I'll do out what the result is for a search function that takes a vector and this key
and I'll do maybe two and doubles to make the output nice and spaced out like that.
And maybe I'll do two ends up here. I'm just kind of thinking ahead to what the output looks like.
And so we've got this lovely, nice spacing here.
We paid attention to detail. I really want you as you're working on your assignments, by the way,
also looking at the detail which we've spaced out our output and trying to subscribe.
Exactly. Making your output match that. Exactly. That's a big thing.
And industry is trying to make that happen. So if I search for something like six.
True, that's in there. true. That's in there.
true. That's in there. Now, if you want to test the function thoroughly, you also have to check for stuff that's not in there.
So let's test for like and we see that is not in there.
What are some other thinking things that you're thinking that I should have tested here?
I tested six Those things got found.
What are you thinking? Like, if we want to really test this function thoroughly and make sure it's working, what should what else should be looked at?
Go for it. Well, no, it is assumed valid input.
If someone gives me a letter, the program's going to crash and say, that's not an integer.
So just assume your user is not malicious unless the program spec says you have to handle letters.
So here, if this were a formal program, I would say assume that the user is actually going to type an integer for you.
I'm glad you're worried about that.
And we could actually do something like catching an error, checking the input and converting to an integer manually if we really, really care.
So you're on the right track there. That is really, really good. I saw another hand go up over here somewhere or.
Yeah, yeah. Maybe check for negatives. Negative. So I've not checked for anything negative so far.
Now negative one would quit, but negative ten is returning false there.
Or maybe a negative version of some positive integer that's in there.
So -is not found. What else are you thinking in terms of testing that I haven't pinged yet.
Yeah. Something over 
Yeah. To make sure that there's not some weird like I know the integers range from zero through with the way that I coded this up.
Maybe there's some weirdness to my function where, like, if I put something over plus dies there the other.
Yeah. Yeah. Maybe I should test it. Zeros in there. Very good.
So we've looked at positive, positive and negative integers. Zero is neither positive or negative.
So let's look at both of those things there. Um, another thing I'm thinking is I haven't checked whether it can find the first element.
I did check whether I could find the last That was pretty good.
But one of the things that you'll see is you get more and more experience with coding.
Is there a lot of errors where like something at the very end of a vector or something at the very beginning that is just getting skipped over?
Maybe someone starts there for loop at index one instead of zero.
So we skipped over the beginning, so let's check that we can hit the beginning, the end, even indices, odd indices and so on and so forth.
So it looks like it's finding all those and then a negative one to quit and hurray, we're finished.
We get that nice output over there. Um, I want to talk then about the bigger runtime for this function.
And this function, actually,
the bigger runtime for this thing is there's something going on here that wasn't happening in any of our functions that we saw last Friday.
When I call this function, I've got a loop. By the way, what was the bigger runtime for calling size on a vector?
Everybody can just shout it out. Order one, it's a and what's the other word for order one.
It's constant. It just tells us immediately what the size is.
It has that associated with the vector behind the scenes or just returns that immediately.
Oh, by the way, sometimes when people write search functions instead of booleans,
they'll actually return the index where it found the thing that it was looking for.
What do you think would be a good if I'm returning like index here?
Like I found this index zero or index five. What do you think a good return value would be?
This indicate I did not find the thing that I was looking for.
Yeah, go for it. Yeah, minus one. Sometimes people will say zero, but zero is a valid index or sometimes you will say,
well, but could be about index in a larger array there are larger vector.
So yeah, negative one can never be a valid index. So it's a really great index to return.
Just say we didn't find this thing. If I asked you what's the bigger runtime for this function overall?
I mean, we looked at that just calling got size of the ordered one, but the bigger runtime for this function overall,
what's unique about this function compared to the ones we saw on Friday where you would maybe say,
wait a second, I don't know how to tell you the bigger runtime for this function because it's unique in such and such way.
Does anyone see what's unique about it compared to all the other functions we looked at?
Go for it. That's perfect.
Thank you. Very, very good.
So if I find if the key is at the very beginning, it just returns immediately after looking at that first element in the vector.
And that would be what runtime is that? If we just check one element and we return immediately, everyone, that would be order or the one constant.
But if the thing we're looking for isn't there or it's at the end of the vector, I have to go through the whole darn vector to find if it's there.
And what does that runtime look like? Everyone order. N Okay, so we have two kinds of runtime here.
We have what we call the best case runtime and the worst case runtime.
The worst case runtime is how bad does it get? The worst case is I go through the whole darn vector and I don't find what I was looking for.
That's an order end operation where n is the length of this vector, the size of this vector with best case runtime.
Here's here's a really important critical detail that best case frontend.
When someone says, What's the best case runtime for a function, you have to first assume the input is arbitrarily huge.
So first, assuming input is arbitrarily huge because if you're allowed with a function to say, Oh well, the best case runtime here is order one.
Because what if someone just passes a vector with a single element in it, one element in it?
The problem with that way of thinking is, well then the best case runtime for every function everywhere is ordered.
One people are going to be like, What if I just don't call it?
What if I just go have a sandwich instead and your function doesn't even run order one costs the time.
Just completely giving up is is an order one operation. So we always assume our inputs arbitrarily huge and then say,
Is there something about this function that allows us to terminate faster than this worst case runtime?
And here, even if I have a billion elements in my vector and the very first one is what I'm looking for a permanent order one time,
it doesn't matter that there were billion elements in the vector, and so we might say the best case runtime here is order one.
There's actually a problem with the way that I've written this function,
though there is no best case runtime of order one with this function because of a bad port life choice that I'm bad for life,
a poor life choice that I made at one point. This is always going to be order n.
Does anyone see the thing I'm doing that guarantees it's always going to be order and behind you if you were back to someone else with Europe.
Bingo. I'm not passing by reference, which means every time I call the function,
I spend order and time copying the vector to a new creating a new copy of the vector.
And that's actually going to make this always order end. But if I pass this by reference, boom.
Now it's a really fast operation to call this and set up a reference to the vector.
And from there I now actually have an order one best case runtime.
It's where I pass this by reference, and the very first thing I'm looking for is the thing that I want.
So again, it's sometimes on an exam. I'll say like, what's the best case runtime for this function and what leads to that best case runtime?
If someone says, Oh, the best case runtime is order one codes, what if I only pass in one element in that vector?
Then that's that's. I don't know.
That causes me to scream in anguish during the grading party and that causes points to disappear from everyone's scores.
The points just shatter because of my banshee like scream. So.
So you want to assume the you have an arbitrarily large input when you're talking about best case runtime is what's going on there.
This function is not particularly clever in the sense that like so check this out.
Suppose like, say create random vector.
What if I change it to create sorted random vector so that it puts random elements into my vector but also sorts them?
And there are few ways to do this. Actually, one kind of clever way to come up with a sorted vector is to do this,
generate a random integer and put that the beginning of vector and then generate another another
integer and add it to what you had here so that you're only getting bigger as you go forward.
So if you generate a five randomly and then you randomly generated three, five plus three,
which gives you eight, and then if you generally generate a two randomly two plus eight would give you ten.
Do you see how if you're generating zero through and just adding that to the previous element,
you're going to get this in sorted order and by sorted I need at least two greatest.
So you could do something like that. There's also just a sort function that you're aware of already that's built into this.
You can just do v dot sort, so throw random stuff into the vector sort and then return it.
We've got a sorted vector. So if I give this a compiler and run, you see that this is sorted now.
Oh, by the way, when I say sorted I do mean from smallest, the largest, but I hesitate to use the word increasing order.
Can anyone think of like what would a vector look like?
That is maybe sorted from smallest to largest, but you'd feel uncomfortable seeing the order is increasing order.
And actually the term that I prefer to use is non decreasing.
Can I even think of a vector that is maybe saying yeah, it's not decreasing, but you'd feel uncomfortable saying it's increasing to four.
Yeah. That's sorted from small.
It's the biggest, right. But it's not increasing. I would say it's non decreasing though, so that accounts for repeats there.
Well my, the function that I wrote above, it's called linear search.
It goes straight down the line. And as a linear worst case runtime, it doesn't do anything clever to capitalize on the sort of ness of an array.
If you wanted to search for in this array, in this, I keep thinking right.
I mean vector in this vector, just sort of the beginning loops through to the end.
And I don't think that that's particularly interesting or neat or novel.
That's something that we all could have done while we were taking one of six. P So what I want to talk about next is if you have a sorted vector,
there is a faster way to search through that thing to see if it contains a particular integer.
And so for that. Let me go to the bomb.
Not this window. This window. So here I have a vector of like and I've hidden from you the values.
And I want to know, does this contain the value? 
And by the way, this vector is sorted. I could just start at the beginning and loop through the blue and look for 
But that's a slow, sad, linear run time.
What was that? That's a regression. Back to one of six.
Hey, we want to see something a bit more clever today. And some of you have probably seen a more clever algorithm.
Does anyone have any thoughts or maybe you've just seen this for, you know,
if I want to search this whole array to see if is in here by Arabian vector where someone would raise their hand,
where could we start that search process in the red right here? Yeah, right in the middle.
Right smack dab in the middle. So it's just looking at this vector initially, the the lowest position it could be is here.
The highest position it could be is here.
Like there could be a here and everything to the left is smaller or there could be a here and everything else in the vector is bigger.
But if I go straight to the middle and just peak at this number and I see a 
Can someone raise their hand and tell me?
We don't know if is in the vector now, but what does that revealed to us about about the nature of this vector?
Jago four right here. Say it again.
It's going to be the first. Yeah. If is in here because I know the vector is sorted.
If is in here, it can't be over here because then the vector would actually not be sorted.
It can't be in any of these indices. And I've actually checked over here.
It's not in this one. So the if it exists, must be somewhere.
Oh, sorry. The look of the would have to be somewhere from indices 
So with a single comparison, I have cut my search space in half.
If this were a billion elements, I would have gone from thinking, Oh, there are a billion elements to look out to.
Only half a billion elements to look at. A single comparison wipes out half of the vector from my consideration.
Where should I go next to continue this process? You want me to go to index zero now and do a linear search through this thing?
Or do you have an idea of something more clever? What index to go to next, everyone? Yeah.
Go to the middle of the remaining portion here and peek at that number.
We see a So I'm looking for I know this thing sorted.
I just thought I know that the can't be here.
It can't be here. It must be if it exists somewhere between indices four and six inclusively.
Inclusively. Meaning it could include index four, it could include index six.
Are you following this process here? By the way, my search space a second ago, my search space, I was trying to highlight just this part down here.
My search space a second ago was reduced to this half right here.
And with a single comparison, I cut this half in half once again from seven elements down to three.
Well, one index go through now everyone. Yeah. The middle here and I see.
Well that's not So I eliminate these from consideration and then I've really whittle it down to one index.
If is here it must be between and 
It must be this thing and it's not there, but there's nowhere else that it could have been.
Are you following that idea? Did that algorithm make sense? How I whittled down and process of elimination said it can't be here, it can't be there.
This is called binary search. And think about that run time with a single comparison.
I cut my search space in half. And by the way, just jumping to an index in a vector is an order.
One operation. You just go there, check if it's what you're looking for, cut it in half.
And then I did another comparison. I cut my search space in half again.
Then another comparison cuts my search space in half again. What runtime does that look like?
Big O style that we saw on Friday where I said, if you're cutting in half over and over again, we have a what, runtime logarithmic?
And remember,
one of my favorite facts related to logs and powers is if you have a logarithmic function and you feed in a vector with a billion elements,
what is the log base? Two of a billion Every one approximately 
That means if you have a vector with a billion elements and you perform binding research on it, provided it's sorted, it must be sorted.
Provide your search to work. Then you are going to look at most elements in that vector.
That's amazing and mind blowing that instead of sitting there and doing a billion.
We're just like, we're finished with this, like things that we looked at there.
This is like such an amazing, powerful algorithm.
Let's take a look at another example here. Supposedly search for 
What I'll do when I code this up in a second, actually, is I start by thinking of the indices that my result could be.
So let me see where my result could be. So let me actually do this.
I don't know how great this will work out, but I'll try to do it. So I'll say here, like the lowest place it can be is this index index zero.
And the highest place it could be is this index index 
And by the way, I'm just going to preview these. So they both have two letters in the variable names.
I'll just call this high h. I like this. And then the midpoint here is this thing.
This is the midpoint.
And if I want to search and see is is in this vector, what I would do is I would go to the midpoint, reveal that I'm like, Oh, that's not 
So if someone raise their hand and tell me. What?
Or maybe just shout this out, actually. What's the knowing that I'm looking for and I saw 
What's the highest index where could be hiding? It could be hiding in the next 
Real okay with that? What's the lowest index where it could be hiding?
It could be hiding in index eight. I've already peaked in index seven.
I know is bigger than that. So it could be that big there for me lately.
Using these three variables here. If the thing I'm looking for is bigger than what's at the bid, I'm going to leave high where it is for me lately.
What do I need to set low to? Don't say set low to eight. You use the formula with the variables on the screen.
Low equals mid plus one. I'm going to move it over by one over there.
So the new low is going to be this one over here.
This is going to be the new low index. And then from there I also move mid to halfway.
I figure out what's halfway between the low and the high. So I'll put the mid over here.
Now, if I peak at that number in the mid position there, I see the right away.
So in the worst case this does log n amount of time to search that kind of sort of reveals or it's pretty close to the best case runtime.
What's the best case runtime for binary search? You can shout it out if you see it.
The best case would be. Order one.
A few people are saying it kind of tentatively, nervously. It is ordered one.
Can someone raise their hand to tell us what would lead to an order? One? You've got this, this vector, remember?
Well, actually, let me just see what people have to say. Good work. Yeah.
The thing that I'm looking for is exactly in the middle of this vector, right?
So if I were searching for I would have gone to the middle, revealed to the middle, and then like, Oh, that's what I'm looking for.
That would be an order one operation. So the best case runtime for finding search for the one worst case logarithmic.
What if I were, say, looking for right now?
So I just came over here, I saw and I'm looking for 
What? What's the lowest index where could be hiding? Everyone showed it out.
Eight. The low doesn't update at all. What's the highest index where could be hiding?
Turn formulaic, Lee. How do you like. Before what we did was low equals mid plus one.
But if I see something like is bigger than what I'm looking for, the low stays where it is.
What do I do to high? I said equal to mid minus one.
So minus one gets us two index next. And that's where we go to search for this thing.
So what happens is these two these two values, the low in the high with I'll actually code this up recursively.
They each keep moving toward one another until finally they are they they meet.
And then what's like if you're looking at the next seven, what's halfway between the next seven and seven?
It's just in next seven. And then one of these cases will trigger where either the high moves down or the low moves up.
But either way, what's happened? Maybe I should do it this way. They're going towards one another.
They meet in the middle.
And if you don't find what you're looking for, either the high goes down and then the low in the high of crossed over or the low goes up.
In the low in the high have crossed over. So I'm just going to keep on going. These these indices are going to meet in the middle.
And once they cross over, that's where I'll say, oh, it couldn't. It couldn't.
The thing I'm looking for couldn't even be here. So let me actually code up that that idea here.
So this is binary search. This is in binary search.
It's going to take a vector of integers by reference because I want this to be fast and the key that I want to search for.
Well, I'm going to call this up recursively. I mean, the idea is kind of a recursive idea here, right?
Given a whole array, you want to search for something? Well, by looking at a single index, what I said was, well, it's not over here.
And so my problem went from search this whole vector to search just this part of the vector.
Oh, now I can highlight that search. Just that part of the vector over there.
I'll just make a recursive call to go search that part of the vector over there.
And recursively, what I'll always pass for this function is what's the lowest index where the thing could be hiding?
What's the highest index, where it could be hiding? So down here in main, I want to be able to call binary search like this.
But here's what I don't want to do. I don't want to tell someone, Oh, when you call this function,
please tell me the lowest index that I might need to look at and also tell me the highest index where that thing could be hiding.
You know that a vector has indices zero through the size minus one.
I don't want to do this because someone's going to screw it up, right? Someone's going to be like, Oh, I don't know.
They want to know v size. And then my algorithm is going to try to check the size, which is an invalid index.
Or they'll be like, I don't know, maybe the vector starts at index one. I just don't trust anyone anymore.
Years and years of coding have made me this way. I don't trust anyone.
I don't trust myself. I just trust the compiler, basically.
So what I want to do is actually just call this function.
And we saw this last week where I was like, call the function and then let that function do some extra work.
It acts as a what did I call it is you have a function that really is just leading into another function.
I called it a a wrapper function. Yeah. So I'll do a binary search wrapper that actually just takes those two parameters and
it returns and I'll do binary search and I'll pass it zero and V dot size minus one.
And I trust that this line is right because we all looked at it and wrote it together.
So now let me write and this is called, by the way, function overloading when you have two functions that have the same name,
but they take different numbers of parameters I've overloaded.
I have two copies of that function, so to speak. So.
What do I want to do? I need. Oh, what's one of the first things that I need when I code up a recursive function?
Everyone. A base case. What was the base case?
That I can someone raise their hand and just kind of like I gave a base case.
But what does that start to look like in code? I had the low in the high moving toward one another.
And then what's my base case going to be that says, Stop, We can't find this thing.
It's definitely not here. Yeah, go for it.
Yeah, if he becomes less than low.
So if they if they fly, if they flip spaces over, they cross one over one another, then I'll just return false or negative one.
I was unable to find that thing. Otherwise, here's what I want to do.
I want to go to the middle index. How do you find the midpoint between two numbers?
Every one, like the midpoint between ten and is 
What's the math on that? Yeah.
I add them up and divide by too low. Plus high. Divided by two.
So ten, ten and Ten and 
Divide that by two you get smack dab in the middle of ten and 
This is problematic. I'll talk about that another time. If we have time.
This'll maybe work for our purposes today. And then here's what I want to do.
I want to say let's look at the thing. If the key is less than what's at that position, then what I want to do is binary search.
So if the key was less than that, let's go back to the search demo.
So that actually happened over here when I was searching for I saw that was No, I'm actually doing that backwards here.
So if the key is less than this, So so so I'm looking for 
So the key is less than what I see at the middle.
Well, in that case, the low state where it was and the high actually came down to become this number.
If I was looking for I would just put the high down here at mid minus one.
So just do binary, search the same vector, the same key, the same low, but high becomes mid minus one like this.
Otherwise, if it's the opposite thing. So else if the key is bigger than what I'm looking for, that's what I have on the screen.
So I'm looking for What I would say is well before it revealed actually let me do this.
If I'm looking for I would say, well, the highest place it could be is still right there.
High doesn't change, but now the low has changed. The key is bigger than the mid.
The lowest index that could be is the middle plus one.
So do here mid plus one through high. What does it mean if I get down to this l statement here everyone?
What would that mean? Say it loudly.
Yeah, I found it. Yeah. If the key isn't less then or bigger, then the thing in the middle, then I must have found it.
I'll just return that index right there. There's a bug in the code.
What issue are you seeing with this? I mean, like it does is actually bifurcate the array, right?
Or the vector. Right. Like we're doing the left, half, the right half.
It's either So we have low through high goes low mid minus one or mid plus one high where they're looking at the left side or the right side or mid.
But what issue do you see with this. Yeah. Go. Oh, yeah, there's not always a middle point.
And so what happens with this is integer truncation will take place and it will just the
will get truncated away and this will just naturally actually work out no matter what.
I forgot. That's, that's like an issue that is just resolved naturally that I don't have a lot of time to talk about.
But I'm glad you brought that up. The good work to return.
Yeah, I'm just calling binary search and then it's returning a result to me and I'm like, Did someone say something?
And I'm not? You need to take that and return it back to whoever called this function to begin with.
So we'll return that one back there like that. Ooh.
Is that going to work? I don't know. You never know. Amazing.
It found in the next four. Probably. It just works. And we can accept that it were here.
They didn't find the and then like the zero it finds and negative negative ten.
Amazing. It's binary search.
Oh, okay. And it's super fast.
It's runtime in the worst case. Is what? Okay.
You are too young for that order, and we're so just disenchanted.
It's worth longer than it is. Amazing. It's our favorite run time.
I mean, order one is also really great, but usually it's because they're just some,
like, silly trick, and you didn't have to, like, work very hard for it.
Logarithmic functions are doing work and they're super fast.
They're so amazing. Don't prefer in the real world a logarithmic runtime over constants.
But you can you can appreciate the logarithmic runtime for its cleverness and its hard work is the thing that I am promoting there.
Where am I trying to go? Okay. It's this window over here.
Let's talk. Let's get our heads back into recursion.
Oh, by the way, as always, let me remind you, you've got to be coding that up.
And this is, I think binary search is a really good one to sit down and try to code up on paper.
You've got to be coding all the time. And sometimes you've got to be doing it on paper to really gear up for your mid-quarter exam.
I think that's one where like, try to knock it out and see if you can create a bug free implementation of binary search.
And also if that's weird to you and you're like, Whoa, what's going on?
Sit down with a piece of paper and trace through it on a factor of like five.
See how low is zero, highest four and how they move toward one another and how they cross over.
Or they find the thing that they're looking for.
Dig in and do that sucky tedious work because that leads to you getting an A And that's what we all want is the A,
But you have to like embrace the suck is a word that they have a phrase that people use sometimes embrace the sucky ness of it.
I want to kind of review really quickly that coin flip example we saw last week and then do something
different with the So the coin flip recursive example was like given a number of coin flips like three,
can we produce all of the valid sequences of coin flips that you could get from three coin flip so had had had had had tails, so on and so forth?
Down The Tell-Tale Tail and I showed this recursive tree diagram,
this idea and put it up really quickly last Wednesday and showed this idea of like when you make a recursive call,
you could when you call this function, you could actually spawn two recursive calls, one where you flip the coin and you're like, Yeah, I got a head.
And then another one where you flip the coin, you're like, Yeah, I got a tail and you keep on recursively going The head is that branch,
the tail is that branch and this keeps on going and ultimately you just keep adding a head and a tail.
So like if you go down this right hand side, it's tail, tail, tail, or if you go to the right and then left it's tail head.
A right move indicates in this diagram at least tail a left wing vindicates her.
And I want to talk a little bit about the trace for this code.
Like this just shows the results. But I want to talk about the order in which we get these recursive calls being made.
Right. Did something like this. I said, First of all, if we've run out of coins, then we're finished.
Just print out the sequence you've got. Otherwise we want to make two recursive calls,
one where we flip ahead and then we have one that's going to flip and one where we flip a tail and we have one.
So if you got three coins and you flip one and you had a head and that's ahead and you've got two coins left,
if you've got three coins and you flip one and you get a tail,
then that's a tail and you've got two coins left still on that left hand, that right hand side to do that flip there.
So here's the order in which the recursive calls actually are created.
Initially, we have three coins. And what this does is it says, Well, that's not zero, so make a head recursive call.
So it goes over here and makes the head recursive call. And in that recursive call, we're like, two is not zero.
So make a head recursive call. And in that call, by the way, we add ahead as we make these recursive pulse.
And then I call like what is not zero. So make a head recursive call.
And by the time they get down there, I've had a head, head head that's an equals zero.
My base case, I print that out and then I return up here.
And when I return up to this recursive call, the thing it just did was it made a recursive call to to put ahead on the on the sequence there.
So then I come back up here and each of these, by the way, has a local copy of the string.
I am not passing the string by reference. That's maybe not efficient, but it makes the problem work.
Because if I were passing by reference, then when I came back up to this function call here, that string would still have a third head on it.
The nice thing about each of these having their own copy of that string is when I
return up here and back to a function call where I just have h h in my string.
And so when I try to add a t to the end of hhno, go back.
That gets me to this recursive call over here.
H h with a t added and then that base case is out and it's like, well, we hit zero, so let's go back up here and let's go back up here.
And in this call, what I had just done was this line where I added a heads to it and I did this left kind of branch of this recursive tree diagram.
And now I want to get back up here. It's like, I did that. Let's try going to the right and adding a tail so it adds a tail over there.
And then that recursive call spawns its own recursive calls.
First it tries adding an H to the end of it. So I go over there and add an H, that's a base case.
So now I return and in that recursive call h t that I return to, I just executed this line of code that added an H and got me down here.
And then when I return via this red arrow, I'm returning to this line and then I'm coming on to this one next and saying this string,
add a T to it and make a recursive call that does this one over here.
And then from there I return. And then when I get to this recursive call up here and I return, I'm like, Well, I just did these two lines.
If I fall up the end of that function call, I return back up here. And then this one is like, I just made my two recursive calls, I'm finished.
It falls off the end of that function call, returns back up here,
and then this function call just started by taking an H and adding it to this string, this empty string.
Now it'll instead add to that empty string a tail and make these recursive calls over here.
Always. It's doing this. This first fall first. Then it returns back up.
Does the other call, Then it returns back up. That call has done both its recursive calls.
So you go back here and it's like, Oh, I've done my one recursive call, let me do my second one and same thing here.
This thing spawns two recursive calls in that order, and then I return, return, return.
So that's the premise there. And that was Wednesday. And be sure you're tracing through all of this.
If this is not making sense or coming to layer, coming to office hours, we're happy to discuss these ideas with you.
If any of this is confusing to you, we want to discuss it with you and kind of shed more light on what's going on.
I call this a recursive tree diagram, not just me. Everyone calls this a recursive tree diagram.
As you're working through recursive problems, draw lots of diagrams to show.
I've got a recursive I've got a function here and it makes two calls.
So draw two edges, two lines coming out of that and draw pictures of what's happening to help you understand where your program is going.
The reason we call this recursive tree diagram is because if you turn it upside down,
you see a kind of looks like a tree there, like the branches of the tree growing upward over there.
Okay, I didn't make that term up, but it certainly predates me.
But we do in fact call that a recursive tree.
So that idea, I just wanted to shed some more light on that for you and the code we've already done and saw it running.
I wanted to shed some light on that or revisit it before I got into this next problem.
The recursive permutations problem. The recursive permutations problem sets.
Given a string like a c t, print out all the permutations of the letters in that string.
Permutations are just jumbled orders of all of the things that you have in a collection.
So A.C.T. is in fact one of the permutations of if you jumble this up, you can also get C or you can get C at CAD or CTA or to C or T, A.
Those are the six possible ways to jumble up these characters.
You can't remove any permanently. So like a wouldn't be a permutation you can't duplicate them so you can't just be like c c c 
That's not a permutation. I'm just lying about taking three things and reordering them.
And it turns out that this is a real kind of pain to code up iteratively, but we can do it recursively.
The idea behind recursion, the recursive approach to the permutations problem.
What I wanted to say there when I said was I was thinking, I just want to remind you, like first of all,
this is a crazy topic and it's going to require a lot of time and independent study and really like struggling.
There might be some tears in your dorm room if you're looking at all this and you're like, This is hard.
I feel like I'm in over my head. I don't know.
I was going to say, you're right. I don't know if you're right about being in it over your head, but you're right that it's hard.
And I don't want you to feel like you're the only one thinking it's hard.
I kind of want to do like, how many of your things, like recursion is kind of hard,
but I don't want to do that because I'm just worried that, like, a lot of people won't raise their hands.
And then other people will feel like, Oh, everyone else actually thinks that this is not hard.
But actually people are shy about admitting that they find things difficult.
I don't know how to make that better. Recursion is hard.
Don't feel bad if you find it difficult or feel bad, but conquer that bad feeling by working hard.
Anyway, so here's how I'm going to kick off my recursive permutations function.
I'm going to pass a string with my letters ac t, and then I'm going to use that as a wrapper to call another function that actually takes two strings.
And you'll see this paradigm coming up a lot.
I've not seen this outside of Stanford, but we like to use this paradigm of when we're doing recursion so far and rest.
The solution we've built so far like what the coin flips look like so far, and then the rest.
How many coins are there left to go or here? So far I haven't built a permutation.
I just in that group you'll have an empty string. The rest of the characters you can think of as like a bag of goodies.
These are the goodies that you have left to put in your permutation, any which way you please.
We call that string rest. What I'm going to do from this initial recursive call is just loop through all
those characters and put them into my so far string as the very first character.
Right? Like, like I have a C and T to play with.
I could have strings that start with A, and if I start a string with A, that means I have CTE left to play with.
Or I could start strings with C, which means I have eight left to play with,
or I could start my permutation with t itself, in which case I have a c next to play with.
I'm going to make three recursive calls, one for each character,
and I'm going to take that character and plug it into my string and see what happens as I move forward.
Now, these three don't all happen at once, right? Like as I'm doing my research,
the function what happens is I do one of these calls and then explore more recursion before I come back up to those calls.
So I'm really just showing you these two to provide context for what's happening as I do my recursive solution.
Those two function calls happen later. First, we go down this branch on the left and I make a recursive call.
And the sub problem embedded in this one is, well, if I put down in a and said that's going to be my first letter as I come down this branch,
what I want to do next is per mute, just see entity.
At the end of my way I can put c t or I can put t c and get two more permutations.
So I'll make those two recursive calls.
One of them will take C and add it to the string that I have so far, one of them, and then I'll be left with a T to play with one of them.
We'll take the T and add it to the string that I have so far.
Then I'm left with a C to play with. But again, those don't happen at the same time.
This recursive call is happening later. What happens first is I actually place to C on the end of the string.
Well then in this recursive call here I'd like I've built up a C, I've walked those things in place.
Those are kind of in stone. A comes first, C comes next, and then I've got a T.
Well, I'll add the T to the end of that string and I'll get act and then there's nothing left in my rest variable.
Well, that's a base case. There's nothing left to play with. That means I've built a permutation and then I return.
I return up to this call over here, and I'm like, Well, there was only one thing to play with.
I made my one recursive call. So then I return up to here and I'm like, Well, I had two things to play with.
One of them, I made a recursive call over here where I put the C in the string.
Let's now make this other recursive call where I put the T at the end of my string and then I've got a C to play with.
And that's exactly what I do. In the next recursive calls I say, Well, I've got a C to play with, so let's put that at the end of this thing.
I get ATC and then there's nothing left there. That's a base case.
So then as I return back up here, I come back up here. This finished this, did the two recursive calls.
I come back up here and I'm in a loop that did one recursive call to generate all this.
Then the for loop goes on to the C and it's like, let's now generate more recursive calls.
The C comes into the string and I've got eight to play with. What happens next is that a comes into the string and I've got t left to play with.
Well I've got C now let's take a T on the end of that. And that's another base case or appearance.
They're putting a on the end.
I could have put a t I could have done c t it's like a CT scan and then come and made my recursive call here where I put the A on the end.
That's how I get CTA and then I return, return,
return and I go all the way back up here and continue to the last iteration of the loop that was generating these recursive calls.
I tried A and C, let's now try putting T in this thing.
So I put T in that thing and I've got I can put a at the end of that.
So that's this call over here and then I just move that C up and that's going to be this or appear return return.
I could have put a C at the end of the string, I could have gone t c and then when I make my recursive call,
the only thing left to move up is that a that moves up into the string and that's how we get all of those possible permutations.
It's wild because you're feeding a string into this thing and you have to loop through the whole darn string and you have to call substring to pull.
Like if I want to pull the C out of the string here, I can just go to string sub one.
You know, these are in cand two, so I can take that string sub one and add it to this.
But then I needs to like pull it out of the string. So I need to call substring to just get the stuff before the C and I need to call substring
to get the stuff after the C and once I have that a isolated and that T isolated,
I put them together into a single string. And that's probably the hardest thing about this function.
Let's code it up. Let's see if we can do it.
And by we, I mean, you just get to judge me. Let's do per mute on cat.
Actually, do I want to do. Yeah, I'll do spring as equals.
I'll just put this up here in case I want to do something else per mute and then that's it.
Let's mute that thing. So let's do void per view.
It doesn't return anything. It's actually printing the permutations.
I should actually call this print permutations.
We try to use verb phrases that describe what our functions are actually doing, and it's going to take a string s that I want to mute.
And I'll use this as a gateway to call the function with an empty string.
And so this is what I've built so far. I've got nothing, and this is all the rest of the characters that I have to play with,
See, Or maybe let me do so much as I did first in the slides, right?
Yeah. So let's call the gateway function. This is void per mute.
It takes a string so far and a string that is the rest of the goodies that we have to play with.
And oh, I need a base case. So if. What's the.
How do you code up the base case condition at the bottom here?
Can anyone raise their hand and tell me what to write in code related to the variable that indicates that we've had a base case?
Do you want to do it? You're, like, smiling really big. Oh, your smile just disappeared when I said that.
Yeah, go for it. Yeah, as long as this is empty.
And so you can check rest stop signs equal zero or just rest equals this like that.
If there's nothing else to play with, they're just the empty string. I'll return out of this function and otherwise I'll print this to the screen.
So far like that. Well, otherwise what I need to do is loop through rest and take character by character and put that on the end up.
So far, let me loop through all the characters in rest.
I zero is less than rest length I plus plus I'm going to put the I character when I commute per perp to per mute.
I'm going to put the IV character on the end of my string. So far, so do rests of I.
And then this is the big Peter factor. A Peter stands for painting the But the big Peter factor here is that you have to split the string up.
You have to every everything that comes before index I in the string plus everything that comes after index I in the string.
And this is just substring nonsense. This is just do you have the tenacity to play with the numbers and figure out what goes where?
Well, with substring. So I'm going to do rest.
That's lobster to get the stuff before index I I'll just say I want to start at index zero and get I characters.
Like if I'm taking the thing at index three then I want there are three characters before that.
The things that index indices zero one and two. So to say however many characters there are there,
take that and then to get the rest of the rest subsector substitute actually allows you to call it in multiple ways.
What is to say, what index to start out and how many characters to get.
And then another way to call it is to just give it a single argument and that says go to this index.
So if I'm taking character I out of the string substrate, I plus one says Go to index.
I want to just give me the substring that starts there and naturally goes all the way to the end of the string.
So if you want to take character three, pass lobster the number four, it'll go to index four and give you everything there and after.
And what does that called? When a function can take two parameters or one parameter, but it's the same function name yet function overloading.
Very good. So if we give this a compile and run.
It says that it expected a semicolon instead of a colon.
Well, it's just really picky all the time. Oh, my God, it works.
I wasn't sure if it was going to work. You never know. I'm getting older and claiming that I.
Oh. You are my favorite.
I'll see you Wednesday. Don't forget you have a quiz. Do Wednesday. Yes.
That. Working out.
And honestly stuck with.
Yes. And you can see you.
Can we take your time?
Tax cuts. It's just to keep it for the poor.
So it would be like an additional kind of display that you could get.
And it's like you don't have to check that one maybe first.
But. But also say the Oh, yeah.
No, no, no. Yeah. You don't want to be third step.
You want to leave. Yeah.
And. You?
Definitely. I just can't imagine.
I know what it's like once you get this.
But you. It's just.
And I'm just.
And I thought I had a very hard.
Yeah. Yeah. Was.
Thanks for coming on.
I mean. Like in.
I. Have.
I'd be happy to do. But one thing.
Yeah, And I knew. What if I'm wrong, people?
After. And.
It's great. Sounds.
Questions are coming. An additional indicator of whether there is.
This is a. But you don't know more about.
Right? Yeah. Know.
It was actually fine to be in the Coliseum, but like.
But what they were looking. Think.
Testing, testing, testing.
Testing, testing, Testing uses.
His body hasn't been. That's.
But the problem is they discovered.
But nobody ever found out What? If there's one guy.
But then. You know, like, I don't want to.
It's like it's all right. All right, all right. Happy Wednesday, everyone.
Let's go ahead and dig in. I just want to mention really quickly, Assignment three, of course,
is unlocked and it's one that people usually find to take more time than the first few assignments.
So be sure that you've started that one or are starting that one as soon as possible.
The other thing is Layer does get very, very busy on Sunday night, Monday night when assignments are getting to begin for the deadlines.
So be sure if you want to have like just luxurious, easy access and.
Luxurious. A luxurious experience just going into later and getting help pretty much immediately that
you're starting that assignment as soon as possible and going to get help as soon as possible.
You also have another quiz series unlocking later today. That one's not appearing yet in canvas because I need to edit it because I've
changed some things about what I'm talking about today compared to last quarter.
And then I mentioned last time there are just lots of extra section problems when you go to the section page on the course website.
There's like a little star under the section list and you can get more problems there.
I want to introduce a new slightly new topic today. We're using recursion for this one.
I want to talk about fractals.
And if you've looked at assignment three, you've seen there is actually a practical problem that you need to solve in assignment three.
So let's dig in and talk about what fractals are.
And then I want to do a little bit more stuff related to like the permutations and coin flip problems that we've already seen.
So quite a lot of material to get through today.
So fractals are just recurring graphical patterns where you have a smaller instance of some pattern embedded inside that pattern itself.
And we sometimes use the term that these are self similar and this next thing that's going to pop up was actually making me dizzy last night.
I don't know, actually doesn't feel so bad. Maybe it was just sleep deprived last night.
These lights took about hours of work yesterday to put together.
And it's so silly because like, we'll just click through them in a few minutes and it may not feel like that,
but it was literally hours of work to create these. And I already had like most of the material that I wanted to put in there.
It's just really crazy to deal with some of these interface stuff.
But what we have here is this pattern where as you zoom in, you see that what looks like when you're zoomed out to be an individual line segment.
As we zoom in on it, that individual mind segment also has this broader pattern that we saw when we were zoomed out.
So that's what I mean by self similar is you have this broader pattern, but then when you move in closer,
you see that what you see up close is similar to what you saw in that thing when you were zoomed out.
These are self similar patterns. These are fractal.
As we zoom in, we kind of see this pattern repeated, repeated, and fractals occur in all kinds of places in nature.
So when you zoom out of an overhead view of a bunch of winding rivers and streams,
the streams that come that flow from a river bend with similar patterns to the rivers themselves,
as you zoom out, you see these kind of layers and layers.
Of course, if you had like a little stream in this image that you zoomed into, when you zoom into that,
it starts to look proportional to what we see right now would look more like a large river as it blows up.
And maybe it has little tributaries and things flowing, flowing around it and whatnot.
And so those the formation of of water, of rivers and streams like this actually follows some patterns.
And there are actually some formulas that govern things like the width of the river compared to like how the curves develop and things like that.
That tends to occur in most rivers. If you look at those across the globe itself, similar patterns also occur in succulents.
There's one place where we see those a lot is this idea of like you have this
kind of spiral pattern and in the very center it's kind of the small thing.
But like you have that broader pattern, bigger and bigger and bigger as you go into these external layers.
Or here you have this kind of tiny spiral pattern. And if you if you zoomed out on this, you would see a very similar pattern,
kind of a over branching in from a high level view embedded in these in the succulents on the right there, that kind of spiral.
So we have more of this kind of just like circular radial thing on the left versus the spiral thing on the right.
Another place where this comes up is in the Romanesque go brockley, which is a super, super cool.
Like I don't know if you've seen these before,
but this head of broccoli has this kind of like pointy I don't even know what you'd call it, Obviously these cones growing off them.
But if you zoomed in on these individual cones, what would you what you would see is more cones in here.
The resolution kind of goes belly up. But each of these little cones has little bumps on it as well that are like these little cones forming,
forming this spiraling pattern within that cone itself.
So there's that kind of self similar recurring recursive idea of this pattern emerging within the broader pattern.
So that's what that's what fractals are all about. What I want to do today is write some code where we actually make a fractal appear using
some graphics packages and and draw a particular fractal proposal to show up in snowflakes.
As you zoom in on the structure of snowflakes and ice and what not in the real world.
And what I want to talk about today actually is the code snowflake,
which is a recursively defined it's a mathematical formula for creating a snowflake.
So this snowflakes that we're going to talk about today have multiple levels of complexity.
This is the most basic snowflake we call the level zero code snowflake.
It doesn't even look like a snowflake. It just looks like an equilateral triangle. Not super exciting.
But as you add levels to this, it starts to look more and more Snowflake s So a level one.
Coach Snowflake takes this pattern and builds on it and does that.
That's a level one snowflake and then a level two snowflake.
If you watch this transition here, you get more spikes out of that for the level two snowflake.
And then this is a level three Coach Snowflake and this is a level four.
And let me talk about it a little bit like that might have been a little bit hard to see that difference there.
And then level five, I'll talk with this a couple of times so you can kind of you might not even be able to based on where you're sitting,
you might not even be able to see there are little additional spikes emerging there in the level five at this point.
But I want to talk then about how to create this.
And the idea is that if you zoomed in on any one of these individual line segments, I mean,
this is actually the pattern that we were seeing in this very first slide up here, except I had kind of a zig zag sort of pattern going on with it.
But if you zoomed in on those, you could continue to add layers and layers,
levels of levels of complexity as you go deeper and deeper into that fractal.
But what we'll focus on today is coding up a version of this where we set the level
ahead of time and then we get this pattern just depending on what level with that.
Now, in terms of what's happening here, as you go from a level zero coach snowflake to level one and then from a level one to a level two,
what you might notice is that every single line segment is like, go to the next level,
just gets a new little spike coming out, like this line segment here. We'll get a new little spike coming out of it.
And this one here got a new little spike coming out. And this one here got a new little spike coming out.
So each spike just spike each line segments spike of highs.
And then that creates more line segments. Like now I have instead of just this one line segment here, I have four lines segments in that area.
And if I go one level deeper, each of those line segments is going to get its own little spike coming out of it.
And so we're just spiky, spiky, spiky. Each of those individual line segments is how this kind of comes into existence.
So I want to take a look at how that kind of line segments spike application happens.
And this is actually going to form the basis for how we draw these snowflakes when we get into
the code here and also like how we develop the recursive idea for drawing these snowflakes.
If I start with a line segment like this and I want to spike ify it according to the snowflake formula and what I was doing on that previous slide,
what we do is given this line segment, we find the points one third and two thirds of the way through the line segment.
So I've got these here, the red, the red dots. So that first start is one third of the way through the line segment.
The next start is two thirds of the way through the line segment.
And from there I look at what dart above this line I could use to form an equal lateral triangle.
So if I put a dot right there, those three red dots that I have on the screen form an equilateral triangle,
and I actually have the code pre-written to take two points come up with the third point that would make me an equilateral triangle,
and then we'll play with the recursion from there. But just given this line,
this is the first step that we need to work with as we're trying to draw one of these snowflakes in code is I'll give you two end points.
And instead of just drawing a straight line, if we want to recursively spike this thing out, we have to find the point.
One third and two thirds of the way through the line find the point that creates an equal lateral triangle with those things.
And then from there, take this line segment. Instead of putting that there, we would just put the line segments here and here like that.
And so that's how we get a spike.
And if you wanted to go a level deeper, I mean, if we hit a base case, we would just stop here and put this thing to the screen, right to the screen.
But if this weren't the base case, what we'd actually do is recur within each of these lines and spike each of those lines.
So here what I'm doing is at each of those four individual lines segments that I have on the screen,
I'm again finding the points one third and two thirds of the way from one end point to the next.
And then I'll find the point that makes an equilateral triangle with each of those pairs of red dots.
So there are four extra points right there to make those equilateral triangles.
And then I'll just get rid of the line segment between the one third and two thirds
dots and spike it up there like that to make those triangles come out there.
And again, if this were my base case, I would stop there and be finished.
Otherwise, I would further split up each of those individual lines.
So the main takeaway there is given a line segment, how do I complexity by that and make it more snowflake.
You find the one third and two thirds of the way through equilateral triangle.
Get rid of this line, put the lines going up there.
Now I'm showing you what would happen if we were doing like all of these recursive calls in parallel.
Each of these four line segments right here will actually get its own recursive call to complex ify and add a spike to it.
I'm showing you just kind of like the whole thing happening at once.
But what I want to do next then is kind of show you what's the order in which I would make recursive calls to have this pattern emerge and also like,
how are we even going to do this? This is another thing that I want to show you because what I don't want to deal with
when I'm drawing to a screen is that I start by drawing a line for lines like this.
And then in order to add these lines, I have to like, draw like a white line over here.
To cover that up. Like, that would just be a lot of extra work.
And so I'm going to show you kind of how to make just the lines that we want to draw and not have a bunch of extra stuff.
And then here you see a complex applying even further.
That is another iteration of just all of these things, all of these line segments being split up,
getting a little peak, and then complexity going from there.
Now this doesn't form a whole snowflake. I'm just showing you one. Fine segment of our snowflakes.
And I'll actually and then here's just another level of that all being developed there.
I actually don't I don't know a lot of I don't have a lot of like animation or automated graphics manipulation knowledge.
So I actually went through and manually constructed all of these images and placed those red dots individually.
I don't know whether I should be proud of that or ashamed, but I put a lot of time into this for you.
Anyway, so from there, as I mentioned here, this this gives us the pattern,
but it doesn't show the order in which recursive calls would would take place.
So I want to show you the recursive solution to drawing these up in kind of a weird way.
What I usually do is recursion is start with a big idea, and I say, Where is the sub problem within this?
And we decompose into a sub problem. Like if I want a raw or if I wanted to flip five coins.
A sub problem of that is flip four coins and sub problem that is flip three coins and you start at the top and work my way down.
I actually want to show you how my function is going to work, just starting with the base case,
and then I'll start one level up from that and show how the recursion works.
Then I'll start one level up from that and show how the recursion works,
because I think that this might actually just make this one a little bit easier to follow.
So initially, if I call my function, what I'm going to give my function is to end points where I want to draw a line.
And I'm actually just going to focus right now on drawing a single side of my snowflake.
So I'll give my function to end points. And I have this line up here to represent where those two end points are in the space between them.
And I'll posit that the integer level, like what level of snowflake we're making right now and level zero Snowflake,
that's the one that forms an equilateral triangle that we that I showed you on the very first or second or third slide.
If you hit level zero, that's actually the base case.
And what I would do when I hit my base case is given those two points as inputs, I would just draw that line and say I have nothing else to do.
So here level is equal to zero. This is indeed my base case.
I would draw that line and quit and you might say, Well, well, that doesn't look like a snowflake, what's going on here?
But remember I said that I'm focusing on just drawing a single line segment of the snowflake.
So this shows what happens. Oh, let me go to full screen mode over here.
This shows what happens when we create one side of a snowflake.
What I'll do to create an actual snowflake on the screen is always run this function three times.
So I'll create this kind of upper part of the snowflake.
Then I'll run the function again to create this side of the snowflake that'll run the function a third time to create this side of the snowflake.
I'm creating a level zero snowflake by basically creating three levels, zero sides to the snowflake.
And no matter what level of snowflake I want, like even if I want a level five snowflake, I'm going to do this.
I'm going to create a level five bar here, then a level five bar here, then a level five bar here.
I'm going to three times and conjoin those to get a whole kind of radial pattern going on.
So that's my level zero, snowflake. It doesn't look very snowflake. It's not magnificent.
Let's go on to a level one snowflake and see how the level one snowflake emerges, what that looks like.
So again, what I'm going to do is always start by passing my function to end points and saying,
this is where I want this particular portion of the snowflake to be.
This is the starting point and this is the end point. But if I call this instead of with the integer level being equal to zero,
if I set the level equal to one and say, Hey, I want to level one snowflake here, this is not a base case.
Remember, my base case is level zero. So level is not equal to zero, which means I need to subdivide this line and then make my recursive calls.
So this is where we go back to that process that I indicated for subject for subdividing the line.
How far through the line did I say I was going to draw those dots? They were going to be one third and two thirds of the way through.
So given two points, I'll check if this is a base case, this level equal to zero.
No. So I've got my two end points for this line. What I'll do is I will compute those points that are one third and two thirds of the way through.
And then I have a function that finds that third point to create an equal lateral triangle.
And I'll get that point now when I get to this function called level equals one,
I will not draw the line that you see on the screen because as I mentioned earlier,
what I don't want to do is draw this line and then I'm like, Oh, well, now I need to erase this segment of the line.
I'm just going to calculate where these points are and let my recursive calls print the appropriate line segments when I hit base cases.
So this line that I have on the screen, I'm not going to draw it just yet.
It's only there for your frame of reference to understand where the start and end points were that I passed to this function.
Now I've computed this points.
My level is one which is not the base case, so I need to make recursive calls and I'm going to make four recursive calls,
one for each of these line segments that just appeared here.
So from this initial call, I just had to end points.
I've now calculated three other points in between, and that creates for me four lines.
Each of those lines corresponds to a recursive call. Here's the first recursive call me.
I'll go over to this piece that I just highlighted in Pink over here. So the original starting point.
In my first function call to whatever this first read point was, I'll make a recursive call over there,
and when I make my recursive call, initially when I put this up on the screen level was equal to zero.
As I go into one of those line segments, I will work towards my base case.
So I think I just said that level was equal to zero. I meant when I initially called this level was equal to one.
When I make this recursive call, if I want to work from level equals one down toward my base case,
what do you suppose the level should become as I make this recursive call? Yeah.
Zero. I'll just decrement one from it and work towards zero.
So when I make this call, say, well, level is one less than the call that I'm coming from, the level is zero.
I'll say, Oh, that's a base case. And the base case means go ahead and draw that line segment.
So I'll draw that first line segment and then that's a basically so I return back up to this call where I was looking at these two broader endpoints,
and then I'll go to the next.
The next recursive call is going to be this one that goes from that first red point to the tippy top of the equilateral triangle.
And I'll make a recursive call there with those two endpoints and I'll pass that level equals zero because from up here level was equal to one.
When I make my recursive calls, I'll always decrement by one. So levels equal to zero.
I will print this line out because that's a base case and then I'll return and then I'll do that for this line segment here.
That's a third recursive call. Then I'll do that for this line segment here.
That's a fourth recursive call. And then I just return and I'm finished with with that function call.
So this first function call just got two end points and it made four function calls after that.
And each of those four function calls drew a line segment.
And then as I mentioned on the previous slide, once I've done this for whatever level of Snowflake click,
this is now a level one snowflake side, I'm going to do this.
Then I'll call that function a second time.
And the third time the second time I'll call it in such a way that I have this as my starting point and this is my ending point.
So add that part of the snowflake, then I'll call that again and I'll use this starting point and that ending point,
and that will give me this piece of the snowflake over here. So three calls that are non recursive are just three calls to the initial function.
Each of those will do a recursive process, but those three calls are just going to be like baked into me to create my snowflake.
So this is now a level one snowflake. It's a little bit more snowflake than the level zero triangle that didn't look super snowflake.
Let's look at another example here. This is the last one I'll trace through before we start putting it up.
So I want to create now for you a level two snowflake, and I'll use the same process, the same pattern here to start out,
I'll make my first call to the snowflake drawing function, and I'll pass it my end points and I'll say, Hey, levels equal to two.
Since this is not a base case, since levels not equal to zero. What I need to do is split this up into four line segments.
So I'll I'll, I'll find those points to split this up into four line segments and I'll make a recursive call to each of those for line segments.
What will be the integer value of level when I make the recursive calls to each of these four line segments?
If level was two here, what's the level that I should pass down as I make my recursive calls to those everyone?
Yeah. One, I'm just going to decrement by one. So what I'll do then is I'll make a recursive call over here to this line segment.
Let me zoom in a bit so you can see this. And here I'll say, well, levels equal to one.
Well, what I need to do that if levels equal to one, is continue, because this is not a base case.
Level is equal to zero. So what I'll do here, level is equal to zero is the base case.
So this is just level equal to one. So since this is not the base case,
I need to further subdivide this and kind of do the process that we saw on the
previous slide where you have a level one like this and you go deeper into it.
I'll create those four segments over there. Then I'll make my recursive calls.
I'll make a recursive call to this segment. Now, here level was equal to one and now one.
So I had my initial call level was two. Now I'm in the pink call on the screen where level is equal to one.
Now I'm going to make another call here to this line segment. What should level be equal to you in this line segment, everyone?
Yeah, I've worked my way down to zero. Well, that's just a base case. So here I will actually draw that line to the screen.
All the other lines are just theoretical lines that I've put up there so you can see what's happening in the problem.
This green highlighted one is the first one we're actually going to print to the screen and then I'll hit a base case.
So I'll return back up and then I'll make a second recursive call from within the pink call.
I'm making a second recursive call. This is the green call. Are you all following what I'm saying?
As I do? As I said, pink call. Green call is what's going on there?
Man down. Okay, you're above it. Welcome back to the days.
Everyone wanted everyone to take a second to shake it out a little bit, get the blood flowing.
I know it's a tough topic. It's a bit rainy outside. It's a bit warm in here today.
Okay. Welcome back, everyone. I don't know if I clarified last time I do that because I care.
Because I want you to pass the exam, get a perfect score on the assignments, and you're missing out on the knowledge of your OC.
So make that this call here. And then I return back up here and I make another call to that line segment.
Draw it base case level zero. Then I come back up here and I make that fourth call to this line segment here.
I'll draw that. That's a base case. So my original call caused me to create four lines, four separate recursive calls.
The first of those four separate recursive calls was this pink one,
and it made its own four separate recursive calls to draw the green highlighted pieces.
And then and then I back out from there, and then I'm finished with that.
I finished with those four green calls they return and then the pin calls like I did all my four recursive calls.
So it returns. And then I go on to this next one segment and do the same thing.
Remember, initially, high level overview here, level was equal to two in the pink line, segment level is equal to one.
Very good. And then so if level is equal to one, that's not a base case I've got to subdivide.
So I'll find those points and then I'll make these for recursive calls.
That one, there is a base case draw base case draw base case draw, base case draw.
So this pink call made its own for recursive calls.
And then as I back out of that, I've drawn those four lines there.
I come back up to my original call, which was in the process of doing four calls.
It did two of them already. Now it goes on to the third one. We're level as one.
Are you following the idea here? Now? It's going to recursively subdivide.
It has all these level zero segments, recursive call, recursive call, recursive call like this.
So that one returns over there.
And then from there, I do this final this fourth call got my final call, but my final recursive call from the main one,
this makes its own for recursive calls like this, this one, this one, this one and this one.
And then once I'm finished with that, I've got this segment of the snowflake.
And so that's the order in which the segments will draw is you don't just draw one line and then all three,
a bunch of peaks appear at the same time and then a bunch of new peaks.
If you think about the order in which the green box is appeared, that's the order in which we draw.
So the order in which this would draw would be this segment first, then this, then this, then this, then this, then it just goes around.
And so if someone were watching that draw and they didn't know what was happening behind the scenes,
they would think maybe it's just a simple for loop that's going from left to right.
But the simple for loop to do that is actually perhaps more obnoxious than
the recursive approach to kind of figure out how far into the snowflake am I?
Do I need to go up now? Down now over what coordinate I make out here?
The recursive solution to this is actually it's not trivial,
but it's perhaps a little bit more friendly than computing each of these points independently and trying to figure out the the action there.
Now, that was a level two snowflake side. And remember, as I keep saying here, I'm going to do it three times to build a for real snow.
Well, it's not a real snowflake, so it's something that looks snowflake.
So I'll do that first call, then I'll do a second call from here to here and get that.
Segment and then a third call from here to here to get that segment.
And there's my level two snowflake. It's actually starting to look like a snowflake is what's going on there.
Now, in the course notes for you today,
I have actually created this image here that shows the whole recursive subdivision process for an even deeper level snowflake.
It'll just keep going deeper and deeper and deeper and deeper and deeper and deeper and do it'll create the whole darn snowflake.
I also put this one together manually, and then I created each frame individually and then animated them together with the new image.
And. Oh, thank you. Confirm. I'm not I'm not doing that for applause.
It's just so you know that part of this. I want you to know that I'm working hard behind the scenes.
And then also, you know, maybe it's just like a warning about this life lesson built in there somewhere.
I don't know what it is because clearly I'm still stuck in the loop. Oh, let's code this up.
So I've got here for you. You know, I try not to do this.
I don't like to just bring in code that's pre-written. But the graphics library stuff, I mean,
we're giving this to you in assignment three that there's graphical library stuff that you're going to use to create your saw.
PINSKY Snowflake. And there's just infrastructure surrounding it that would be obnoxious to try to get through in class.
There's just some stuff here that's like, let's find the width and height of the screen and find an appropriate place to start the snowflake.
Then there's some trig to find the third equilateral point. And you can I'll post this for you.
Of course, in your lecture notes, you can play with it, dig into it as much or as little as you want.
The main thing is to understand the recursive processes happening, and then this is just like icing on the cake for you to play with as we go.
So I do have the and this collateral point function.
I am going to have to find a point between two points.
It's like a fraction, right? I said a third of the way and two thirds of the way through between two points.
So I've got a function for that. This is going to be my draw snowflake function.
It wants to know. It wants to know what the level is and the starting at end point for your snowflake.
And then I just have an example called Down here where I'm like, Let's create a level five snowflake.
Starting at some point that I've computed with this formula as defined above.
So first of all, let's just knock this out, finding the point between two points.
So we've got this G point thing here and this G point thing.
If you put it after one of this points, you see it's just the point with X and Y coordinates.
It's nothing crazy or intimidating. It's just a thing that's built into the graphical libraries that you have access to.
Like this G window library in the G types library.
Oh, and then this G window. This is the graphical window where I'm actually going to draw stuff that has a bunch of functions
built into it for drawing lines and filling with different colors and things like that.
So to find a thing that's a fraction of the way between two points.
Well, if I have and point two and I want to know like, what's the x coordinate?
That's like a third of the way between them, what I would do is add whatever.
A third of the difference is between point two and point.
Once x values, I just subtract their x values, then take a third of that and add it to point one x value.
That should get me a third of the way there x wise and then I'll do the same y ys.
So I'll say to that. So I'll just do double x equals.
The x coordinate that I want is going to be px plus I'll do.
Then the difference between their x coordinates like that and then just multiply that by my fraction.
So if my fraction that I pass into this is one third, I'm saying look at the difference between the x coordinates.
Take a third of that and add it to the starting x coordinate and then do the same thing
for Y to find the the piece that's a fraction of the way through the Y coordinate.
I'll just change these two Y's over here and then I'll return a new G point.
And there's a g point function here that you can just feed at the X and the Y values that you want to create your new point.
So all I've done there is looked at the X and Y coordinates a few points and figured
out the piece that was a fraction of the way along from those taking the difference,
adding to the original. Everyone okay with that? It's and I don't know if that's really crazy or is everyone is even following that.
Is that something you feel like you could do? Is finding the fraction between the two points?
Okay, so the main event happens here in the snowflake function, and I'll just call that function above from the snowflake function.
Ooh. What's one of the first things that we do when we write a recursive function? Everyone, a base case array.
What's our base case. Shout it out if you remember. Yeah.
Level's equal to zero. And aside from returning and not making recursive calls, what was the main thing I needed to do when I hit a base case?
You actually draw the line segment. And so in this G window object, we have actually a draw line function.
Amazing. And it's hard to see here, but it says, just give me a starting point and then into point and I'll print that for you.
So I'm going to give it a starting point and another point, and it's going to draw that thing for me.
I'm amazing. Otherwise I needed to make four recursive calls to draw snow.
Wait, so I need to pass it my window recursively.
What did I say? I was going to make the level when I made a recursive call.
The level to each of those four recursive calls is going to be level minus one.
And then I need a starting point and an ending point for each of these recursive calls.
Okay. So I needed to find the points that were like partway from the beginning to the end.
So. So check this out. I needed to have Do I have that diagram?
It's just bad memories. So yeah, like a given a line segment.
I wanted to find a point that was, first of all, one third of the way through.
That's that first red dot there. So let me do that G point.
I'll just call that point A is equal to the point between my start and my end, and I want to pass as a fraction.
I want to find a point that is one third of the way between those two points.
And then this next point over here, I'll just call it point B.
That's the point. That was two thirds from the starting point to the end point.
I'll call that one B like this. And then I wanted to get after that the tip of this triangle.
I'll just call that g point tip equals and have a handy function up here that does trig and
I give it my bottom left and bottom right points and it just finds me that equal lateral,
that point that would give me the equal lateral. Hoo hoo hoo. And so that's from A to B that I want that thing over there.
And so I have my starting point, my point a my tip, my point B and my end point.
I want to draw those four line segments from start to, hey, that's that first line segment over here, start to A and then from A to the tip.
So this is from A to the tip of the equilateral triangle, then from the tip to what I'm calling point B.
So that's going to be from the tip to the what I call point B,
and then from point B to the end of this line from point B to the end point for that line.
That's all there is to it. To creating. It's like. Three lines of code.
You know how coders like to exaggerate about how quickly or how few lines of code they use to do it.
There's actually there's a bug here, and it's not something that I would expect you to know, but it's it's kind of obnoxious online.
I is and Did anyone catch what that bug is?
And I don't think that I've talked about it explicitly in class before.
Yeah, go for it. Yeah it, it doesn't, it doesn't it.
And so when I do this in C++, if I do one divided by three C++ looks at those, it's like, Oh, you're doing integer division.
And when we do integer division, you know, in the real world, one divided by three is three.
Right. What do we get? What is the as an integer, though?
Zero. So C++ will actually truncate this to zero.
And then when it passes it to this function, this function will be like, No, I wanted that to be a double and C++ will be okay,
but we'll say like OC instead of because it's got it, got it to zero first and then it passed it and it got .
If you divide an integer by an integer in C++, you get an integer in order to get a double here,
because otherwise I'm just passing zeros and it's just going to give me a bunch of zeros and not go through the line.
One of these or both of these has to be a double. So check this out.
If you do integer divided by integer in C++, that gives you an integer.
If you do a double divided by an integer, that gives you a double.
If you do an integer divided by a double, that gives you a double.
If you do a double divided by a double, you get a double.
It's only when you have integer divided by integer that you're getting that integer only.
So I could just do this. I only need one of these to be a double and I'm guaranteed to get a double as my result.
So this is actually totally fine. So the idea here is if you just have integers, your result is going to be an integer,
and this works for every operator plus minus times divide with integers.
But as soon as you throw a double into the mix, we're going to get a double as our result.
Is this looking to anyone like a concept that you might have seen in biology before?
Where if I have to integers they give me an integer results, but integer double gives me double.
Double an integer gives me a double double and double gives me a double. What?
What concept? Anyone want to raise their hand? Does anyone see it? What concept does that mirror?
Actually from biology. Yeah. Go for it. Yeah, we're using it these as dominant and recessive genes.
So this is like the integers, the recessive gene. If two integers mate, they produce an integer offspring, but the double is a dominant gene.
If a double meets with an integer or if two doubles mates, then we get the double the Yeah,
you get that you're giving yourself the gold star like that's a you're amazing I agree.
Yeah. Like, oh so that's what's going on here and that's the mnemonic that I use to remember those over there.
Um, I don't know. Let's see if it runs. Oh, my goodness.
Did you see it also? How like did you see the order in which it did those?
It was exactly the order that I said it would do as it goes from left to right over there.
That's super amazing. Oh, thank you.
Looks like. I'm glad you're excited about your education.
Let's do this. Let's let's put this up really quickly. Let's do I want to be able to show you different levels.
So I'll just do while true inch level equals and I'll do get integer like this.
That comes from the bio library. Symbiosis is one of the Stanford C++ libraries.
I'll get an integer and then I'll just do like this.
I'll say like, if the level is less than zero, that's not a valid integer, so I'll just break out of this loop.
Otherwise I'll draw a snowflake of that particular level.
And actually, before I draw the snowflake, I just happen to know that there's a clear function built into this window.
I can redo that thing there. Okay, so let's draw level one snowflake.
Oh, and then a level two snowflake. A level three, a level four, A level five level.
Okay, we won't worry about that one. It's not going to finish any time today.
No, I mean, it will actually. It is finished already. In fact, a level zero snowflake level, negative one Snowflake.
Let's draw the whole snowflake. So this is just doing one segment.
What I want to do is draw that segment and then do the second and the third segments.
And actually I can capitalize on my my equilateral triangle function.
This one up here that gets that point.
The third equilateral point, just from my starting point and ending points, I can actually use those to find the third point and do the whole thing.
So here's here's what my thought is. Let me get this new point. I'll call this the tip.
This is it once again. So this is the tippy top of the equilateral triangle equals what's the name of the function?
Third equal lateral point. So third, equal lateral point between bottom left and bottom right.
And here's what I know about this function.
If I give it bottom left and bottom right, it's going to give me the point that is above and between those.
So I want to draw if I have this point, this point in the one above,
I want to draw a snowflake from like that tip to B and then from B over here and from over here, back up to that thing.
So let me do those three recursive calls over here. I'll start at the tip and then go down to the bottom.
Right. So the tip to the bottom, right. And then I'll go from the bottom right to the bottom left.
So let's do from the bottom right to the bottom left.
And then from the bottom left, I need to go back up to the tip of this thing.
And will this work? I don't know. Let's find out. A level A level zero snowflake.
Amazing. It's this that triangle that we were. And then level two and level three.
Oh, my gosh. Level four, level five. And so this is the coach, Snowflake.
It's super. It's super. Okay, So that is what it is.
Thanks for. I know you're very excited to hear about that.
I don't know. That's magnificent. We probably have a round of applause for the snowflake itself.
It's so cool. And. I don't know.
I don't have anything else to say about that. Let's move on to another problem.
I feel like it's so anticlimactic to have worked through and triumphantly gotten this whole thing and then just move on from it.
But I just think it's really beautiful that you have the support.
If you have the support functions,
it's really just a few lines of codes to do that whole thing and a few lines of codes down here to get the whole snowflake working.
And of course I'll post both versions of this in your notes today so that you can
see the one that draws just the segment and the one that draws the whole thing.
Let's talk then. I just want to do another two kind of quick problems that kind of build on other problems that we've seen.
So we've seen already the coin flip problem. So the coin flip problem is a question of sequences.
It was what are all the different sequences in which we could get heads and tails.
If we flipped a coin three times or any number of times.
So we saw we've actually seen in two separate classes. Now, this one keeps coming up.
It's a really common pattern to play with an adapt from the from the coin flips from this approach.
So one of the things we saw with this approach is you have two options. You can flip a head or tails.
We make two recursive calls, one that adds a hedge to the string, one at the tail to the string.
Well, what I want to talk about then is how we can build on this to do a very similar problem, which is what if we rolled a six sided die?
So a little guy that has one, two, three, four, five, six, six faces.
What if we ruled that some number of times? How many different results could we get?
Well, if we want to kind of coopt this idea here, I mean, we a coin flip is actually kind of like rolling a two sided die.
And now I'm just kind of elevating that, saying, what if we had a six sided die?
Can anyone see what modification we might make to this function if instead of heads and tails, we wanted to flip a roll of six sided die?
Does anyone have any thoughts on what would need to change? I have this function that does the two recursive calls go for it and read.
Yeah, I would do six recursive calls and instead of just adding heads and tails to my string,
I would add one, two, three, four, five, six to my string. And so the way the function would proceed then if I were rolling, say,
suppose I wanted to know how many outcomes are there, What are all the outcomes for rolling for die for dice?
Well, from my initial call I would say, well, I could roll initially a one, two, three,
four or five or six, and then from each of those I would make six more recursive calls.
So like if I rolled a three, I could then after the three roll, have one or two or three or four or five or six.
And then from each of these recursive calls down here, you can think of these almost as like parallel universes, right?
Like you initially, you roll your die and you split into six parallel universes, one where you get a one.
Would we get a two, three, four, five, six? And then from here, each of these could have six.
And like I was looking at this, I was like,
This is just too tedious to go in here and draw like six more things coming off the bottom of each of these dots.
But I did it anyway. There's six more of those coming from there.
And then like, so that's one, two, three levels deep and like, I'm having to twist those to get them to work.
And so here I actually did not for the fourth one, I did not go in deeper to draw six more recursive calls off of each of those dots.
That actually was too much.
So what I did instead was I copied and pasted six versions of that right there and then reunited them under a larger dot above.
And this actually has a diagram of all the and it's I think this is really neat, actually,
when when you take a moment to reflect on it like recursion is tricky and crazy when you first see it.
Sure. But we're writing a short function here that can generate all of those little dots along the bottom of this diagram.
It's this explosive thing that's really just a few lines of code.
And let's take a look at what those few lines of code look like. Let me do that.
It's going to be very, very similar to what we already saw with the let me do this.
I'm going to do void role DI don't know if you've heard that term before.
Dlike Dungeons and Dragons had a big moment.
Like when the pandemic hit, a lot of people got into Dungeons and Dragons and are now familiar with like Dand D 
A Dis just a six sided die. That's the shorthand notation for it.
DAnd how many times do I want to roll that? So let me do down here.
I'm going to just do roll Dsix and I'll say Roll it four times.
And this would print out and all of those sequences all the way down to six, six, six, six.
And so from here. One of the things that I want to do is add to the end of a string.
What my role is. So let me kick off. I'll just use this as a wrapper function where I pass it an initially empty
string and N and it'll just go through and add to this I'll do void role D six.
This took my string s and my integer N Oh, I need a base case.
What would be equal to where you're like, Hey, there's nothing to do except print my result over here.
Yeah. Zero. If if there's nothing else to roll over there, then what I'll do is just see out my string.
And return. Otherwise,
what I wanted to do was this role Dand I'll take my string and add an integer to it and then I'll have one less dye that needs to be rolled.
So I'll add my integer. One, two, three, four, five, six.
First of all, what do you not like about the way that I have? Just like these six lines splayed out over here?
What could I do instead to make this maybe a little bit nicer? Yeah.
Just do a four loop that that goes through that. So I'll do four and I equals one less than or equal to six I plus plus.
And then in that four loop I'll actually just add to the integer I to my string over here.
Now one of the things that you're seeing is the plus sign is lighting up. C++ does not like the idea of taking a string and adding an integer to it.
It's like these are two fundamentally different things and Python is so great.
Write Python is just like, sure, whatever. I'll figure it out. C++ does not like us trying to add an integer to the end of the string.
So if I weren't sure, like how do I convert that into a string,
I would go poking in the standard C++ library documentation and see if there's a handy function perhaps in our string library.
SDR lived out H. Perhaps in the string library. There's a handy function having to do with integers integer to string that did it all it takes.
I just converts that to a string and then I'm going to put a space after that so that there spaces between each successive di role.
Uh. Uh oh.
No one expected a hoodie here before a birdie Berger on. Oh, who did that?
Yikes. All right.
It's pretty close to the screen, so it comes up with all of those.
Now, one of the things that you see is that's running, by the way, is it's taking a while to churn through all of those.
It's like. And that's because see out printing to the screen is an expensive operation.
And I'm doing it many, many, many, many times here. Watch this slight modification that actually makes this a lot faster.
What if instead of printing every result out as I get it, what if I just hoarded them in a vector behind the scenes?
Because printing to the screen is a slow, expensive operation.
You have to move stuff through hardware. And it's not just like stuff moving through your memory hardware.
It's like a pipeline to get to the screen and display pixels and stuff.
So let's create a vector here instead. So do here vector of strings.
Those results, I'll call this my results like that and I'll pass the results vector.
Let me just pass that in as the first parameter here, let me do up here, it's a vector of strings called results.
And then up here I'll do the vector include vector h.
Oh. And then when you make your recursive call, you have to remember to do this over here.
And so what I'm saying here is, instead of printing out, let's just do results, not add that particular string to the vector.
And then down here. I'll do SEO results now like that.
Victor. Victor. Victor.
Okay. What's bad about the way that I'm doing this right now?
There's. There's like, a key. You want to go for it? You. You're not. Yeah.
I'm not passing the vector by reference. This is creating a new vector every single time.
So in some of my recursive calls, I'm creating new vector, and those results don't get returned back up to this thing.
Let's pass that by reference. Oh, did you see on line results normal looking?
And then when I put an ampersand here, it's now italicized to tell me that is the pass by reference parameter.
And as I give this a run. It just prints them all out immediately.
It's just like, boom. There's no like as it's not like to compute the result.
It's like, boom, there they all are. It's super, super fast. So it was computing them very quickly.
It was really the printing that was taking a lot of time and slowing that thing down.
And I can verify that I have the right number of them, by the way, by just printing the size of the vector,
see out results, dot size and l if I flip or if I roll a six sided die four times.
What's the math on how many results I should be able to get?
How many unique things there are in the gray. In the gray. Yeah.
Six to the power for there's six results here. or or six here.
Multiply those together and six to the fourth power gives us one, two, nine, six.
So I'm hoping that when I run this boom, there were things in that vector.
It's doing the correct thing over there. Super amazing.
So this is very much the kind of thing that I would want you to be able to come up with on
an exam and actually probably something even a little bit more beefy than this on an exam.
So be sure that you are playing with these problems and and writing these and and practicing and closing up
all of your notes as you try to replicate some of that stuff from scratch and see what comes out of that.
The final thing that I want to talk about, the final problem that I want to mention today is the recursive permutations
problem that we saw on Monday where we talked about this so far and rest paradigm,
where I was taking things from from the yellow box here, rest and putting them into a new string variable so far and making these recursive calls.
And I mentioned on Monday that we have to really pass the string by value.
If we passed it by reference, then down here, when I got A.C.T.,
when I returned back up and tried to add like a C to the end of the string, I still have the A.C.T. there.
And so I have asked C and it's no longer permutation and things would just get really wacky and, and jumbled up there.
So I was deliberately parsing things not by reference, but by value.
The problem with that is that is a slow approach.
If you're creating a bunch of strings and you're passing strings recursively to your function by value, that is a slower approach.
This approach is one of the more straightforward ones to code up for printing permutations.
It's not necessarily easy, but it is one of the more straightforward ones.
There is another one that relies on passing your string by reference and actually modifying the string in place.
And I want to just give you a quick taste for how that would work. If you want to actually do this in place and not have the runtime hit and memory
hits for creating new strings every time you call your function recursively.
What we do and this happens a lot with recursive problems is parser string in and then pass some index that changes as we work through the string.
And we actually just did this with the snowflake where we had an integer that told
us how far into the snowflake we were and it was working its way down to zero.
What I'll do with this one is start at zero and say,
So far I've put zero things in place in my permutation and then I'll work my way up to the length of the string.
So here, if I call this function, I say, Hey, I'm at index zero.
What I would say, well is let's just pick one of those letters, C or T to freeze into position zero and then move forward recursively and look
at position one and pick one of the remaining letters from index one or later.
So I'll take an eight maybe and freeze it at position one and then move on to position two and then say,
well there's only that t there, let me freeze that into place and I've got a permutation.
But if I come back up here to this call, instead of freezing a in the position one,
I could have frozen the T into index one and then moved on to index two and
gotten CTA and similarly at the root instead of freezing C into position zero,
I could have chosen a to freeze into position zero and then moved on to index one and said, well, who are we going to freeze in the index one, C or T?
I could have tried it with C and I could have tried it with T. And similarly up here when I chose what I put in index zero,
I could have put the T at index zero and then for index one that could be a or I could have put a C there.
And so you can create actually an integer here that kind of loops through forward through that, loops through,
but kind of moves through the string as you make these recursive calls and just picks those things and swaps them into place.
But the thing that you want to do then is as you return from these recursive calls,
like when I return up to this recursive call here, I would be in a for loop that was processing these letters if I made a swap,
like if I put A here and C here, then when I return up here I'd want to put C back where it belonged and then back where it belonged.
So that when I swap stuff over here,
it's swapping the T with the C and kind of just like really quickly what that function would look like then void per mute.
If I pass this a string s, I would just use this as a wrapper.
Oh, I wanted this to be by reference at super fast. And then I would just say per se, starting at index zero,
let me create a string here s equals cat and then I will compute that string cat and get rid of this thing over here.
And so to mute what you do is we have this string and we have some some index that we're at.
And you would say like this index started at zero.
Once it hits the string length, then we know that we've actually put characters in every position in that string.
So just go ahead and print it out. Otherwise return.
Otherwise start a for loop at that position.
K that we're at. Go through the end of the string. Look at all the other letters that are there and swap into position.
K The thing that was at position I And then swap that back when you're finished.
And in between those two swaps you're swapping to make a change and then you're recursively muting
and then when you come back you undo that swap before you go onto the next iteration of the loop.
I can commute that string and move on to the next iteration here.
I just need a quick swap function that takes a string by reference.
And two indices and swaps them and says, let's hold on temporarily to the thing at index.
I now I can overwrite that with the thing at index J And now that I've overwritten that, I can put the temp over there.
And that prints out all of those things like that. Now, I know that's really I know that's really amazing, right?
I know that's moving.
You can have an A I know that's moving really quickly, but I don't want to waste a lot of time on different approaches to different problems.
The video is, of course, going to be posted in canvas. The slides are there.
The code will be in your notes if you play with that. Want to check that out.
Thank you so much for being here. I'll see you on Friday, everyone.
Everyone, Welcome back to one, two, six. Yeah. Today we're going over recursion.
It's now a good example of recursion which you might see if you just Google recursion is that if you click on this link,
recursion will bring it back to exactly where you are. Now, this isn't quite what occurs will be like recursion.
More will make the idea simpler and simpler, but maybe do some recursion improperly.
You don't have the good base cases, then maybe you'll go in an infinite recursive loop.
So we're going to try to avoid that on this assignment. But that's why the warm ups there.
And we'll help you guys through it. Now, big warning before we start this assignment, I highly, highly encourage you to start early.
Recursion is difficult. It's new. You're going to be working on Christian for the rest of the quarter.
But this assignment has a lot of parts. It isn't the easiest thing to learn.
And even if you eventually get it up, it might take a few days to do it.
And if you'd start late, you start over the weekend,
you may find yourself in a position where you aren't learning the material or you aren't able to finish the assignment type.
Assignment has a lot of parts. They're all relatively hard and they all are a very good learning experience.
But this assignment is not one to take lightly. So an overview of this assignment is first going to start with debugging.
This will give you some practice with some recursive bugs and specifically that infinite recursive loop they talked about before.
Then we're going to go over some balance counting. We're going to draw some hirschi triangles.
Do some ballot ordering and then merge sort of sequences. And these are all things that can be done recursively.
Now tips and tricks Before we even dive into the specifics of the wallop.
Recursion is all about breaking out a problem into smaller and smaller pieces, attacking them one at a time.
In order to do that, you need to have a strong understanding of what the task is and how you can break
it down into those easier portions to tackle through a similar methodology.
That means it's up to you to decide, okay, how can I make this process similar and what portions do I want to tackle?
One at a time. How small to make things and how does making it smaller actually help me?
Tips to come to those conclusions are to draw pictures and particularly draw the recursive tree.
During the course of tree will come in handy for any recursive problem you solve.
For example, when you're doing cross problems, you may wonder, Oh, how many calls do I need?
It all depends on the tree. That's possible.
So if you have a pathway and there's two paths you could take at any given point, at every single point, there's two paths you can take.
They probably know you need two recursive calls, right? You across on the left side of the path of your course, on the right side of the path.
Those are the techniques that you're going to be doing throughout this assignment as well as future assignments.
So let's dive in with some warmup and debugging or weapon debug exercises for going to first have you examine the recursive stack frames.
You're going to do this in the debugger. Next, we're going to have you recognize Stack Overflow, which is akin to infinite loops in recursion.
In recursion, if you do have it loop where you cross infinitely, you're eventually going to crash your duty creator.
So you don't look up for that. Find out what a crash looks like and then find out how to depart through a crash in order to fix the crash.
So that way when you encounter your code because you will know how to fix it last,
will have you write some test for recursive functions, and particularly the power function.
And the power function is a very good example of how recursive techniques works.
So I would highly recommend looking at the power of function more closely, even if it's not strictly mandated to write test for it.
Lastly, the warm up will have a bit on Christmas time and big analysis and this is just for you to get your bearings,
make you realize how important all your techniques are and really get into the deep,
deep depths of how small changes for the right type of function can really explode when you run something recursively.
But now into the first part of this segment, that's an actual exploitation, balanced operators.
So we're referring to operators, we're referring to bracketing operators.
And in most programing languages, bracketing operators are parentheses, square brackets or curly brackets.
Now, when you're writing code, bracket operators are used in many places.
You have the parentheses when it comes to a function, you have the curly brackets when it comes to the scope of a function.
So what isn't containing the function? And then you may have parentheses which are doing math or square brackets when you're indexing it to something.
There's a lot of different cases when you have these parentheses.
Now, when you are writing code, genie creator or other compiler will yell at you if your operators aren't balanced.
Now you can write a program that could theoretically determine whether your operators are balanced and whether you should be all that by two.
So if you take this segment of code and delimit it to just the operators,
you'll end up with an output like this where all the operators are in a light.
Now you can see, oh, the operators are correct.
The ballots or if you can't see that, you can also trace through what unbalanced our balance operators are.
So balanced operators are when you have the same number of operators and that the operators
are closed out in scope such that you don't have operators intersecting each other.
So this example shows that it's not balanced because you have an extra property that isn't there.
This one also is in balance because the closing parentheses comes before the occupancies, and last one isn't balance because they are properly nested.
And that's the harder example to really think about, is you have this curly bracket here and then you have these practices here,
but you can't get it to a point where the parentheses close before they're entangled by another pair of brackets.
So we look out for those operators and make sure you have a good understanding of what truly is on balance,
before you dive into this part of the assignment. You're going to be writing a function is balanced.
This will take in an input string. It will strip the string just to the bracket operators and return.
True or false. A boolean value of whether the string, the input was balanced or whether it's not.
Now, in order to solve that, you've got to bring some additional functions. Operators from an operators are matched.
So operators from takes in a stream that returns a stream with only the bracket or the operators for the function.
Operators are match takes in the string which you just found from operators from returns.
True or false, if it is balanced, if the string of only the brackets are balanced, you must implement both of these recursively.
And that's a mandate for this assignment. So make sure that you're doing this recursively.
We've dealt with some strings and that you did it iteratively.
The goal here is to give some recursive practice, not to test whether you can actually solve this problem through iteration.
Now some tips Robert is from is that I will process the first character of string determine it should be kept automated.
Then what you can do is you can recursively process the rest of the string with a recursive call.
So this is really when we come up to the idea of recursion, you're taking one big product and trying to find out how to split up the small parts.
You just take the first curve of the string. See if it's, let's say an operator, it's I keep it.
If it's an operator, you want to keep it. If it's not operator, you don't even care about it.
You can just ignore it and omit, omit it,
and then add the result of recursively calling the with the operators from process on the rest of the string.
So this will be very useful for this part of the implementation and how they're going to look at that.
But also note that you try two or three test cases to validate the behavior before you commit your assignment.
Next comes operators are matched now string consisting of only breaking characters established if and only if one of the following conditions are met.
So when you hear something like this, you might be thinking these cases base cases.
So this is how you know if something is true or false.
If the string is empty or the string contains just a pair of bracketing operators that are exactly the same sets the parentheses,
the square brackets for the curly brackets as a substring, and the rest of the string is balanced.
After removing that substring, that's the only case when the operator or string sorry has messed operators.
So this last one may be a bit harder. Understand? So I have an example for you.
First you might be look at this string and see.
Okay, it has this direct substring of these curly brackets.
So I'm going to remove it and continue the process for the rest of the strings. Like you look at this as the direct substring of these curly brackets.
I'm going to move it. Go on to the next. Now has the direct substring of square brackets.
Move it. Go to the next. You end up with the empty string. So you know it's an empty string.
That's one of our definitions for a balanced match of operators. So we can return that.
It is balanced. Now, if you can't find any bracket operator sub strings.
So one of these three sub strings and you didn't match the empty string.
Are they balanced? What happens up to you to find out?
Next part of the assignment is a separate ski triangle. So here's a good demonstration.
You'll run your tests, and when you do run it,
you get to a point where you have this triangle and you can move the slider at the bottom to determine the order triangle and what order means later.
Or you can move the red triangles in order to change the positions of the three points.
Now, most of this in terms of changing the positions and the graphics user interface will be input for you.
You don't have to worry about that as much. You're mostly learning about the cursor process and the math.
So one thing I know about Sir Penske is it really showcases the artistic relevance and prominence of recursion in the real world.
You can request create graphic graphic designs of fractals or a fractal that is defined as images that help solve similar parts.
And all of these fractals, at least for our cases, will be determined on a scale of order.
And that is an integer, a number order zero for the number of triangles that you're doing based off of where you started.
So the zeroth order will be just be one. So.
PINSKY Triangle black that the second or sorry, the first order surveys indexing will be three triangles and then order two, three, four, etc.
So where there is just plain filled triangle of order, one will have three security triangles of order zero.
And then it could see. Maybe order for order. End is a triangle filled with three suppressed triangles of order, and minus one.
Six is, of course, the process of order. Four has three order threes.
Those order threes have three order twos.
That order to has three order ones, etc. etc. All these triangles need corner to corner and that'll be very helpful for the math part of this.
Just note that when you draw a surprising triangle of order, end is the same as drawing three triangles of order and minus one.
And then within they're three triangles of order and minus one, minus one, etc., etc.
So you're given the draw Stransky fractal function header which returns an end.
So you want to keep track of how many triangles you recursively draw as you go along. Now, one thing to note is that the window passed by reference.
Window is the graphics window for visual wear. G point one, two and three are the coordinates x y on that window.
An order is the order number that we discussed earlier.
So while recursive, which of these inputs change as you go along, I'll give you a hint It's not the window.
You're going to be using the same way every single time. And if you kind of see that path by reference, but one, two, three, an order do change.
So you're going to have to find out what coordinates to place the new triangles and then what order to feed through those coordinates as you go along.
Now trust this. You'll also have the draw order zero function,
which is a provided function that will draw a triangle on the graphics window with the vertices at the provided points.
They only want to write this function once in your written code and then trust your recursive process to draw a triangle in the correct position.
Now that's saying, Oh, you're recursive. So in reality it'll be called more than once at execution.
But when you actually write the code, you should only be writing this once, only calling it once.
Now, since this first Lipinski is to draw pictures, I'm going to say this for every syllable.
Chris had problems at the quarter, so just be prepared for it. You're going to want to draw pictures and see how things are done.
Or in this case, I always look at the pictures we provided because it'll be very, very helpful.
Now, another thing keep in mind is you need to find coordinates. Now, a very neat tip that you may have noticed in the picture is that the midpoint of
each side of an outer triangle becomes the corner of one of its smaller triangles.
And you can actually see that from here. If this is the big triangle, this is the midpoint that became the corner for this triangle here.
And then from this one, you have this triangle. This midpoint became the corner for another.
So that's going to help you find out what caused it to feed into the G point one, two and three.
Now, line segment midpoint equation, in case you forgot, it will be x one plus xby two, y one plus y over two.
But do note that triangles are not guaranteed unilateral as is often demo.
You have those red points that you can move around, so you can't just assume, oh,
I can divide things I have for all three that will be points rotated about certain axis.
You'll have to calculate all three manually. I also highly recommend checking out the g point documentation which is linked in the.
If you want some more details on how g plate works.
And just a reminder, the only drawing functions you should you should use is r provided your order.
Zero. You shouldn't be digging for other functions or trying to think of that way to do some drawing.
It's all done for you. Next comes ballot counting.
Ballot counting takes in some preexisting conditions. So I'm just going to go over them for you real quick,
is that you're telling accounting an election between two candidates and be willing to tally for votes, whomever has more will win the election.
Your question is how many ordering is exists and then how many favorable ordering is exist.
Now, a federal ordering is is defined as an ordering of ballots for the eventual winner is always in the lead.
That means that they never tied, they never got behind. They were in the lead the entire time.
As the audience are being carried, your answer is what is the probability that A is strictly ahead?
That's your goal when you're answering this question and you can write code to find the solution.
So one thing to keep account of is all the assumptions, given that all orders are equally likely and a preset number of votes for A and B exist,
you can find the probability of any favorable ordering as the number of table ordering divided by the number of total drinks.
So what this means is you're guaranteed be assuming the ordering strictly likely and guaranteed that your preset numbers of A and B are provided.
So the probability having any favorable ordering will be one scenario of ordering or all favorable ordering so that you ended up
with a favorable ordering at all will be the number of favorable ordering is divided by the total number of orders probability.
So let's say let's look at example. We have two A's and one B as your boats for possible ordering success.
You start with A, you get another A and then you get a B. I took the lead and never lost it.
A won the race. Therefore this is favorable order. Now if you have A and then a, B and then A, A start is the lead.
Then it won the race, but it tied. So it lost the lead because it was a tie.
Therefore, this would not be considered favorable ordering. Lastly, you could start A, B, D starts with a lead, but then it loses the race.
So that's not a favorable ordering at all either.
So in this case you have one favorable ordering and three ordering, which means the probability of ordering is one out of three.
Now for any kind of technique or anything. Karmic talks recursion will be very helpful for counting.
When you think of recursion, recursion is very great for finding every possible scenario that could possibly happen.
So if you're doing something, probability or call matrix recursion will come in very handy.
So your goal here is to write two recursive functions.
Count all orders, which returns the number of all possible orders for an election with all accounts for and I think help federal orders,
which returns the number of favorable orders for an election, will count.
And then very simply, all I have to do in the test cases, you're not writing a function to actually do this.
Well, compare the two and divide the number of table orders by the number of orders to find this probability,
you may wonder, Oh, how do I know if I'm right?
So you're going to use the solution to these as well as Bertrand's theorem, which is that where A is greater than B,
note that you have to restrict A and B to be less than to not exceed the range of the data type, but that doesn't change the actual applicability.
The theorem Note that if you take a minus B over A plus B, that's the likelihood of a favorable ordering.
That has a very long proof that we won't be going over and you can just take our word for it, but you'd like to look at the proof.
It's also on the course website and the assignment spec. So my tips are to draw out separate stories.
Go for a range higher than three boats, go for rates higher than two and one B and see what star is worth.
Also know that you can assume that and they are both non-negative. They can be zero, but they won't be a negative number.
So you don't have to worry about somewhere as case because you're not going to have negative votes in the real world.
One thing I recommend is to think of base cases. When can we no longer create new unique offerings with a set pool of and be left?
That is what defines an ordering. If you have like ten A's and zero B's, how many ways can you arrange that one?
Right? It's ten A's, so you can think of your base cases and try to think of when can I stop recursive.
Lastly, I want you to notice that abbreviated and manatee headers don't work for both functions.
That is, you can't recurs on the headers provided because you need to be keeping track of more information.
Specifically for comfortable ordering,
you're going to need to use a wrapper function to set the first recursive call and the recursive that is the function.
This will give you some practices, wrapper functions as well. Next, we're on to more sort of sequences.
So far, when we've had to move sort data structures.
You've been provided the way to do that.
You've had vectors sort for vectors, you've had maps which automatically sort through keys in increasing order.
Now you'll be using recursion to write your own sort of algorithm called merge sort.
So we're going to start with binary merge,
where a binary merge operation is something you're going to see very commonly six where you have two individually sort sequences.
So they're already sorted and you just need to sort them into one sort of sequence.
You're going to input binary merge, which in this case will take in two queues which are sort of increasing order and combine them.
Note that if at any point you find that the queues aren't sorted, you should throw an error.
You can't guarantee that they're sorted.
The idea is that you feed them in and they are sorted, but your code should still account for the fact if someone messed up in calling a function.
Now note that the user passed by copy so you don't need to worry about Oh, I can't change these things.
Feel free to modify them in any way that you like if it makes your application easier.
Now also know that there's no guarantee that the queues are the same length, so you should make no assumption about the length of the queue,
but you should write something that should work regardless of how long either queue is.
Also, note that there's no special cases of duplicates of value.
You can just find out some logic that works on it and it should end up being a sort of sequence of matter.
Now the last part about this assignment is that binary merge should be done literally iteratively.
You should not be recursive at this point. You should iteratively. Excuse.
But it's for this assignment or to go through each kill. But remember, entering through queues can be a bit weird.
So if you're confused for how to rate the cuz I had a quick look at the website and see a way to do.
Let's examine each element at the front of the queue and include a small element into a new queue.
Although you guarantee that both of these kids are sorted.
You have no promises about the range of the queues, so you'll reach points We need to grab from each queue at separate points.
The easiest way to look at which theme to look at first is to examine the element at the front of each queue.
Since you know that they're sorted, you know that no value after the front of the queue can cope first.
So all you to do is compare two elements at a time. He can do.
[INAUDIBLE] be very helpful here. And I want you to consider when to use peak and when to use D.
Q, For example, if you're just looking and comparing, do you want to be removing it from the queue?
Probably not. Now to ensure that kids are sorted.
It's very helpful to keep track of the previous events from each queue.
This will come in handy when you need to call your error function.
If you aren't keeping track of the pass, you may be compared to elements, but you may not realize, Oh,
this moment was actually less than the element that came before it from that cue when that should be possible.
So in order to have proper error functionality, you need to be sure that you keep track of the previous element from both queues at the same time.
Last comes the big O run. Time to answer Question ten.
You'll be asked to estimate the bigger runtime of this iterative merge function that you've just attempted.
Now, the best way to do this is use time trials where you can increase the queue size and then find the runtime.
Your goal is to try to find a relationship between queue size and runtimes and estimate it now for now.
Multi merge. We give you this function and you have another question on this.
Now if multi merge assumes that binary merge function works, but if it does work, the function will be fully functional.
So after your binary merge function and you have the approximate runtime to binary merge, your task is to look at this code,
study it and come to any clues of what the bigger runtime is for the save multi merge function as well.
Now last comes the recursive multiverse. Now, when you think about it, it emerged really isn't that good compared to the recursive method.
Now, why is that? Because the Christian method can use a divide and conquer strategy to merge a sequence.
It's much more efficient, especially for longer sequences. If you keep splitting things up into smaller parts and then merge them later.
So if you split the vector of your cubes that you have in half because cross multi merge will take a vector of a bunch of cubes,
then you can reverse them. And that results into one larger queue that is sorted.
My tips. All I can say is follow the handout. They help guide you through implantation process.
That's very good. And here it is right now. So first, we recommend dividing the vector of case sequences into two halves, the left and the right half.
These should be approximately equal number of sequences, which is the number of cues in the vector.
So one thing that you have is a surplus operation. So to subdivide a vector.
I remember I highly recommend looking at this and seeing what actually it does.
That way you know how to implement it properly. Let's say you want to do of a critical recursive multi merge on the left have
two sequences and the right half the sequences you're going to have to cross.
Of course you can kind of think of your tree as branching in to different points each step.
Then you want to use your binary merge function, the one that you are earlier to join the two combined sequences.
At this point, if you've taken the recursive leap of faith, you know that your XML will sort them into two sort sequences.
So when you binary burst them, there are two sorted and you're binary, which should work very quickly and then return the final sequence.
What this means is in your overall code that you look at, you have one called the binary merge,
which takes in the arguments of two separate calls a recursive multiverse.
Once the left half is sequences and one to the right have a step sequences.
Now when you recursive you're going to call recursive multi merge that's going to keep
on splitting left and right over and over and over again to reach your base case.
It's up to you to determine what the base case will be. A general tips are consider your base cases.
Now these depend on the inputs. So you taking the vector Q You should really consider what's the smallest possible input we could receive.
And if we get this input, what do we do then? Next called binary merge to compare to combine the two sorted.
We just discussed that, but note that by recursive multiverse to take in a vector of sorted choose.
It outputs a single sorted queue, so make sure that your type will only ever be a single sorted queue.
That's all I have for you. Best of luck with the assignment. I highly recommend that you take your time.
You start early. You get working on it now. But I know you can do it. Feel free to reach out for help if needed.
Good luck.
Hello? Hello. I'm struck that that was really.
I don't know. Yeah. From my father.
What's your. Just know that.
That's. All righty. Hello. Happy Friday.
Let's go ahead and dig into some material. I actually don't have any announcements today.
You kind of at this point know about the rhythm of the course and how everything works.
And so things are moving forward at a rapid pace and we're just going to dive into material.
The new topic we're talking about today is backtracking. This is still a recursive process that we're going to be discussing.
And the main idea behind backtracking is this If you have some problem you want to solve and you start in some initial state,
like suppose you're playing some game and this is the initial state of the board for the
game that you're playing or you're trying to solve some puzzle or get out of a maze.
You have some initial start state and you have multiple moves that you can make in this game.
So in a maze you can think of like and I have this maze drawn up here where these hash symbols are walls.
And this is a little person in the maze and this is the exit the person trying to get through.
You can imagine a situation where you have a game and you have multiple moves that you can make.
And this is just one example of that. The idea is you just try to make one of those possible moves and then see if that leads to success.
And if not, you come back and try a different possible move.
So from this starting state, maybe you can make four possible moves like you're in a maze and you can move up down, left or right.
So you try moving up and what you do is you change the state of whatever the representation of your problem is,
like the board or the grid that you're using to represent your maze.
You change it and then you make a recursive call so you can do something like this.
You could say, Well, this this person, one of the moves that they could make is they could move down.
And then you take this kind of new problem.
This is a self similar version of our original problem, and you pass it recursively to your function and you say,
hey, you had this problem that I passed to you and ask you to solve.
And this problem makes a recursive call that's like, Hey, I have a new problem to solve.
A problem that have uncovered, which is one of the person has moved here and you try that,
you make a recursive call and from there you make a bunch of moves and as you make a move,
you change the state of the board, you change the state of the game, whatever your representation is for this problem.
And you make another recursive call. And if you hit a dead end, you backtrack.
You return to a previous call where in a loop you were trying out all of those moves.
So you tried one of them. You made a recursive call. It hits a dead end. You come back up here and then the loop continues on.
You're like, Oh, well, instead of going that way, what if I move this other way? And so you make that change.
You go down, you do your recursion, and if that leads to another failure, you backtrack, backtrack, and you're always returning.
And as you return, you're arriving in the middle of some sort of loop and saying, Who was there?
Another or maybe not a loop, but some set of of of options that you were considering.
And as you return, you say, oh, well, could this other option leads to my solution.
Now, as I'm as I'm doing this here. And maybe what I do is I start out with a for loop that has if we restrict this person to moving only up, down,
left and right in the maze, I would kick off in my recursive function a for loop that has four different iterations in it.
One to try moving up, one to try moving left, one to try moving right, one to try moving down.
And I would check as I do that loop and you've done something like this already with your you implemented depth first search breath for search.
So you've done something like this where you're looking at different moves in a maze. And if I try to move up, I can't do that move.
I try to move left. I can't do that. If I didn't move right, I can't do that. But if I try to move down, I can.
So what I would do is this I would modify the grid maybe, and put this little person here and then make a recursive call and say,
Hey, backtracking function, Try to solve this new version of the problem.
Can someone raise their hand to tell us what would go wrong here potentially with that algorithm
that I described where I make this move and then I make my recursive call and then I'm like,
Hey, try to solve this problem for me. Back tracking function. What are what are you seeing here that could go wrong?
Go for it in the blue sweater here person. Yeah.
If I go. If I make a recursive call and say, Hey, here's my new problem.
Well, if that for loop tries to move up the for loop, we'll be like, Yeah,
this person can move up, so let's move that person up and then make a recursive call.
And so I had my initial call. I moved the person down and made this call.
Now I moved the person back up and made this call. This person gives a run back.
It's like, see, it's to $Sometimes it's like being stuck in a bad horror movie where like this person is stuck in a maze.
I don't know how they got there or why they're walled in,
but someone's like chasing them with a chainsaw and they're just running back and forth and not actually getting anywhere.
You're shouting at the screen. You're like, No, don't move back up.
But they just move back up and then then they die in a in an ugly bloody what's it called when we get infinite recursion.
We had a stack overflow so they die in a read bloody Stack Overflow.
You're not a happy life. So one of the things we often do with backtracking problems is we find a way to keep
track of the states that we've already been in so that we don't go back to those states.
And the simple technique that I have for tracking that with this problem is when I move the person down,
I'll just put a little breadcrumb here to say, don't move back to that state.
So now in my recursive call, when I'm looking up left, right and down, I'll look up and say,
Ooh, I can't make a recursive call where I move the person up because I've already been there.
And if I go back there, I might end up in an infinite loop here or infinite recursion or stack overflow.
I can't move left because there's a wall there, but I can move, right? So I'll put a breadcrumb down and move this person.
Right. And so I'll move that person, make another recursive call and then keep on going.
I can't move upper left right now, so move that person, make a recursive call. I can go up.
So put down a breadcrumb, move the person, make a recursive call.
Now, in this recursive call that for loop would look up left and right and say,
I can't move there, and would also look down and say, I can't move there. I've been there already.
So what I would do from there is I've made recursive calls to move this person down to that position here where I've hit a dead end.
I would return to a previous call and when I return to this call right here,
remember I was in a loop that was trying to move up and I just tried to move up.
I made my recursive call. It didn't work out. When I come back to this call, then I'm going to look to the left and say,
Well, I can't move to the left, I can't move to the right, I can't move down. But when I come back to this call,
an important thing that I need to do is I don't want to like when I moved the person up to this position and made my recursive call down here,
when I return to this recursive call right here, I don't want to leave the dude in the maze down there.
I want to bring him with me. I want to say, Hey, we're backtracking, buddy. Like, let's back on out of there.
So when I backtrack out of there, I'll actually bring the person back with me.
This is me returning from a function call, and then from here there are no possible moves at all.
Return to this call and move the dude and I'll return to this call and move the person.
And then when I get back to this call, remember, I was in a for loop. I tried moving up.
I couldn't. There was a breadcrumb. I tried moving left. I couldn't. There was a wall.
I tried moving right and I did that. But it led to a dead end solution.
And now I come back to this call and I'm in the for loop where I'm like, Oh, I did three iterations of this for loop.
The fourth iteration is like, Hey, now try to move down. And I would make this recursive call here.
And by the way, as I'm returning from this path over here, this path that I explored with backtracking,
I would have this function return a false value so that when I return over here to this function,
to this function call, and I was considering moving down, if I returned a false to this function call that would tell me I did not find the maze exit.
So please keep exploring. If I had found the maze exit right here, then when I returned, I would have returned True return true return true.
And when I got to this position and I returns true, I would say kill the for loop if I found the exit there.
I don't need to keep making recursive calls. I don't need to go down and explore the maze.
So these calls, as I backtrack, would return true and false to indicate whether that path led to the solution or not.
And so in action, here's what this looks like.
So I have here, I mean, it's like t t I wrote this little program maze that t t and I'm going to give this a run.
And what we'll see is above the maze. When I give this a run, it's either going to say searching as I make recursive calls.
So I want you to try to visualize this in tandem with the animation you're about to see.
You'll see the person moving in to say, searching. That's recursive call, recursive call, recursive call.
And when he hits a dead end, it's going to say backtracking. It's going to go backtracking, backtracking, backtracking.
And then when it starts making more recursive calls to go in another direction, you see it's searching.
So this is that first recursive call searching, searching, searching, recursive call, recursive.
Now backtracking, backtracking, backtracking, now trying a different branch, recursion, recursion, recursion.
And it's searching very, very painfully slowly through the maze.
And so, again, very much like a horror movie where you're like, dude, you're not going to make it.
You need to move with some hustle. There's a murderer in the maze coming after you go down.
Go. No. Why are you going to the right? What are you doing? Bad move.
Like leave the garage. That's where the murderer is hanging out and hiding for you.
And then when we hit. So this is recursive call. Recursive call. Now backtrack.
Backtrack. I'm returning false. Returning false, returning false.
Going back to, I mean, these embedded calls, it's like backtrack, backtrack.
Oh, I can make another move and it goes recursion return. Version. Recursion.
Recursion. Backtrack. Backtrack. Recursion.
Recursion. Recursion. There we go.
And that little exit. I know the spinny animation is one of my crowning achievements in life.
So that's there for you. I've also set this up so that he can go really fast through the maze if we want to.
So so that's the basic idea behind backtracking. And again, if you were to code this up, what would you what you would have?
It's some sort of for loop where there are four iterations and each of those iterations corresponds to possible move.
We sometimes you'll hear us using a lot as we talk about backtracking this quarter.
The phrase choose, explore and choose that represents what's happening in the backtracking paradigm.
So given this problem, what I did was first I had to choose a move up or down, left or right,
and then I made it and I made a recursive call and I said, Explore what happens.
So at one point what we did was we moved from the start.
We moved down this path over here and said, Explore what happens.
And then when we return, we unmake that move if we haven't found our solution.
What I did was I undid that move. I brought the dude back to the breadcrumb that's highlighted on the screen and said, Go in a different direction.
So choose a direction, explore whether that works out and then if you return it didn't un choose undo that thing as you and the on choose
also is like as we were returning I always put the dude back in the right position as we moved back through the maze.
I always worry actually. Sometimes I just refer to a thing like that as a dude and I worry that I'm maybe not being like super inclusive or if,
if there are non-male that there might be non-male people in the audience who are thinking like, Oh, why is it always a male in computer science?
I just want to say I consider the male pronouns through overuse to have been neutered over time.
So sometimes if I just refer to the male pronoun, I'm just kind of being a little bit neutral with that.
And I hope no one's thinking like, Oh, why is that just a male all the time?
The patriarchy is kind of self-defeating in that sense, isn't it, that through the overuse of male pronouns,
they've just become in some forms we consider them gender neutral just because they've been so overused.
Anyway, so that's just my little side right there. I don't want anyone to think that I'm being sexist or exclusionary by doing that.
Well, and also the dude is being chased by an ax murderer, and I definitely don't want to be like, Yeah,
let's throw women, CIA computer scientists into the lanes and and come across as if I'm saying that.
So I just want to be really clear about where I stand in terms of inclusivity and everyone being welcome in my classroom.
Please, let's let's take so so this is depth first.
Search. Depth first search is the quintessential backtracking algorithm.
That idea of go down a branch, you hit a dead end, you back up and then you go down a different branch over there.
One of the things that I want to show you about this is that if you have multiple we sometimes call them solutions or we'll call them Gore states,
if you have multiple goals in your maze, let me take a look at what other mazes I brought with me today.
I have this one here just to show you that this program will actually this process works regardless of where you put the maze.
So the maze exit.
So this person will still find the exit regardless of where the maze begins and where the exit end seems like the worst possible path there.
That was amazing. Or if you have a situation like this where there is no exit,
what will happen is the dude will explore the maze and end up backtracking all the way to the beginning and never having found the exit.
It will just work its way all the way back to the beginning and be like, Oh, I didn't see him.
So this is the situation where you just wake up one day and you're in a maze and I guess
the person who abducted you and put you there like built a wall before you woke up,
I guess could happen. Be careful that there are the other means that I want.
This is what I really want to show you here is backtracking and depth First, search accordingly will find a solution to your problem.
If from the starting state there is a way to get to the goal.
The end state depth first search slash backtracking will find it, but it won't necessarily be the best solution.
So I happen to know with the way that you're just looking at this, you're like, move two squares to the right and you're finished.
You're out of there, dude, you're home free. But I happened to note the way I coded this up.
The dude always tries to move left before trying to move right?
And so if I give this a go here, then the the the guy's like, just moving over there, like.
Like a crazy person. Like, why would you not we just turn around, The exit was behind you, and we'll eventually make it to this exit over here.
Find that exit and get it gets way out. But depth search is not guaranteed to find the shortest way to get there.
It just depends how you've cut it up. Now, breadth first search would have. Do you remember breakfast search from that assignment that you did?
If we started here, breakfast search would have looked at all the neighboring cells.
So it would have looked at this cell and this cell and then all the neighboring cells from
there that get processed from a Q So next would have looked at this cell and this cell.
And when it found that so it would be like, Oh, I know how I got here. I kept track of this.
I got here just in two squares.
But backtracking doesn't necessarily find the shortest path is one of the main things that I wanted to point out there.
And then this this one isn't actually, I think, particularly interesting.
It just finds it finds an exit out of the exit.
And nope. So to the maze you can have multiple possible solutions as you're exploring something with backtracking.
So that's backtracking and that fundamental paradigm again. What were the three words I was like first?
BR They were. Choose explore untruths.
Okay, Now in your notes for today, in your course notes,
one of the things that I've written up for you is the section called The Basic Anatomy of a Recursive Backtracking Algorithm.
And let me say this I think choose explore on choose is a very like Stanford ism, this basic anatomy of a recursive backtracking function.
I really do want you to kind of take a minute to read this after class today when I post your notes.
This is just kind of my take on backtracking and what all happens there.
I mean, we have a base case to check if we found our solution. We sometimes check for duplicate states.
Well, like here, we had to check that the do didn't move back to a position he'd been in already.
Sometimes, actually, you have backtracking algorithms where you don't need to worry about checking for duplicate states.
And then we typically have a loop or some sequence of function calls that tries a bunch of possible moves.
And within that will check whether the move that we were doing was valid.
We will then change the state if it is a valid move. That's the choose.
We're saying, okay, we are going to make this move. Then we perform our recursive descent, make our recursive call.
That's the explore. Let's see if we can find a solution. And then when we return from that recursive call, we will often process the return value.
So in the maze that throws things, we would return false if we didn't find an exit.
True if we did find an exit. So when you make this call and it returns, check if it returns true or false, and then undo that state change.
That's the unscrews part of the choose explore on choose. Move the guy back to where we brought him from is the thing there.
And this also sometimes is optional. What you'll see with some backtracking is we sometimes make recursive calls and when we return,
we don't need to undo the state change because just naturally,
when we make our next recursive call that state change is going to happen and overwrite the previous state changes.
So it just doesn't matter if we if we do that or not. So let's take a look.
Let's implement something from scratch with this actually. So we've talked already about sequences.
So we've looked at sequences of coin flips, heads, tails and things like headset's heads, tails, tails, tails.
What sequence those flips end up in. We've also looked at permutations given a set of objects.
What are all the jumbled ordering of those objects? So the coin flip thing is different from that, right?
Like we weren't saying, here are three heads. How can you order those heads?
Well, that would just always be headset's heads. What we're looking at with the coins was actually a sequence problem.
Or we also saw rolling some dice. That was a sequence. This problem.
What are the different sequences we can get out of that? But Permutations was given a set of objects.
What are all the orders we can do? There's a third related problem, and I want you let me say this before we forget today.
I think it's a good idea to be familiar with all three of these paradigms.
So going into, say, a tech interview in our field,
you would want to be able to just throw down and kind of have as just part of your repertoire that you know how to do this.
Throw down a solution to a combinations, a sequences, problem permutations problem, and a subsets problem.
So let's talk about what subsets are. So given a set of entities like suppose I just have this set that contains elements A,
B and C, a subset of that is just a set that contains some selection of those elements.
Now, remember, with sets, we don't repeat elements.
So I wouldn't say that a is a subset of ABC, but one possible subset of this is just the set containing a that's a subset of it.
It contains some selection of the elements from ABC.
This is another subset here. This is another subset here showed out another subset that you're that you can have here.
Yeah. Abby That's amazing. You just chose the one that I was going to have next on the screen.
A lot of people show shouted that, Okay, what's another one? Yeah, we could do a C, we could do B, C, choose any two basically, that you want.
The order doesn't matter. All that matters is that they're in the set. And ABC also is a selection of the elements there.
ABC is a subset of the set containing ABC, so every set is a subset of itself.
What's missing from this list of subsets? You can just shout it out if you happen to know. Yeah, the empty set.
So if someone says Here's three options, select them and build your own set.
You can just leave them all behind and have an empty set there. These are the only subsets of this set.
And again, if you're looking at this thinking maybe A is a subset.
No, because you can't duplicate elements in a set or maybe you're looking at this or saying,
well, what is what about B, A will be A is the same thing as a B in set notation.
It doesn't matter what the order of the elements is. So I want to talk about how we can generate these subsets recursively.
And the idea relies on backtracking. So let's generate the subsets of ABC.
I'm going to start with an initial call and I'm going to use this so far and rest
paradigm that we've already seen where we have the string we've built so far.
The solution, the set we're building up so far, and then we have the things the other,
the rest of the things that we have to play with now to represent a set in this problem.
I'm just going to actually use a string that has characters.
So the string ABC just think of that as the set containing a comma, B, comma C is three elements in a set.
A string is a nice, easy, accessible representation. For that, I have some choices here.
I'm going to make a binary choice with each element of the set.
I'm going to look at this, this rest ABC, and I'm going to say, Well, first of all, if I want to build some subsets,
let's make a choice about a all of my subsets that I can generate, either have a or they don't have a right.
Like if you look at all of these sets back here, each of these sets,
it either has a or it doesn't have a, and that will lead to a bunch of other subsets here.
So that's the first choice that I'll make here. I'll say, well, there are two choices.
I can either leave a behind and say, Nope, I'm not going to put it in my set and remove it from the table for consideration.
I'm just going to generate subsets that don't have that thing, or I could put it in my subset,
in which case it's off the table for consideration because I've already taken it off the table and put it in my subset.
These are the two options. I remove it from the table of consideration and I either put it in my set or I don't put it in my set.
Now, recursively, when I code this up, of course, you know, these two calls aren't going to happen in parallel.
I was just showing you that call there. See you some context for what is happening and where I'm going with this.
But initially, we'll make this call to the left over here and then I'll repeat that process.
I'll say the first element in rest is B, do it to include it in my subset or not.
Well, there are two options. Let's first of all, just try leaving it behind.
Or I could try including it. But that call is going to happen a little bit later.
And then from here I have C on the table and I look at that, I say, Well, I can either put that in my subset or leave it behind.
If I put it, if I leave it behind, I end up with the empty string and then there's nothing else to choose from.
This is actually the first subset of generated. It's the empty set.
And then from there I return up to this call and then I make a choice from there.
Am I going to include? Well, I tried today. What have I left behind?
Let's make the call where I include C so I would put this is a basic as here.
I would put C down here in the set and then I've had a base case again, so I have my two choices.
Leave C behind or put it in my subset. Now when I come back up here to this call, I return up here.
One of the things that I wouldn't want to do is leave C in this string as I return back up here.
So I wouldn't want to pass by reference my string because then when I get back up here,
C would still be lingering and then I'd go here to add B and I would have B and see in this blue patch right here.
So this is where the the unused part of backtracking comes into play.
I wasn't really nice. Way to choose something is just to not pastor strings by reference.
If I pass my string by value, then putting C into the string over here.
Well, when I return up here I have a different pass by value so far and a different pass by value so far here.
So the C just disappears actually when I return, if I pass by value.
So pass by value is helpful for choosing kind of stuff from your string automatically,
but it's also a little bit more computationally expensive because every call is generating new strings and taking time to build those new strings.
But I think it makes the code a little bit more straightforward. So from here, if I put B into the subset, well then I have to make a choice about C,
I either leave C behind and I just have B in that final solution, or I take C with me and then I have B and C in that final solution.
And then I backtrack. I'm like, backtrack, backtrack, backtrack all the way up here.
And I'm like, Let's try something else. So this is actually a version of backtracking where I'm not necessarily looking for a single solution.
This is a kind of backtracking where I'm making a choice and then undoing that choice, but I'm using it to find all possible solutions.
So you can imagine the the special crimes investigator who finds that maze and the dead body in the maze that's been ax
murdered in the previous example we saw might want to search the entire maze and look for all the hidden traps and exits.
And so their process is necessarily different from the person who was like, I just want to get an exit and get out of here alive.
Different flavors of backtracking. Do we explore all possible solutions or just stop as soon as we find one?
Well, over here, if I take a and put in my subset, then I have the choice with B, Do I take it or leave it?
If I leave it, then I only have C left to choose from. And if I leave C behind, this is my A subset.
And then when I come back up to that previous call, if I take C with me, this is my AC subset.
And then if I come back up here, if I took B with me,
I'd have a B so far and then I can either leave C behind that gives me this or I could have taken C with me and that would have given me this.
And those are all the subsets we generated. We have the A, the B, the C in isolation, we have A, B, C,
we have the empty set and we have the set with all three elements and it generates all of those.
So that's the idea there. Everyone feeling okay?
I don't know. I have to say, I wasn't pausing for applause. I was just pausing for you to recover.
But if the pause helps you recover, let's. Let's do it. That's great.
Let's take a look. Let's put this up. So I'm going to call the subsets, and that is not what I want to do.
Let me open this project over here.
Configure the project and and okay, so this is going to be my string S equals ABC and I'm going to do media should call.
I'm just going to call it subsets. This is a bad function name. By the way.
I've mentioned to you, we tend to use verbs for our function names, verb phrases, and this is a noun, but you know what I mean.
This would really be like print subsets or generate subsets or print all subsets or something like that.
I'm just doing shorthand there so that we can get through this today without me having to do a whole lot of unnecessary typing.
So with the subsets, I'll pass the string s in here.
And then what I wanted to do was have so far and rest and remember what I never do when I write a function like this.
I never trust someone to call this correctly.
Like if I give someone a function with two parameters and I'm like, Hey,
please be sure that your first parameter is an empty string, and your second parameter is all the stuff in your set.
Someone's going to mess that up.
They're going to give me a string that's not empty is the first parameter, or they're going to make the empty string the second parameter.
And then the first parameter has ABC. I'd rather to say, just give me the one parameter.
It's the stuff you want to promote and I'll take care of behind the scenes,
setting the function up and what do we call this kind of function that really is just made to lead into another function?
Everyone Yeah, it's a wrapper function, or I sometimes call it my gateway function.
Okay, so this is just going to do subsets and I'm going to pass the empty string because so far I put nothing in there and then let's do this.
So this is void Subsets takes the string so far and the string rest.
And we need a base case. Can anyone think of a base case where you're like, Oh, if we hit such and such situation,
I don't need Well, I guess I had the situation on the screen there.
But what's that case where we're like, Oh, there's nothing left to do except just kind of print something in return.
What's the base case, everyone? Yeah, if rest is empty.
So we could do with rest empty or if restaurant length equals zero or if rest equals equals double quotes with no space between.
So if that's the empty string, then what we can do is just see out so far the thing that we have so far and return.
Common Pitfall by the way, in base cases, sometimes people forget to return and so then it goes on,
the function goes on to make more recursive calls instead of leaving and actually being a base case.
Okay. Otherwise we have to make a binary choice about that first element in our string.
Let me actually take that first element out of the string. Right. Like, that's something that I wanted to do over here,
like a I wanted to take it out of the rest and either put it, put it in so far or not put it in so far.
So let me pull it out. First of all, I'm going to say, Char, this one equals rest remove when you call at rest, not remove what was a position zero.
When you call when you remove what was are actually now let me do I'll do rest like this over here and then I'll do rest equals.
Let's do the substring. Now remember the substring if I pass it one that means just go to index one and include everything from there and beyond.
So index zero is effectively being eliminated from this thing right now.
I'll go away. That thing over there. Okay, so we're back. So I've pulled that one character out.
And now if rest initially was ABC, what I said was go to character one and give me everything from that character and beyond.
So now rest should actually just be b, C and I can make my recursive calls.
And the two recursive calls are either do include this element or I don't.
So if I, if I don't, let me do that. So this is subsets so far, I just don't add it there and I pass it the rest.
Or if I do added, I can do something like this.
And that's all there is to this. How can you peel a character off of the rest?
And then you make a call where you didn't put it in the set you have so far,
and then you make a call where you did put it in the set that you have so far, maybe hurray, that's actually generated.
This is the empty one up here, but it's generated A, B, C, A, B, a CBC.
AVC So that's doing all the things there. Now, one of my objections to this is that it doesn't look like sets, so let's actually do this.
I'm going to do fancy print so far and just write a nice, fancy print function and void fancy print that takes the elements that we have.
This is just my string s and I'll do a nice little curly brace.
Like that. And then at the end, I'll do a nice little closing curly brace and like this.
And then I'll just do a for loop for and I equals zero is less than the length of the string I plus plus.
And let's go in here and print each of those things so as sub I and then the question is do we put a comma?
So I have the string ABC, I want to print a comma, B comma.
But see, I don't want a comma after.
So I want some way to say if this is not the last character, then go ahead and see out a comma and a space to evenly space everything out.
How do I know if this is not the last character? You can just shout out if you have an idea.
If I is not equal to what? Yeah.
If it's not equal to s length minus one. Remember if we have three characters, the length is three.
The indices are zero, one and two. So when we get to number two, that's length minus one.
Three minus one is two. We get to index two. That would be the last character.
There's no comma that we want to print after that thing there. Oh, hooray.
Now it's printing them all in like a fancy set format.
We're basically bamboozling, bamboozling whoever is looking at the output into thinking we have sets,
but really, it's just a string behind the scenes. It's wild.
It's a few lines of code, but it's doing so much. It's an exponential explosion.
Actually, this one call makes two calls. Those two. So you have one call, then two calls.
These each make two calls. You get four calls. Those each make two over eight calls.
It's a two to the end algorithm. It's really, really slow.
Remember, exponential is like super, super, super bad. We hate to see it.
Another modification you could make to this, by the way, is you could have this function spit out the number of subsets it generates.
And this is very much something I would put on an exam is give you a question like
this and then say modify this code so it returns the number of of results it found.
And so here's what I'll do to generate the number. I need this first of all, to return an integer.
So this is going to return an integer here. And then down here I'll do C out total number of results, and then I'll print whatever this returns this,
you know, after I call it and it prints all the subsets, I should now come back here and it should print.
A number of subsets that are generated. And so here I'll do first of all, let me use return so that whenever this returns, gets returned back to me.
And now I want to count up the number of subsets. Well, first of all, if I see a solution here, then I've seen one solution.
Let me return the number one. Just say that I've seen one solution.
Otherwise, if I'm not in a base case, what I need to know is how many solutions does this generate and how many solutions does this generate?
And what should I do to those two numbers? What should I do to this number that this returns and this number that this returns?
Add them together. So one thing I could do actually is say return and take these and add the results together.
So when I hit this line, it will first make this recursive call.
And that's what I want to do, is make this recursive call, generate the subsets,
but then that returns some number and then I go on and I make this recursive call which generates in principle subsets,
but then it returns a number and those two numbers get added up and returned all the way back to whoever called to this function.
And there's just like, if I go down here and I generate five subsets and five subsets, I do five plus five is ten,
that would return up here and then this ten would return up here to get added to whatever number came from over here, ten plus whatever.
So this is just generating those numbers and returning those numbers. And what we see, oh, this is just like a poor of life choice over here.
Let me do this. INT totes equals subsets of us like this and see out total number of results over here.
I'm just putting that in a variable. It started to print everything, of course, before it made those function calls there.
So it printed eight different subsets and I counted up the subsets.
So of course, leave that in your notes for you to consider all of those possibilities there.
And the things that we can do with that.
The next thing that I want to talk about then another problem that I want to solve here today is I want to talk about.
So I just have a different problem that I want to try. And it's like maybe a little bit more complicated than this one.
Not that this one isn't already complicated, but let's take a look at another backtracking problem.
So I'm actually just to start a new file for this one. Let me do vec some.
What I want to know is given two vectors of integers,
is it possible to partition them into two vectors such that the sum of those two vectors is the same as one another?
So check this out. If I do, let me do vector int v like this and then I'll do v equals five like that.
And then I want to know if this is partition of ball.
And so by partition, what I mean is splitting this up into two sets where every element is represented,
where every element is, is represented in these initial, in these subsequent sets.
Exactly. Once I don't leave any behind and I don't duplicate any.
Now here and maybe kind of violating a bit of a principle here, I'm calling this a set.
Maybe I shouldn't call it a set at all. Let me just call them vectors.
So I have this vector I want to if I can partition it into two separate vectors such that the sum of the elements in the two vectors.
So let me say this. Here's one partition. I could have an empty set and one, one, two, three, five.
This is a partition of those elements into two vectors, one empty vector, the other vector.
All of those elements are there, they're represented. Or if I took the three out of this one,
this is still a partition because every element that was in my initial vector is in exactly one of this one vector or the other.
Or this is also a partition. If you union to these two vectors together, you would end up with the same original vector.
One one, two, three, five. This is not a partition.
I've lost one of my ones. This is not a partition.
I've gained an extra two. Is everyone okay with my definition of partition?
It's that each of those vector elements ends up in one of the subsequent vectors of the other.
Okay. And so in terms of putting these together so that they can so that we can end up having the same sums.
Well, one way to do this is to do you can do one, two, three, what's the sum of one and two and three, everyone, six.
And then what elements are left over that need to go over here, another one and then a five?
And what's the sum of one and five, Everyone. Six. So do you see why you need those two vectors together?
I get my result back, but also if I independently sum up all the elements, they're the same.
So one plus five or six and one plus two plus three is six.
So this I would say is partition of all into two vectors that have the same sum as one another.
In contrast, if you do something like this one, four, five, six.
There's just no way to partition these out into two vectors that have the same sum.
Like if I put six by itself, then I'm left with five, four and one and five, four and one add up to ten.
That's not equal to six. If I try to put six in one over here, that's seven.
But I'm left with five and four is nine. That doesn't work. If I do five and one over here, that's six.
But then I'm left with four and six over here, which is ten.
Do you see there's just no way to partition these out into two vectors that have the same sum as one another.
It's just impossible to do. So in terms of my test cases, let me do this then.
Let me do C out and I'm going to call is partition a ball and pass it this vector.
And I would expect this to be false. This one is not partition ball and I would expect this one to be true.
This one is partition of ball into those two vectors.
Let me write the is partition of all that.
So I want to return a boolean from this is partition a ball and I'm going to pass it a vector that contains integers.
And I'll do that by reference just to keep this thing.
You know, I don't really love the idea of passing a vector by by value because I create that copy that takes a lot of time.
If I have a really large vector, it also takes up more space to create multiple copies of that one for each recursive call that I makes.
I don't want to do that, so I want to know if this is partition ball.
Here's my idea. I have again a binary choice.
If I want to try to create a partition, I can start with this set, say one, one, two, three, five.
And the first one, as I'm trying to create a partition, it either needs to go in vector one of my partition or vector two of my partition.
Those are the two possibilities. It either goes in, but you can't leave it behind.
You have to put it into one of those two vectors that we're creating. So I'll give that a go and then I'll do that for the next one, in the next one.
And once I run out of elements, I'll just check if all the elements over here add up to the same numbers, all the elements over here.
And I can actually do this without maintaining new separate vectors, because what I'm interested in is the sum.
So I can say if I put this element, this first element into vector one, I'll just have a sum that says Yeah, plus equals one to the sum over here.
Or when I get to the three, if I decide to put it in vector two,
I'll just say some two plus equals three to keep track of what sum I would have if I put that in there.
So I'm going to create two sums to keep track of as I make recursive calls and see if they are equal when I run out of elements.
So I'll say Here, return is partition of all, I'll pass of the vector and then some one and some two.
So if I try to do this, if I end up doing like one, two, three or and then the my other vector is like one five,
what I'm saying is I'm actually not going to store a vector. Like if I put one in this vector, quote unquote heavy air quotes.
I'll actually just add one to this sum right here and I'll add two to this sum here, and I'll add three to this sum here,
and I'll add one to the second sum and I'll add five to the second sum and when to make my recursive calls and base case.
So they'll both be equal to six. But to get there, I'll make a lot of other recursive calls along the way.
So let's see how this works out. Let me do this. Is bool is partition a ball?
It's a vector int like this and I just have int someone and int some two like that.
Oh I need a base case. So what are you thinking for a base case here?
In what situation can we actually stop trying to put elements into either some one or some two.
When what situation happens? Can we stop doing that? Yeah, very good.
When the vector is empty. So when v dot size is equal to zero.
What I want to do is check whether the two sums are equal to one another. If so, return true.
I found a solution, but if I ended up doing like a partition. Where? Add one over here and then.
One, two, three, five over here. Return false because those sums aren't equal to one another.
So you could be tempted to do something like this. You could say if someone equals sum two, then hurray we found a solution.
Return true else if they're not equal, we did not find a solution.
Return false and this would work. If the sums are equal, we've run out of elements.
We put every element into one vector, the other. If the sums are equal, return true, otherwise return false.
This paradigm, though this idiom is very much frowned upon in the field.
If something is what I'm saying, here is this. I'm saying if this is true, return true.
If that is not true, well, if the highlighted thing is not true, then it must be false.
So I'm saying if it's false, go down there and return false. If it's true, I want to return true.
If it's false, I want to return false. That means I can just do this.
And get rid of the stuff I highlighted because the question does someone equal some to give us a result either true or false?
Just return that thing directly. Is everyone following this idea, if that's true?
My code below said return true. If that was false, I would have returned false.
And so just whatever it is, return it. If it's true. Return true.
If it's false. Return false. How many are following that idea?
Give me a little friendly wave. I get lots of waves happening here.
Okay, so that's a paradigm there and something that I want you to be comfortable with. Well, then what I need to do is from the vector, remember,
I need to remove a whole element and try putting it in one some or the other so I could do something like this.
I could say int this one. So just like we used so far at rest.
I personally sometimes use the noun phrase, this one to refer to whatever element I'm playing with right now.
So this one equals v dot remove the thing at the very beginning of the vector, so I'll just try to remove that one there.
And what v remove does is not only does it pull that element out, but it also returns the element that it pulled out.
So whatever it returns the number that pulled out. That's what I'm putting in this integer over here.
So initially that's going to be one from that set below. So that'll I'll give this a try.
I'll try is partition a ball with my vector where I've removed that element and I've got some one in sum to I'll make these two recursive calls.
I'll try adding that to my first vector. Sum this one and I'll try adding that to my second vector.
Sum this one, and I'll look at those two results and say, What if we added it to the first sum but not the second one?
And then I'll say, Well, what if we didn't add it to the first one? But we did add it to the second one.
I'll take a look at those two results. And these, by the way, are booleans.
So I could maybe call this bool result. One equals this bool result two equals this.
What do I need to return then if I.
If I. So I checked whether this led to a solution and I checked whether this led to a solution.
What do I need to do to those two booleans to find out whether I found a solution at all?
You can just shout it out. Yeah, I need to all those things together.
So I'll do resort one or resort two like this.
Now, here's my complaint about this. Initially.
One of the things I'm going to do is pull pull an element out and watch as I pull this out and making all of these recursive calls,
I'm preparing to make the left and the right call. When I returned back to Maine.
Just like imagine how crappy of a situation this is.
Someone in Maine created this vector that had like special meaning to them and perhaps a sentimental value.
And they gave us the spectrum that like, Hey, I have this precious vector.
Can you tell me, would it be possible to break it up into two vectors where the integers in those two vectors had the same sum?
That's kind of where the metaphor breaks down. I don't know why someone's coming to you with that question, but this vector was precious to them.
And you're like, Okay, let me find out. And you destroy the vector when you come back to them.
And you're like, Yes, that was possible. They're like, Where's my vector? You're like, I don't know.
I removed all the elements from it. They're gone.
This is just considered the technical term for this in the field is rude to just like someone gives you an input and ask you a question.
You're like, Yeah, I'll give you an answer to that question. But the cost is I'm going to destroy the data that you had along the way.
So this is where the unused part of Choose, explore, choose comes into play.
If you remove this element and make your recursive calls and you're like, Ooh, what if I pull this element out and put it over here?
I put it over here. Once you figure out whether that's a good idea, put that element back where you found it.
And so we can do something like this v dot insert back at position zero, this one element that we removed.
So we take it out, we play around with what happened and then when we come back here,
we put it back in and we return back to this function call where we not only give the person who called us a result,
but we leave their vector in the same. Not only do we leave all the elements there, we leave them all in the same order in which we found them.
That's another very important thing to do. If someone gives you some data and they ask you to solve a problem, don't just like.
So it's kind of like, what have you called a plumber over to to your plate?
I guess we're living in dorms. I was going to say your house, but houses are so expensive, we'll never afford a house.
I'm sorry. They just keep getting worse and worse and worse. It's never going to happen.
The existential dread Friday the.
Oh, what was I talking about? The existential dread took over and I lost my train of thought.
Oh, yeah. If you call a plumber over to your place and you're like, Hey, I need you to fix this plumbing problem.
And then they like,
what they do is they come in and they just rearrange all the food in your cabinets and they flip tables over and they unplug your computer,
but they fix the issue. They haven't done a very good job.
Even if they've left all your stuff in there and they fix the problem. But they like upended everything that's considered poor form.
So so not only leave all the elements in the vector, but get them in the same order.
What's bad about the way I'm adding and removing elements from the vector?
You should feel queasy when I write code like this.
What's what should be making you feel queasy about this code?
Go for it. It's inefficient because.
Very, very, very good. If I have a vector and I want to take the zeroth element out, remember I have to scoot everything over one by one.
Scoot, scoot. It's an order and operation. It's better to just add and remove at the end of the vector.
But, you know, ain't nobody got time for that. Let's see if this works. Oh, no.
Someone was not declared in the scope. What? Should I initialize someone equal to everyone.
Initially, when I put nothing in the vector, I have a sum of zero.
Yeah, I just. I meant to pass the zeros. I don't know why I was typing the word someone in sum to their.
Okay. And by the way, one means true, zero means false. So we got a true and false result by calling those two things there.
That's super exciting. One of the things, by the way, that that C++ does that's super neat is this thing called short circuiting.
So check this out. Suppose I do true ordered with something.
What is true or with true? Everyone true.
What is true or with false? Also true.
So what is true or with something? It's always true.
So C++, if you if you tell it to evaluate true board with something, it doesn't actually evaluate this something.
It doesn't need to. It knows the result is true overall. So one of the ways that you can capitalize on that here is you can say Google result
equals and you can take these two things here and put an order symbol between them.
And so if that first one returns true, the second recursive call never happens because C++ is like true or with whatever that call,
which do I already know whether that's true or false? The results are going to be true.
And so then I can just return the result down here. And this is called short circuiting.
And when you put two function calls together like that, it can stop the other function call from happening.
When I was doing it this way, when I had it like this, I wasn't applying the order operator until I got down here.
That's after all this computation happened. Both of these calls were definitely going to get made in this version of the code.
But when I rearranged like this, there's now a chance that both of those calls will not necessarily get made in this version of the code.
And so that's just a neat thing that happens. There is short circuiting.
If you want to go to Boolean calls and you're willing to return true without making the other call.
Like, if I wanted to if I wanted to go through all of these possible calls and generate all results and look at all results,
then I wouldn't want to do this short circuiting technique.
The final thing that I want to show you, we do still have a couple of minutes here is what if we wanted to print the actual results?
This becomes trickier with the choose explore untruths because if I want to create vectors vin vI have to put elements in.
But then when I undo a recursive call, I have to pull those elements out and it becomes a little bit hairier.
Let's take a look at what happens here. This is vector of integers. I'll call this Vand this is a vector of integers.
I'll pass it by reference called VAnd then down here, let me create new vectors.
This is a vector of integers v one and a vector of integers v two.
I'll pass those in by reference. Now it's happy to make that function call.
And then what I want to do is whether vector sum of v one is equal to the vector sum of V to let
me just write a function really quickly that actually goes through some vectors into vector.
Sum takes a vector of integers by reference, it has an initial total value that I set equal to.
To zero in total equals zero for I equals zero is less than v dot size.
A-plus plus total. We add whatever is at v sub I as we go through this thing and then return the total.
So that's that case there. And then down here to remove what I want to do is actually add this.
I want to go back to trying to add this to my different vectors. So let's try adding it to my vector v one dot.
Add this one thing that I removed and then do pull result one equals is partition of all and I'll pass it.
Now the actual vector that has that thing in it and when I get back I need to undo that change immediately.
Let's remove let me do v one add.
So it went to the very end. So I need to do v one dot size minus one.
That's the index that I'm removing from. And then I could do the same thing down here.
With this V to try adding it to V to result.
Two is this thing over here has to be one in V to remove from v two the thing that was at that.
And then don't forget to put that back into your original thing and then result one word with result two over here.
So this is more complex. I'm having to you can see choose remove a choose ex or untruths in these three line kind of vignettes that I have over here.
This was choose put it in the vector explorer, make a recursive call and choose.
Remove it from the vector.
But there's also this choosy nature of pulling out of this vector, and this untrue is the nature of pulling out of this vector.
And then we have the results that happen over there and it passes those two test cases.
I'm sure it works on every test case. Amazing. Thanks for being here.
Happy Friday to you and I'll see you on Monday. Thank you.
Some people working hard for that. I appreciate.
Staying already. Hello. Happy Monday. Thanks for being here, everyone.
The adventure in backtracking continues. And remember,
the main idea behind backtracking that we saw on Friday was you have some problem you want to
solve and you have some moves that you can make as you get that starting state for your problem.
You just kick off some sort of loop or make multiple recursive calls where you try one move and you make recursive call,
recursive call, recursive call and see if those moves lead to a solution.
And if it does, you return true up that thing or some number of that thing or some result that you wanted and to stop the recursion.
And if not, maybe return false or some flag that indicates we didn't find a solution.
And then you come back up and you go down a different path and try try finding different
try finding different paths that might lead to the goal that we're searching for.
Before we dig into another example of backtracking,
I just want to mention on Friday there was some lopsidedness in some of our sections and we're very worried about those growing too large,
Like we have a section where people are attending. That means that people are assigned a flat section or getting a subpar experience.
They're not getting that one on one attention and relationship with their cell.
So we do request that you go to the section you're signed up for, and if you need to move one week,
you need to have a good reason for that and you need to email Clinton for approval.
So if it doesn't have Clinton's approval that you're attending a different section from the one you're signed up for,
you might actually not get credit for section that week That does impact your final grade in the course.
And we're doing that because we want everyone to have a really good section experience and not have any getting overcrowded.
So I just wanted to throw that out there. Mentioned that as we dig in, the problem that I have for you today,
the new problem that I want to talk about here is the zero one knapsack problem and the zero one knapsack problem says,
oh, no, I want it to show lots of information at once.
Okay, here we go. So the zero one knapsack problem says we've got some sack, some carrying sack.
You can think of it like a backpack or something like a knapsack, your sling over your shoulder that has a weight capacity.
See, I don't use any units in this lecture. You can use your favorite unit of measure kilograms lbs.
Whatever. It's the numbers that we care about here. Not so much the units in this particular problem.
So just assume we have some units defined. So we have a bunch of items that are laid out before us.
And what we want to do is each item has some weight associated with it.
And again, our knapsack only has a limited capacity in terms of its carrying weight.
So you can imagine that you have a knapsack where if you load it up with more than £of goods,
it's going to rip and we'll just lose all those goods all shattered to the ground, and we'll lose all of the treasures that we're trying to gather up.
And so the idea is you have a bunch of treasures laid out before you.
So here I've got six treasures, number two zero through five, and each of them has a weight associated with it.
So this first one has a weight of for the next month, a weight of two and 
So those are the weights of these things. And then they also have values associated with them.
Higher numbers are better. And again, whatever the units are, gold coins, dollars, whatever the case may be,
but this has a value of six, four, five, three, nine and seven four, all of those respectively.
What we want to do with the zero one knapsack problem is maximize the value of all the items that we stuffed into our knapsack.
And you might look at this and think like it's like a common approach to people trying to solve this problem.
So suppose you're robbing a vault and you've got your trusty knapsack with you,
and there are six treasures laid out in this vault, and you happen to know ahead of time what their weights and values are.
What some people will do is they'll just try to go for the treasure that or the item that actually has the highest value in it.
And so if we did that here, suppose we lifted up this treasure that would take up six units of weight,
so we would be down to four units of weight remaining that our knapsack can hold.
And then our total value so far would be that we've got nine units of value for picking up this really this, this most expensive treasure.
And then if we go to this next one over here.
So the next highest value that I see is this value seven If we go to that one, we have a value of seven, So we have a total value of so far.
And then from the four units of of weight remaining on our knapsack.
Well, this one also this weight four units. And so if we pick that up, we've got zero units remaining in our knapsack.
So if I take items four and five, the total weight is ten units, ten units.
And then the total value is I have units of treasure.
This is actually not the best way to rob this vault.
Does anyone see a more optimal By the way, I'm not promoting crime, but houses are expensive, so I don't know what your plan is for anyway.
What's the. Don't don't robot. What's the optimal solution here, though, in terms of taking items from this vault?
We don't want to take those last two items and get a total value of 
Does anyone see a more optimal solution here in the red sweater or the.
If I take the first four items. So that'll give me a weight of four, five, six, seven, eight, nine, ten.
And I have a total weight or total value of six and four is ten, five and three is eight.
So I get a total of So we could take those first four and that would certainly be this one over here.
Did anyone see anything even better than that then, taking those and getting the.
The units of treasure. Are you? Are you raising your hand or do you work here?
Yeah, I go for it. What's up with.
Wait. Say that louder. Item five has the same as.
As. As for. Yeah.
Oh, I thought you were saying item four. Yeah, item five has the same weight as item zero.
So instead of taking the first four, what I could do is take these three.
But then if I take this one instead of item zero.
So take the ones that I have highlighted and item five.
So these will get this will give me a weight of two and three is five, six, seven, eight, nine, ten.
If I take this item five down here and then when I add these up, seven and three is ten, five and four is nine.
So I could get a total of Very, very good. And it turns out that is the best that we can do in terms of taking our treasures.
So the idea of just taking the most expensive treasure is not going to always leads to the best solution with this knapsack problem.
By the way, it's called zero one knapsack, because we're making a binary decision about each of these treasures.
We either take it or we leave it behind. That's the one.
Take it or the zero leave it behind. A binary choice. There's another problem that's similar to this one called the continuous knapsack problem,
where you can take fractions of items, but with a lot of treasures, that doesn't make sense.
Like if you're stealing the Mona Lisa, you don't want to like slash the Mona Lisa and take like two thirds of it.
Then you've just destroyed like a human treasure treasurer of humanity in a great work of art.
You wouldn't take a fraction of that, but if you had, I don't know,
just like fairy dust, you would maybe take like, a fraction of the fairy dust with you.
And that might be useful to just have like a fraction of it and fill up your next sack.
So there's a different solution for the fractional knapsack problem, the continuous knapsack, if you looking at that one later.
But for the zero one, this is the best solution.
Now, another common approach that people will come up with as they try to solve this problem is they'll say,
well, wait a second, why don't we look at the ratio then the trade off between the value and the weight?
We want to maximize value and minimize weight.
So what if we did value divided by weight for each of these treasures and used
that to score the desirability of that treasure value divided by weight?
Because if values in the numerator, then the bigger it gets, the bigger that score is for that item.
And if weight is in the denominator, then the bigger that gets, the smaller the score gets for that item.
And that's what we would want is something that's really, really heavy.
Might not be as desirable as something that is very light but has the same value to it.
And so if you did that here, you could actually come up with the correct result.
So let me just punk those into a spreadsheet really quickly.
We have these weights and these values and so the weights are to and the values are 
Did you check my work as I did that because I wasn't actually looking at the screen? Did that look good?
And then when we do the value divided by weight, if we do this value divided by this weight.
And give each of those a score, then what we see in this case is this thing has actually the highest score right here, this line.
And then the next highest score from there is .
The next highest score is this . And then the.
The next I mean, the next one is a tie, actually.
But the thing is, if we've already taken three, four, five, nine units of treasure, we actually can't pick this one up.
That's too heavy for. Oh, actually wait four, five, six, seven, eight, nine.
We can't take this one either. And so we're just left with this one over here is the only one that we can take.
And so we would go by what those values are valued by the way weight ratios are.
And just pick the highest one that we can actually still pick up and fit into our knapsack.
And that would give us the correct solution.
Now, the problem with this solution is it doesn't work on all test cases that you can maybe come up with for the knapsack problem.
So one of the things that you have to be careful of just in general when you're
solving problems in computer science is that you don't just look at one test case,
come up with what feels like a really clever solution and then be like, Boom, I've solved this problem.
You have to convince yourself and logic through the solution to convince yourself that this is going to work in all cases.
And if you tried to do that in this with this particular approach to this problem,
you just wouldn't be able to prove that it works in all cases because it doesn't.
And so here's actually an example, an input test case where this solution would not work if we did that.
So here's just another test case. I have other weights here and I have other values here.
And I've rigged this so that when I do value divided by weight,
this one looks like it has the highest score because I have like a really high value compared to all of the other ones.
And again, if we have a knapsack of capacity ten, if we go for this one and say, Oh, this score,
this value divided by weight is the highest of the scores I see it's higher than it's higher than two.
If we do that, then we would take this item, this item zero, and then our knapsack capacity.
We'd have two units left in it because this weighs eight units over here.
And then we couldn't pick up any of these. We would just be forced to take this one.
And so if we take this one and this one, we end up with units of treasure, and then our knapsack has one unit of capacity left.
But we can't pick any of these up with it. But if you instead went for things that had lower scores over here,
like if you forewent this score that looks really appealing and high and instead went with these items here,
we would have the three plus three plus three plus one would give us a total weight of ten.
And when you add all of these up over here, you get a total of this.
This one initially was giving us If you add these up, you get and then add this two and you get a total of 
That's better than that for getting all of these is better than the 
So none of these approaches are working.
Take the most valuable thing, not working, take the the highest thing that you can take in terms of those value divided by weight ratios not working.
And so this is where I'm going to just turn to backtracking to help us and say let's just look at these different scenarios and see which one is best.
And to solve this problem, then I'm going to appeal to the idea that we saw on on Friday of subset generation where you can imagine that we have
these five items or the six items in the previous test case that are laid out before us on some sort of buffet.
And I'm going to just make a binary choice about each of those items, whether to put it in my knapsack or not.
So this first item that I have laid out, I either take it with me or I don't.
And I could write a recursive function that actually makes two recursive calls.
One that says, Hey, take it with me and see what result I get as I then go down and make choices about other treasures.
Now, of course, if I take that with me, that diminishes the capacity of my knapsack.
And so when I get to other treasures, I might be forced to leave those behind because they're too heavy.
But I have some value because I took this thing with me. Or if I leave this first treasure behind and move on to the other treasures,
I don't have the value associated with that treasure, but I have lots of capacity in my knapsack.
So if I see other things come up,
I might be able to take those things that I wouldn't have been able to take in if I had taken that first treasure with me.
So I'll go down the line and just make a binary choice about each thing. I either take it or I don't.
And that's how we generated subsets on Friday.
Given a set of elements, I said, Well, to generate subsets, you look at each one and you either put it in your set or you don't.
And that gave rise to all of the possible subsets. So this problem ends up looking a lot like subset generation.
And I kind of have like a two sided admonition for you.
One is on Friday, I mentioned we've we've seen a few what I call just very common paradigms.
We saw we've seen sequence generation like coin flipping or rolling some dice.
We've seen permutations, jumbling elements of a set or jumbling elements of a vector and seeing the different orders.
And we've seen subset generation. What are all the different subsets we can take in or generate in terms of taking items or leaving items behind?
You want to be familiar with those three paradigms, especially if you're heading into a tech interview with a big tech company.
They'll often want you to be able to throw down the code for something like that and also identify a problem like that in disguise.
And so knapsack is kind of a problem like that in disguise.
You can solve it by doing a subset generation saying, Well, what are all of the possible ways I could select elements from this?
And then which of those gives me the best overall weight? So that's like one admonition is you need to be on the lookout for those patterns.
My other admonition, though, is you can't just be on the lookout for those patterns.
Sometimes you encounter a recursive problem and sure, it has a base case and that looks familiar to us when you're coding up the solution.
But a lot of recursive solutions that we write up for different problems just
don't really look or match a pattern for something that we've seen exactly before.
And so on the one hand, it's important to identify those patterns.
On the other, it's important when you're trying to if you have a problem, when you're trying to,
like, fit it into some mold where you like, it feels like this thing, but it's not quite working.
Sometimes you need to abandon that paradigm and just accept like, this is a unique problem and I need to think about the functional decomposition,
the recursive, like the recursive decomposition and what the base case is going to be, and so on and so forth.
So I want to start coding up a solution to this problem. Let's just dig in here.
So this is going to be knapsack.
And I want to throw down those test cases that I just had on the screen.
So let me get this one going here.
And I just want to put together we have these provided tests. So let me include the simple test framework.
This is include simple tests like this and create some tests.
So this is going to be provided test. And I'll not really worry about what I'm going to call that thing.
Right now. I want to create a vector of weight.
So these were all just integers that I had over here, weights equals,
and I'll fill that in a second and then a vector of values, and I'll fill that in a second.
I'll try to spell vector correctly. I will.
My goal is to get this to compile and run, so I'll include vector that H, and then I will run my knapsack function.
So I'm going to do knapsack and I'll pass it.
The weights and the values and the capacity of my knapsack, which initially was saying like,
let's just use ten for the capacity equals ten, and then I'll expect that this is equal for this particular test case.
We already did one where the answer was going to be and then I'll just copy and paste this for next.
We have that other test case over there. So let me move this to the side and come back over here and just copy this test case over.
So we had the weights over here were the values were 
And the result down there was a 
And then for this one over here we had weights of eight, three, three, three, one, and we had values of and two.
And the result that we wanted out of this one with our knapsack of capacity ten we saw that we can get out of that.
So these are just the test cases over here. So I'm doing some test driven development, right?
The idea of I've come up with some test cases. I know what my expected results are before I've even recoded my function.
And so I can as I start writing my function, I have something waiting for me that will tell me whether I've got it kind of working so far.
I don't like this setup at all for how these test cases are done.
And so I have kind of a it's maybe a philosophical objection, but we're going to have to deal with it concretely.
The philosophical objection is I'm passing these two vectors in, and what's what's represented in these vectors is like the first item.
This is its weight, this is its value. My last item, this is its weight.
This is its value. I have the weights and values stored here in such a way that the indices align.
So like for item three, if you want to know its weight and value, you go to index three in the weights vector and index three in the values vector.
So I have these two separate vectors. They're stored separately in memory.
They're passed a separate arguments that rely on this idea that the add the element
to index three in both vectors is giving me information about the same item.
Well, an issue that could arise here is what if I pass these vectors into a function and somebody sorts the first vector?
Well, then the weights and the values from vector to vector are all jumbled up and no longer match one another.
And that seems like something that someone could reasonably try to do is try to sort one of these vectors.
So what I want to do instead is create a single data type that packages a weight and a value together
and just have that single data type in a single vector as opposed to having two different vectors,
and I risk one getting out of order. And then there's a mismatch going on there.
And the constructs that C++ has that allows us to package related pieces of
information together and pass them as a single variable is this thing called a struct.
So struct is used to package together related pieces of information in a single kind of new.
You can think of this as creating a new data type and the syntax for creating a struct.
I'm going to create a new data type that contains pieces of information within it.
So what I want to do is create a treasure data type and each treasure will have a value associated with it and a weight associated with it.
So the syntax for this is you do struct and then the new type name or struct name and then curly braces,
and then you give a data type and a variable name and you just keep on doing that for all of
the different variables that you want to have packaged together in this single data type.
And then a key component here to structs that I see people missing a lot on exams and things like that is this is not a function definition.
This is actually just a statement about a creation of something. And so it does need of a semicolon down here after these curly braces.
So that's the syntax. Here's a concrete example.
I want to create a treasure struct, so let me do struct treasure.
And it's really common to put an underscore t at the end of a struct name to indicate that you've created a new data type here.
This isn't a variable name, it's a data type or a capital T.
If you're using camel case instead of underscores and we are using camel case in this class, so do capital T.
So this is creating a new data type called treasure. T So Treasure T is a data type like info double or char and then inside it.
I declare what I call the fields or the members. So let me put that here.
These are the fields or members of my struct.
And what I want each treasure to have is a weight. And a value like this.
So that's my basic treasure structure. Now as to fields in it, a weight and a value.
So if I want to create a vector of these, I can now do that.
So let me actually create a vector of treasures. So I'll do vector of type treasure.
This is a new type, just like I mentioned, like info char.
These are my treasures and I'll do create treasure vector and pass it my weights and my values.
And it's going to return to me a single vector and it will pass that one vector and it will have at every index,
bundled together, kind of paired together those weights and those values.
These will be my treasures like this. So let me write a function that does that.
This is going to be my my vector. I have my vector of type treasure T and this is create treasure vector.
It takes a vector of integers by reference because I want to do this speedily.
And a vector of integers again by reference, because I want to not waste time and space copying those over in here.
And then what I want to do is just create a new treasure vector and add these treasures one by one.
So check this out. I'll do a vector of type treasure t like this.
And just create like a treasure of treasure vector V, and then I'll return this treasure vector v.
So what I want to do is create a new treasure and put inside it.
The the weights and values associated with each of these things.
And so here's how.
I mean, there are a few different ways I could do that. Let me just loop through these vectors.
So for inter equals zero, I is less than wait start size, which I expected to be equal to the value start size I plus.
Plus I'll just create a new treasure. I'll call it treasure T my treasure equals.
All right. You can just create a new treasure like this. Let me show you kind of two ways to access these fields.
So what I've done here on line is treasure key is the data type, and my treasure is the variable.
So this is kind of like it. I, I is the integer variable here.
My treasure is the treasure t variable to go inside there and access the weight and the value.
We do this, we do my treasure and then apply a dot to it.
And you see, when I do the dot, I get this menu that I can access the value field or the wheat field.
So my treasure is a variable. You can think of it as like just a little bundle of goodies.
It's a bundle of two variables that are inside it.
So my treasure is a variable, and inside it are two variables.
And so to set the value equal to values sub I,
and then I'll do my treasure dot weight and I'll set that equal to weights sub I and then I'll do the treasure vector.
I'll just add this particular treasure to it. So that goes in and just adds that treasure over and over.
Let me get rid of this up here. We're just talking about the structure and whatnot.
So this, this will create my vector for me. The word vector is is underlined in red right now at the top of this function on line 
Does anyone see the error that's leading to that? And it's actually related to something that I kind of like a rule that I just established.
I don't know if I want to give too much away a rule that I just establish for when we're creating structs.
There's something I've done wrong. Yeah. Where you have to put the Oh yeah.
What were you going to say in the in the ten sweater? The same thing.
Okay, both of you. Okay, great. The story there is I'm just bad at pointing in a in a manner that is discernible.
Yeah. So there needs to be a struct at the end of the semicolon. At the end of the structure definition.
Very good. So that was kind of inhibiting it from figuring. Like, it was just like, What are you doing?
This one thing is bleeding into the next. So this creates a vector of treasurers.
I'm just creating a bunch of treasurers like this. You can also do this with structs.
In C++, you can use curly brace notation here and just list out with commas what you want the different fields to be set to.
So the first field in the structure is the weight. So that would set that field to this weight here.
And the second field is a value. So that would set that to that value over there like that.
So you could do either one of those. I'll maybe just leave that like this and then let me maybe come down here and show that this is a thing.
So for entry equals zero is less than Treasurer's dot size I plus plus and I'll just loop through and I'll do C out.
Oh, this is actually kind of a pain I want to do kind of like pairs like this for each treasure.
But then I need to like blow all of this up. Like this needs to be treasures sub I'd weed and then here I need to do a comma and a space.
And then this needs to be another thing over here. Treasures treasure sub I value like this.
I just want to show you. Let me comment this line out over here.
I just want to show you that these are actually what this one is not going to do anything.
I just want to show you that I actually created a vector of treasures over here. So let me do this.
Let me do run simple tests. All tests and want to give this a compile and run.
Oh no. I would expected a hoodie here before the birdie bear my treasure.
Oh, someone forgot to put a semicolon there. How embarrassing. Okay.
And so you see that it's got these pairs that it's printing. Those did, in fact, get into this vector.
The four six is up here on this line right there like that. Okay. So let's write this function now.
It's just like printing out and showing that there's a thing there.
And by the way, part of the reason I'm showing that to you is because in the assignment that we're looking for you tonight,
I know you're excited about just the nonstop barrage of assignments in this class and that turn where you're just like,
there's never a day where you don't have something fun to work on.
We've worked very hard to make this just a delightful playground of learning.
I know that you love it. So in your assignment that unlocks tonight, there is actually a structure that you'll have to play with.
And I wanted you to have seen that in class already. Ooh, let's start writing this function.
So let's do the knapsack function. So I'm going to do here. It's knapsack takes a vector of treasure t like this by reference because I want
it to be super efficient and some initial capacity associated with this knapsack.
And then I just want to play with the idea of adding stuff to the knapsack, taking things away from the knapsack,
adding things to our current value, taking away from our capacity and going and going and going is kind of the idea here.
So to kick this idea off, one of the things is I have this initial capacity and I have some buffet of treasures to choose from.
What I want to do is work my way through this treasures array and and pick treasures out and either take them or not.
I also need some base cases for this recursive function.
Does anyone have any thoughts on things like what are some things that I could pass into this function where you're like,
Oh, if such and such happens,
I know what the maximum value is that you can take as you're trying to rob the vault and you have this capacity in your knapsack.
What are some thoughts that you have about base cases here, situations where you're like, Oh, I don't even need to do any looping or anything.
Like, I mean, there shouldn't be any looping. I don't need to make any recursive calls.
Where are you thoughts about situations that could be passed in where you're like, I know immediately what the max value is.
I can work. Yeah, very, very good.
So we'll say like if treasure's size equals zero, or if you could say like you could say if treasure's is empty is another way to do that.
Well, then there's nothing here, so there's no value to be gained. Perfect.
That's a really, really great test case. If we've run out of treasures, then there's nothing to be done here.
And I will, in fact, to do that, we will, in fact, remove treasures from this and whittle down to this base case.
I'll make decisions about the treasures as I go. Any other considerations about the base case?
It's other situations that might happen. Yeah. And what's your name, by the way?
Michelle. Okay. Yeah. Go for me. Yeah, the capacity is equal to zero.
Then there's. I can't take anything. Assuming that everything has a weight, a nonzero or non-negative.
Assume that everything has a positive weight here. Right.
So if capacity is equal to zero, then we'll go ahead and say you can't lift anything up if the capacity of the knapsack has reached zero.
Okay, So those are some considerations there in terms of base cases.
Otherwise, what I want to do is exactly the thing that I said that I wanted to do,
which is make achoice about each of these items as I go down the line.
So I could take an item out of the vector, I could do treasure.
T this one. You know, I like to use the name this one to represent the one item that I'm playing with at this time.
I could say from treasurers, let's remove item zero.
Ooh, treasures like this. Remove item zero. Now I've got that item, and then I could make my two recursive calls.
I could do this, I could do the knapsack and I've taken away from the treasures.
So that's I've already removed. So this gives me a modified two treasures parameter.
And then let's see. So we either take it.
Or we don't take it. If I take it, let me call this.
This is the value that I get with this item.
If I decide to go through the vault and take this item with me, then I want to do knapsack with that treasure removed.
And again, I have removed the treasure here. So this has that treasure removed.
And then what do I do to the capacity here?
If I have ticket, if I've picked up this particular item that I'm calling this one, what do I need to do to the capacity?
Can someone raise their hand? And you know what? What's your name, by the way? Julius?
Yeah, the one that I just picked up. It's. Wait. I need to remove that from my capacity because I've lifted that up and put it into my knapsack.
What else do I need to change about line to give me the value, the overall bar.
So I'm lifting this thing up and I'm saying now that I've made a choice to take this thing,
please recursively figure out with all the remaining elements what's the best value that I can get from all those elements.
So this will return to me the best value that it can get from just considering the rest of
all of those elements having made the choice of this element of this element zero already.
What else do I need to take into account on this line though? Michelle.
The amount I got. What? Yeah.
Which is this one that I just picked up. And so it needs to take into account the value of this one that I picked up.
So this will figure out for me. I pick this thing up and the recursive call figures out what's the value I get from those items over there.
But I need to add to that the value of actually taking this item.
This one, I took it and put it in my knapsack. So take its value and add it to what you get from looking at the rest of those items over there.
So picking the item up increases the value and it diminishes the capacity of the knapsack.
This is this is the taking it. Otherwise I can go without it.
So let's take a look at what happens if I leave this thing behind.
Actually, let me just copy and paste this line and ask you,
what should I change about this line in order to get what the value is if I leave this behind?
And then, by the way, let me say this before we even finished that line.
I know I'm going to get with and without the value that I get with taking this thing and the max value I can get without taking this thing.
What should I do to those two numbers to figure out the overall solution to the knapsack problem?
Yeah. Take the max of those. So I'll just return Max of with versus without like that.
So whichever those of those is bigger, I'm going to try leaving it behind to see if maybe I get greater treasures later.
And I'll try taking it and see if maybe that was actually a really great thing to take with me.
And then whichever those is greater, that'll be my final solution. What do I need to change about line ?
This line here. This is just a copy of the width line.
So what do I need to change about it in order to leave this one behind?
In the pink in the picture over here. Say it louder for me, please.
Remove this one value because I didn't pick this thing up and because I didn't pick this thing up,
I didn't get the value push associated with that thing.
Is there anything else that needs to change about this line if I'm leaving that one behind?
Go for it. It's working. Yeah. If I didn't pick up this one, then that means I did not diminish the capacity of my knapsack.
So I neither gained its value, nor did I suffer the penalty of picking it up and diminishing the capacity of my knapsack.
So those are the two recursive calls here. Those are the two different situations.
This is terrible right here. I keep doing this just because I think that it's kind of like if you have a buffet of items laid out before you,
I think it kind of makes sense to look at that first one and make a choice.
But remember, I keep saying removing from position zero in a vector is a slow operation.
If I take it out every element after it has to scoot over one by one.
Where should I take from instead? Everyone the very end.
And so I'll do treasures that size minus one. That's the index of the last element in this vector.
And by the way. Um, one of the things that I need to worry about is this.
So I'm making recursive calls where I'm taking elements out of my vector and I'm making choices over here.
And one of the things that I'm going to do is backtrack eventually and come back up here and say,
What if I left that element behind instead of taking it?
And when I come over here. So there's that very first element that I'm looking at now.
It's the very last moment in the vector. If I remove it from my vector and make all my recursive calls,
eventually I'm going to come back up here and I want to look at what happens if I made recursive calls
down this side of that recursive call tree where it was leaving it behind and so taking it with me.
And the problem is, with each recursive call, I remove an element from my vector.
Then when I get back up here, the vector is empty. And so when I make all these other recursive calls, these other recursive calls are like, Dude,
you emptied out the vector with the first chain of recursive calls that you made empty to the vector.
And now all the other recursive calls that I make are just looking at an empty vector and they're like, There's nothing here.
What are we going to do? So what was the three word paradigm or the three word phrase that I had to describe the backtracking paradigm on Friday.
It was doing that that you can shout it out if you remember.
Choose, explore and choose. So here I've chosen what to do with this item.
And actually I'm making two choices about it.
Either I take it or I don't, but I'm choosing an item to play with, and then I explore with these two recursive calls.
I now need to untie shoes and to choose. I took an element off the end of the vector.
Let me put it back on the end of the vector so that when I make my returns and go to do other recursive calls,
that thing is hanging out at the end of that vector.
So let me do treasures dot add and I'll just this one, I'll add it back to that list of those treasures over there.
So pick out a treasure, either take it or don't, and then put it back into your vector and return.
And this also, by the way, satisfies that kind of restriction or that principle that I mentioned on Friday of if someone passes you an input and says,
please solve this problem for me, what you don't want to do is just like wreck their input, especially they're passing it by reference.
You want to just like wreck their input and be like, Here, I got you the answer. But also I destroyed your treasures along the way.
They're all they let you into their vault and they're like, What's the maximum treasure value that I could get out of this?
And you give them the answer, but they go to their vaults and their vault is empty. You've robbed them and you're on the flight to Paris already.
So that's not considered poor form. And here we're adding stuff back to the vector.
So it should still, you know, a better test case would actually after we do this,
it would then check if the vector still had the same contents as before in the same order that we didn't sort that vector,
that we didn't remove things from the vector, add things to the vector and so on and so forth.
Let's see what happens over here. Oh no, it's super unhappy.
It's came up with a instead of the BR So one of the things that's happening here, we're adding this one,
the max with without this actually isn't even the knapsack solution we discussed.
I'm going down and by the way, did you all see that like it is passing one test case but it's failing this first test case over here.
So this also highlights the importance of making multiple test case. That's right.
If we only had the other one, we'd be like, Oh, this works and we would move on.
I'm going down the line and each item I'm saying either take it or leave it behind.
What did I not code up?
That was actually something that I articulated as I was describing that process initially as we were talking about the solution.
Yeah, go for the capacity of the item is greater than the capacity that you have left.
Then you can't pick. Yeah. If the item weighs more than the capacity that I have left, I cannot take it.
This is not an option. I need to check what is the weight of this item and does my capacity satisfy or cannot hold that?
So check this out. This is like if this one dot weight is less than or equal to my capacity, then sure, try either taking it or not taking it.
You can you can do that. You can do either of those.
That's a possibility there.
Otherwise, if this thing is so happy that I can't pick it up, in other words, the weight is not less than or equal to my capacity.
The weight exceeds my capacity. I must leave it behind.
Well, then I can only do this one over here. The Don't take it.
If the if the weight is something I can carry, then yeah, I can either take it or not.
But if I can't even carry this, then I have to not take it. And so I'll do maybe something like this I could do.
Result equals. Well, this is just result at this point.
Result equals this. I guess in order to make this work, I have a couple of options.
I can declare results up here like that. And then here I can say result equals the max of with or without.
That's one possibility here to get my result. And I'm declaring it up here because if I declare result inside one of these code blocks,
then I can't return that down here outside of those code blocks and also declare results up here.
And if I go in here, it's the max of those two. Otherwise, if I can't look that thing up, the result is just this.
And then when I get down here, I'll just return the results like that.
And if I give it a compile and run. Oh my gosh. Amazing.
It's now passing all of those test cases. Everything. There was much rejoicing in the kingdom and everything is great.
What questions do you have about that?
How many of you feel like maybe it's not like crystal clear, but you're like, Yeah, I'm following the general premise here and like,
I could disentangle this as I was seeing lots of hands go up there, disentangle this as I play with the notes later.
So that's that's one possibility there. Were there any questions about this before?
I because what I have planned is I have two more solutions to this. I just want to play and tweak this solution.
Then let's take a look at some alternative approaches.
So one of the things that's happening with this approach here.
Oh, which one do I want to do? They're like a few different ways to do this.
I want to I want to show you two different approaches to this. So sometimes people will say,
some people don't like doing this if check before making recursive calls and they'll they'll call this maybe arm's length recursion.
And they say, well, I'm going to keep that call at arm's length,
cause I'm only going to do it if this condition is met, then I'll make that recursive call.
Otherwise, I don't want to make that recursive call. This with recursive call.
I want to do I want to do just the other one.
Oh, by the way, I'm like, maybe this is like, feels bad to me the way that this is all partitioned out like this.
I guess this is. I'll just leave it like this. Let me get rid of this, though, because I want you to be able to see like more code at once.
And so those are the with and without those I mean, the names with and without, I think, kind of indicate what's going on there.
I just want to be able to get like a little bit more code on the screen at this moment.
So sometimes what people will say is with this arm's length recursion, some people try to avoid that.
So we could modify this, we could modify this a solution so that it just always makes these calls and basically get rid of this check right here.
And if I get rid of that gateway, that check before making my recursive call,
that means that it needs to happen when I make the recursive call as a base case.
So what I'm saying here is I am going to actually allow myself to make recursive calls where I hope this works.
The max of with and without. I'm going to. Oh, no.
Oh no. I just lost the OC. Sorry with the within with out here.
So I'll allow myself to make that call.
Now the problem with that is on line if that thing was too heavy to to pick up, I'm getting a misleading result.
I need this call to somehow counteract the fact that I was saying that I took this value over here.
So this call, like if I pick something up that I wasn't allowed to pick up and it had a value of five,
I need my recursive call kind of in this case to return a negative five to say that thing of wait five that you just picked up.
Well, you weren't allowed or that thing of value five that you just picked up. It was so heavy you weren't allowed to pick it up.
So let me return a negative five to cancel out the fact that you picked it up.
The problem with that is this recursive call has no indication of what the value was of the item that I just picked up.
So that recursive call is actually incapable of negating the fact that I might have picked up something that was too heavy.
So this requires a bit of a rewrite of the function in terms of of what it's doing.
Oh, and by the way, one of the I just removed that condition.
So that becomes a new base case I mentioned, which is if this item that I'm considering taking.
So let me call that treasure. This one, we're saying that if that item is so if there's stuff here, I want to look at that particular treasure.
So let me cut this thing up here and move it up here.
If that treasure that I'm considering is too heavy, then I'm not going to allow myself to pick that up.
So I could say, like, if. If this one that I just tried to pick up is too heavy, don't allow myself to pick that thing up.
In order to do this, though, what I need to do is,
is in order to empower this thing to counteract the fact that I might pick something up that's too heavy.
I need to actually pass it a third parameter, or this is going to be the value so far of all the treasure that we have accumulated.
So now that I have a third parameter there, I also need a wrapper function for this.
Let me do it. Knapsack. It's taking my vector of treasures.
This is a treasure t vector like this. These are my treasures, a capacity.
And that's all that I'm passing to it from this test cases.
And what I want to do then is return and call this knapsack function like this knapsack with this treasure specter and this capacity.
And I'll say initially that the value that I have so far as I kick this all off, the value of this is zero.
I've picked nothing up so far, and so I've got a value so far of zero.
Otherwise what I'm going to do this, this then if I want to pick something up,
I will take this and just add that to my parameter, this third parameter that tells me what my value is so far.
I'll do value so far. And I'll add to that the new the value of the new thing that I picked up.
Otherwise I'll just pass that the value so far and that thing doesn't change.
So the idea is this on line I'm trying to pick a thing up and if it's too heavy, I'm just going to pick it up anyway.
And if it's too heavy, two things happen. One, what it's like I'm adding something to the value here,
and so I need this recursive call to come back at me and say, No, you're actually not allowed to do that.
That was a bad idea. But also, if this thing was too heavy, then this capacity becomes negative.
And so I could add that as a check up here, I could see if my capacity has actually become less than zero.
This move was not possible. I'll just return a zero to actually zero out this value so far that I was that I was trying to add to.
I'll just return to zero and say, no, that move was actually totally illegal.
So don't even consider that. Well, if I zero this out, then that's great.
If this thing was too heavy, this becomes zero. And so this is the only thing that has a non-zero value potentially.
And when I do the max of the two, this is just zero. So I'm definitely going to go with the without thing.
So this simulates what I had before of if the thing was too heavy, I just wanted to look at the call without,
well, right now, if this thing is too heavy, the weight becomes the capacity becomes negative.
My new base case causes me to return zero. This becomes a zero.
And so I'm still I'm returning the max of zero versus just this thing. So this thing is the thing that's going to actually get returned over here.
So that capacity like that, so this can actually go down here at this point.
The other thing that I need to change that is if my treasures are empty, I don't want to return zero.
I want to return the value that I've garnered so far. And then if my capacity is zero, same thing.
I want to return the values that I've gathered up so far with that thing.
And let's see the knapsack that I do.
One of the dangerous things about modifying a recursive function parameter that's parameters is like, do you have all of your recursive calls?
I added a third parameter. Okay, So I updated all of them and added that third parameter.
Oh my gosh, Hooray. So this version is working also. So this is a slight twist.
I personally think this one is a little bit harder to to process and see what's going on.
I don't know. For some of you, you might be looking at this. Oh, yeah, this one actually makes more sense.
We make the two calls over here. I think it makes a little bit more sense to say, can I lift this or not?
Because that's kind of like the human thing that you would do if you were going down this line.
You'd say, Well, I can't lift that, so just leave it behind. And so there's really only this one case, the case where I've left it behind.
This one I think is quite slippery. And I'll leave that to you to kind of trace through that one.
I want to write a final version of this that uses and this next one is not so bad.
It relies on this. The the paradigm that I used for the second version of our recursive permutation function.
And this is actually a really common paradigm with recursion, which is instead of modifying the vector,
adding and removing elements from a vector, just leave the vector alone.
And so we'll actually maybe save some runtime here by not adding and removing elements from a vector
and instead introduce a variable K that just tells you how far into the vector you've gotten.
So instead of like removing element zero and then going to element the new element zero with your recursive call,
we could just leave the vector the same and then just move on to element one and then leave the vector
the same and move on to element two and leave the vector the same and move on to element three.
And as you move on to each of those new elements, make that binary choice.
I'm either going to include this element or not.
So here's kind of the third modification I'm going to introduce here actually an independent variable.
K So just call this K and K starts at zero to indicate that.
I want to start by evaluating in my vector what is the treasure index zero.
Do I take that treasure or not? And K actually is going to serve double duty.
So like when K becomes say two, that means I'm going to go to index two in my treasures vector.
And determine, am I going to take the Treasury index, too or not?
But that also means that if I'm at index two, I've made a decision about what to do at index one and what to do at index zero.
There are two elements over here. One and zero. If K is equal to two, that not only means I'm at index two, my vector,
it's going to be that I've made a decision about two elements that have already been processed.
So I've left two elements behind. So kind of two different ways of looking at K, It's how many elements I've already processed.
Initially, when I kick this off, I processed zero elements and it's also the index I want to go do to process the next element.
The first element that I go to is that index zero.
So let me get rid of this thing over here and instead of this then emptying out the vector because the vector never has anything removed from it.
What I want to do is keep going until K falls off and it's no longer a valid index.
And so that's when K is equal to treasurers. Dot size.
Remember, treasure size minus one is the last valid index for this thing.
So if there's no treasure there, just go ahead and return zero. If there's no capacity left, just go ahead and return zero.
Otherwise, what I want to do is pick up a treasure. Oh, well, now I'm back to this other thing of.
I need to say, if this one dot weight is less than or equal to my capacity, then I can actually pick it up like this.
Let me return. This is my result over here. And then the result is the max of those two, with or without.
And then otherwise, I need to just do this one over here.
This is the version that we had before, basically. Otherwise, my result is just this knapsack call over here,
except what I'm always doing is going to index K, So this is going to be treasures sub K like this.
That's the one that I'm on. I'm not actually removing it from my vector.
I don't actually need to add it back to my vector and once I have my result, I just return my result.
So all I really need to do is fix up these recursive calls.
I pass it the treasures array. I do this, I'm not passing it the value so far.
I do need to take this value here instead of passing this the value k recursively.
This is where I take this thing. So let me add this over there. Like that, instead of adding that thing like this is right, leave it behind.
What do I need to do to my K parameter then to get this to march forward through my vector?
Yeah, just add one to it. And so if I add one over here, this has make my recursive call where I've moved on to the next element in the vector.
Then when I make that recursive call, that's the index of this one, this treasure that I will play with and make that consideration about.
Now, I'm a little nervous because I modified all of this base cases in place and actually it works.
Okay. I was like, I'm sure that I missed something here that actually did the right thing.
Let me show you this last thing just really quickly. So there's this problem.
Well, I don't have time for it. Remind me to talk about Queen's on Wednesday.
I'll show you a backtracking thing with Queen's. And that is what is.
Thanks for being here. I'll see you on Wednesday.
How are you? Oh.
All righty. Hello.
Hello. Welcome. Happy Wednesday, everyone. Everybody, let's go ahead and begin.
I know the. Let's go ahead and begin.
All right. So we're shifting gears a bit here.
Be sure that you check out my announcement that I posted in on Ed about what's going on for this next week.
Of course, you have your exam next Thursday. I'm going to work on posting some exam related materials tonight or tomorrow, some time.
So hopefully those will be released very soon. And that's kind of where we are.
But we're shifting gears today and talking about I mean, this is another big fundamental paradigm shift in terms of what we're doing in the course.
So we started talking about C++ and acting as consumers of already implemented ADT from the Stanford C++ Library.
Then we had our first paradigm shift into recursion.
This is our second big paradigm shift of the quarter, where we're now actually going into object oriented programing.
And instead of acting as consumers of years that have already been implemented for us,
we're going to talk about how are those implemented and look behind the scenes so that we can create new
editors of our own and implement abstractions that we come up with to make our programing tasks easier.
So we're shifting today from this kind of client side consumer approach to things exist.
We're just using them to. Let's take a look at the implementation details and create those things.
And for that, what we're going to start with today is talking about what object oriented programing is or for short.
I don't just want to keep kind of a disclaimer. I'm going to give you kind of a light introduction to OOP.
I'm going to give you just enough knowledge to play with these concepts and implement interesting things.
There's a whole wide world of object oriented programing that we're not covering in this class,
so you might want to do a deep dive on that some time on your own after you get the intro from this class.
But just want to be clear about that.
Like this isn't designed to this segment of the course, isn't designed to like make you experts at object oriented programing.
There's a whole lot more to it to dig into what object oriented programing is.
I want to talk a little bit about classes. Classes are one of the fundamental driving things behind object oriented programing.
A class is a way of bundling together related pieces of data and functionality, so actual functions that operate on that data.
And where have we seen something like that already in C++ where you can bundle together?
Related goodies? We saw structs, Yeah.
So a class is kind of an evolution of a struct. A struct is all about bundling together related pieces of data.
And when object oriented programing came along and built, like when we built on C and created C++,
we that idea of the struct evolved into a class where the structs and C initially just bundles together really two pieces of data.
And in classes what we actually do is we bundle together related pieces of data and the functions that operate on them.
So you've already seen this actually, like when I do something like this in class, like vector,
int v vector is a class here in this class is bundled together, some information, some data.
So all the elements that go into your vector, those are part of the data behind the scenes in this class.
The other thing that's going on behind the scenes there is the vector keeps track of the size of this,
of this vector, how many elements you've put into that. So that's maybe another like an integer variable that's stored behind the scenes there.
So we have all this data that the vector class is keeping track of that represents what's happening in,
in that vector that we refer to, that is the state of the vector.
But then there's also functionality built into that. You know that if you do like v dot add, if I actually go up here and include vector H,
you know that if you do v dot ad, there's this function or I sometimes refer to this functions as methods.
There are all these functions or methods built into V those.
That's the functionality that's bundled together with the data that's, that's inside this class.
So this class is bundling together data and functions that operate on that data.
And, and again, you've used those all quarter long like vectors, a class A stack as a class Q grid, the map,
the set that you've played with, those are all classes that are bundling together data and functionality that's implemented for you there.
So that's really what a class is. It's bundling together, those things. Now when this idea came along, this was a fundamental shift in the field.
So before, just like we're having a paradigm shifts today in terms of the classes shifting gears, historically,
the advent of object oriented programing and the arrival of this idea on the scene represented a big shift in what programing looked like.
So in old languages like C, if you wanted to create something like a vector,
this idea of a collection of elements that could expand and you can add things to it,
what you would typically do is create a struct, so maybe a vector type that had some data in it.
And I'm not going to define all of that data there. But then if you wanted to add something to your vector,
you would separately write an ADD function and it wouldn't be inside this vector type over here.
It would exist separate from that vector type.
And when you called it, what you would do is you would pass it the vector that you wanted to operate on like this,
and then maybe like some data that you wanted to add to it.
So the, the container that you wanted to operate on was actually an argument to the function that operated on that container.
That's very different from what we see down here where this function is built into.
The container. Are you following that idea? The idea that you can have a function that you pass a container into?
That's very different from having the function exist kind of within that container.
It's part and parcel with that container.
So this was a big shift in terms of what coding looked like historically when we moved to object oriented programing.
And the neat thing about the object oriented programing paradigm is it really mirrors how we think about objects in the real world.
So the advent of O.P. kind of brought the practice of coding into alignment with our view of objects in the natural world.
For example, when I get up in the morning and I'm rushing to get to campus on time and I take the elevator in my building,
when I step into my elevator and I press a button to go to another floor,
I don't think of that as like a go to floor function that I'm passing the elevator into as as an argument to that function.
I think of that button and the functionality of going to another floor as
something that is built into the idea or fundamental identity of the elevator.
It is part of the elevator, not a separate thing that I'm passing the elevator into.
So that functionality is unified and part of the identity of that elevator and what it is and how it exists in the real world.
And that's what object oriented programing is all about,
is kind of breaking down the wall that we used to have between data and functions and bringing them together
and seeing like some entities actually have data and functionality as just part of their identity.
And so that's what the object oriented programing paradigm is all about.
You can think of these. So I mentioned the vector here as a class.
You can also think of the class as a blueprint. So if I create v one and v two, what I'm doing here is I'm actually creating two.
Let me give you some terminology here.
So I'm creating two instances of the vector class or another way to state that is I'm instantiating the vector class.
So V one and V two are not classes, they're instances of the vector class.
Or sometimes what I'll say is they're objects. So these are the objects in object oriented programing.
When you have a class and you actually create an instance of that class like vvyou create a variable of that type, you're creating an object.
So it's a v, Vis an object, V two is an object. These are instances of the vector class, and we kind of do that in the real world too.
So suppose you are building a house, which and this is very hypothetical because as I mentioned, houses are very expensive.
Most of us will never afford one. It's over for us. I don't know what your plan is.
Oh, I guess that's what I'm studying. Yes. Okay, good. Good plan. You'll probably be okay.
I worry about the abstract poetry majors. Maybe they have a trust fund. I don't know.
The no fence. If you're an abstract poetry major, you're great. Come talk to me.
I want to know why you're here and what your plan is in life.
So suppose you're building a house, and we have this Munro model of a house,
and someone takes and builds their constructing a neighborhood, a cookie cutter neighborhood,
because developers have realized like, Oh, we can capitalize on the fact that everyone needs housing and drive up the prices and take your money.
And they have a lot of money so they can make that happen. And anyway, so that's our situation right now.
So we have this Munro model and we want to build a neighborhood and maybe we make multiple instances of that Munro model, that house.
So if we build a version of the Munro house over here, that Munro model,
we would say that's an instance of the Munro model and then someone else builds that model.
That's another instance of the Munro model. And so similarly that's happening here.
The vector is kind of a blueprint for how you create a vector and then Vand Vare instances of that class.
And similarly, if you built two houses from that Munro model,
what you would have is two separate objects in the real world and they maintain their own internal state, right?
Like just because two houses were built using the Munro model doesn't mean that
if you put a teacup in this house that also appears in this house over here,
they are separate entities just like V one and V two are separate entities.
So when we create an instance of a class, they each maintain their own internal state.
And here we have like VIf that were a house, it's kind of like decorated with integers and this other house V two it's decorated with strings.
So the class is not only a way of bundling data and functions together, it's also a blueprint for how that thing is created when we instantiate it.
So this is a lot of a lot of the language over here for for these particular things.
Now in terms of like why classes? Like why, why would we do something like this?
Why would we create new classes? Why not just use the goodies that we already have access to?
And we've already seen where creating classes can be really useful.
We saw this actually when we talked about stacks way back in the day kind of as we were kicking off the course.
So the let me actually open this one over here.
I had vector dot, I have this loaded up, but then I like zoomed in and everything kind of got out of the vector vector dot.
Okay. So we saw actually earlier this quarter,
I don't know if you remember this example we saw that you could implement the idea of a stack just using a vector.
Like with stack we push and pop and whatever you pushed last, that's the thing that gets popped out.
I mentioned it earlier this quarter. It's like, well, we could actually just use a vector to simulate that idea.
We could just add stuff to the end of the vector. And so that's like pushing.
And then when we want to remove from the end of the vector, we would just remove like if you're adding, you're going, boop, boop, boop.
Well, then if you want to remove and you want to simulate the idea of a stack, what you would do when you deep bloop,
when you remove stuff from this object is you would take whatever was at the end.
This is a life of data structure. The last thing is the first thing to come out.
So you could pull off the end there at V size minus one.
Now,
the problem with this is suppose you're working in a company and you you're like the first person to come up with the idea of a stack and you're like,
Oh, we can solve all these problems with this new idea that I have.
And instead of creating verbiage to discuss that, like, instead of treating the idea of a stack and saying push and pop.
You're like, you're trying to communicate with your coworkers and you're like, Oh,
use that cool data structure we talked about where you at at the end and you remove from the end.
And then like that, first of all, is just an inefficient way of communicating with other human beings.
But then everyone who goes in sits down to try to use that idea of the stack.
They start coding this and maybe they have an off by one error where they forget to subtract one there.
Maybe they try to remove from section zero instead of removing from the end, or they add at the beginning instead of removing at the end.
And so there are all kinds of issues that can happen there. Instead, what we do is we just implement the stack,
make sure that we have one good solid implementation of it, and then all the details are abstracted away,
hidden behind the scenes, and then someone can just consume that because they're familiar with the idea of the stack.
So that's the power that classes have to offer us is as we come up with new
ideas for other abstractions that we use in our daily lives to solve problems,
you just implement those using a class and then you have a good solid implementation of those.
And we're expanding with each new implementation, our vocabulary of abstractions and different,
nifty problem solving duties that we have to play with.
So that's kind of where they come into play there for what classes are all about.
And so this is kind of where what's going on right now.
Then in terms of looking at our classes, we've I've mentioned we're shifting from like consumers or clients to producers of these classes.
So where we've been and I took this graphic from my colleague Keith Schwartz,
who also teaches to $Sometimes where we've been is we've been playing with these interfaces the idea of like,
here's this thing that exists here, the functions that exist, here's the documentation.
We don't need to know the details behind the scenes. We're just using these things to solve problems.
Now we're actually going to look at how those are created, because at Stanford,
we want you to get the kind of education where you're not just kind of going through a
coding bootcamp and learning how to use a few tools that have already been created for you.
We want you to be empowered to be the creators of the next new cool series or sequence of tools.
And to do that you need to know how do we create these abstractions, How do we create these classes?
So today is all about going behind the scenes and looking at those classes and what we can do with them In terms of what I want to implement today,
let me say let me say this instead of implementing a vector today, because I think that this is like kind of like not true.
It's a little bit tedious and not like super, super fun. I instead want to code up a class that does something a little bit more whimsical.
I want to code up a cool creature today. And I don't know if you're looking at this image and you're like, What is that cute little creature?
That's Chris Hemsworth. And next to him is, is a Quokka.
And what I want to do is code up some Quokka functionality today. So I want to create a Quokka class with you.
And we're going to instantiate the Quokka class. And if you instantiate the Quokka class, you get a bunch of what is that called?
When you instantiate something, the variable is called a an object or an instance of the class we created.
Very good. So let's create a Quokka class.
I got this project started over here and I'll come back and talk a little bit about implementation and interface and what's happening here.
To add a class to my project, I'm going to go up here in the top left corner and right click over here.
The the project that I'm working on in the queue creator. And then there's a thing here that says Add new, I'm going to click add new over there.
And this of course will be in the video if you need to go back and watch, like wait, was this process to create it?
And then this first thing that's highlighted is a C++ class.
I'm going to create a Quokka class, a blueprints for how a Quokka is constructed, and it says, What's your class name?
Well, I'm going to give it a quokka over here.
And the tradition when we read a class in C++ is to capitalize the first letter of the name that helps us distinguish
between what's a class and what's just a built in data type in C++ or what's just a regular old variable.
If the first letter is capitalized, we generally look at that and say, Oh, that's got to be a class.
So just create this. And it actually created two files and there's a little yellow warning.
Okay, The little yellow warning just disappeared. It takes a second to actually add it to my project.
But what we see here is if you double click headers, you'll see that I just got a Quokka dot h header over here,
and then down here in sources I got a Quokka dot CP. Let me actually split the view over here so we can look at both of these side by side.
And I'm going to play with the Coconut H and the Quokka dot. CP Here's how this divide works.
When you create a class, you get these two files. So far you've mostly been working with CP files, writing source code, implementing functionality.
This dot h file over here, we call it the header file.
That dot each file of this is you can think of. This is the interface to the class.
This is kind of like a list of what the class has to offer.
So that's what the file is. You can almost think of this as it's a little bit like emulating the Stanford C++ Library documentation.
It's going to be a list of all of the goodies that are within a class. The data that we put in there and all of the functions that you call.
And then over here in the CPP file, this is the actual implementation of the class.
And so this is the how.
Of the class. So this is where, like, I'll list my functions that I want my class to have over here.
But then over at my CP file, that's where I will implement those functions and say how we do the things we want to do.
That's where we actually write the code.
So let me dig in and start playing with this idea of of what I want my quokka to be able to do some things that I want my Quokka to have.
So I want my Quokka to have a name. So let me do I'm going to do a string name for the Quokka.
And by the way, when you create this in C++, the syntax that it has, it has, you can kind of ignore these things right here.
These are called include cards. If you want to know more about what those are, we can talk about them offline.
Just leave them in place when you use the cute creator to create a class.
This basically ensures that if you pound include this each file in like multiple times in
a source file that it doesn't have conflicts where it's like you've defined these things,
you're pulling this file in multiple times. And so it looks like you have like five different definitions of this function over here,
five different definitions of this class or whatever is going on there. This prevents that from happening.
And then the syntax here is class and then the name of the class we've created.
So somewhere in the Stanford C++ libraries, there's something that looks like this class vector.
So this is Class Quokka and then in curly braces, and there's a semicolon at the end of the curly braces, just like there was with structs.
We have a list of all of the goodies that happened that make this class make up this class.
So the data inside the class and the functions inside this class, by default,
there's this function here that is called the it's a function that has the same name as the class.
We call this our constructor function. And you'll see that that already exists.
Over in the CP file. There's a constructor function over there as well.
This is just a function that any time you instantiate the class is called automatically.
And right now it just doesn't do anything for us other than when you try to create a clock.
Quokka is created and this function gets called kind of as a side effect of that.
We'll see that in a second. Why that's actually interesting and useful.
But then beyond that, you can just articulate variables that you want to have have happen that are packaged together.
So I want each of my pockets to have a name. So I'll do string and a common paradigm for object oriented programing.
When you create these classes is if you have a function inside your class.
We call these our member func ah sorry variable inside your class.
We call these our member variables. We typically put an underscore in front of the name of any member variable so that anyone who's using this code,
if we use, say, underscore name as a variable name, they'll say, Oh, that's not a local variable inside some function.
That's actually a variable that comes from the Quokka class.
It's part of the built in functionality of this class or part of the built in state or data in that class.
I also want to do a location where these things are located and then like an integer, how adorable they are.
And we can rate each one on a scale of one through five.
How adorable each of these quokkas are. I've brought many pictures of quokkas for us to do today.
One of the things that you're seeing here is the string is underlined and it's like, Oh, I don't know what a string is.
Usually what we would do is we would add it to our code using namespace stuff like this.
And notice that the and then actually maybe include if I include string,
maybe I'll just include IO stream and that I know where we pull and string stuff for me automatically if I get rid of this using namespace steady.
What you see is that the string is red underlined again and that's part of the standard namespace namespace.
It's considered pure form in a file.
When you're creating a class, it's considered a poor form to type using namespace and then putting a namespace in there because then anyone else who
decides to use this header file like in their in their file they type include H when they pull when they do that,
if you have a using namespace over here, it comes over into that file and it pollutes whatever namespace they were trying to use.
Some people don't use the standard namespace in their projects, they use a different namespace.
And so if you define a namespace here, say we're using a namespace here and then someone includes that header file over here,
they're stuck with that namespace and so we just don't do that.
It's considered poor form in a header file to do that.
So does anyone remember very early in the quarter I talked about if I don't want to using namespace nested how I'm going would I tell C++?
Yeah. Go for it there. Yeah. STD colon.
Colon. Very good to say this comes from the standard namespace. So in these dot h files we're going to use as we declare variables STD.
Colon. Colon. Anyway, we're trying to use a goodie from the standard namespace.
So I've got some basic Quokka functionality going on here.
Let me actually go back to Main. Let me split this further and I'll go over here.
This is main and let me see if I can kind of get as much functionality going here side by side as possible.
So in main, I can get rid of all of this stuff over here.
In main I'm going to include that file. So includes Quokka H like this.
So that pulls in the Quokka class definition. And now my, my main function is aware of all the goodies that are inside a quokka.
So I can do Quokka queue one like this, and that creates a quokka for me.
There are no errors happening over there on that line. I've got these little green bars and then if you want to access the members,
those member variables inside my inside my inside that class to go into the queue.
One object I do queue one and then what do I type next to go inside.
One of these variables are own. Yeah. The dot. And you've done that before again with like vector set, Q, things like that.
And so now I can just set these things. I can say the location quokkas only exist naturally in Australia.
I can set Q one name, this one over here, I'll call it Hemi because it's with Chris Hemsworth and then Q one dot How Oh,
I forgot to put an underscore over here. Q one how adorable.
Like this, how adorable equals and then I'll give it a five because it's like super, super adorable.
And if I give this a compile and run, it doesn't do anything interesting.
But it's certainly like it's certainly happy to compile and run. It's doing its thing.
Let's write our first function, then I'd like to have just a function. So I have these member variables.
We also have these member functions.
So our member functions, I sometimes refer to those as I'll sometimes call those methods the methods or functions built into this.
So let me create a new function that just prints out some info.
So I want to do avoid print info that is going to print info about a particular quokka.
Now once I put this, what is this called, by the way? A function, a function signature with a semicolon after it was called a functional prototype.
Very good. I haven't actually created the function. Where should I put the definition for this function?
Should I write the code here in the file?
Should I write the definition for that function in quokka dot CP or should I write the definition for that function in my main and my main file?
Yeah, the clock it out. CP Really good. So this is where I said all the implementation goes.
This is just saying what we can do. We can call a print info function on this Quokka.
Here we actually write this function. This is the how everything happens behind the scenes.
We write our functions over here. And part of what's happening with this divide is this.
When someone loads up or down each file, they see a list.
It's like a menu of all the stuff that it's the interface to the class, all the stuff that they can do with that class.
What we don't want. Like imagine if you loaded up the Stanford C++ library documentation and instead of just a nice list of all the stuff in there,
what it was is like the name of some function and then lines of code and you're like scrolling, scrolling, scrolling.
You're like, Where's the next function? And then you see that function. Then it's like lines of code and you're scrolling, scrolling, scrolling.
That would be ridiculous. We pass these out into two separate files.
There are actually like coding reasons that we could talk about offline if you're interested.
But one of the main reasons we do this in terms of the human aspect of coding is so that someone has a nice menu
of what's inside the Quokka class and they don't need to scroll through tons of code to see what's going on.
So I want to do this voiceprint info function and have it be part of my Quokka class.
I'm just going to do this. I'm going to do see out now here I can using standard namespace, using namespace, stuff like that.
And let me include because I'm doing some SEO stuff, let me include my IO stream.
It's fine to use standard namespace in CP files. Again, we don't like it when we're in header files, so let me just do C like this.
I'll do like this is the name, the name of the Quokka and then I'll put in parentheses how adorable.
And then I'll print out how adorable like that.
And then I'll do a comma and do location, and then I'll print its location.
Like this and then close the parentheses and do an endow character over here.
Now, I need to do something special with this function.
This isn't just a void print info function that's floating around in the wilds for anyone to use.
This function is part of my class in order to signify that this is part of my class in front of the function name, I need to type my class name.
Colon. Colon. And this is part of my Quokka class.
That was already happening in the function online eight. What did I say?
That function on line eight was called It's the constructor function.
Very good. It's the function that's called automatically whenever I created Quokka and that was already
happening up there automatically for me when I use the queue to create or to create this class.
I need to do that manually any time I create a new function.
Now you might be looking at this and saying like, Wait a second, how does this know what the name variable is?
I didn't pass that in as a parameter. The thing is, any function that you write in the Quokka class has access to any given quokkas,
any of the variables there, the name, the location, how adorable it is, and so on and so forth.
So because this is part of the Quokka class, it has access to all of the Quokka member variables.
So when I do something like this, when I do Q one dot and there's my print info function, I can call it.
Now that comes over here and I've called print info on my Q one Quokka.
On that specific instance of my Quokka. So this function here looks at the name variable within that instance and the how
adorable variable within that instance and the location within that instance.
And when I give it a run, it says, Oh, we've got Hemi, How adorable and what the location is for Hammy.
If you want to create another one of those. So let me show you that these variables are indeed separate.
So suppose I created another one, I'll call it Q
This is, first of all, also in Australia. Let's take a look at first of all.
There's first of all, I know how many when you give it a five for how adorable it is.
How many want to give it a four for how adorable it is? A three. A two.
A one. Okay. Some haters. Interesting. I see you. Okay, so the fives had it.
It was I don't know if it was a majority, but it was certainly a plurality of the greatest number of votes.
So this is first of all. And if I do. Q two print info.
What you'll see is when I called Q to print info, I go to Qand it's looking at the name how adorable and location within the Q two.
And again, remind me of the verbiage here. Q Two is a what of the class?
It's an instance and it's also called an object. Very, very good.
And when I created it, I was what was the verb form?
When I created it, I was vertebrate birding, the instantiating the Quokka class, creating an instance of the Quokka class.
And when I give this a compile and run, oh oh, no, I didn't give it any.
That was Q I didn't type to two down there.
So when I get this a compile on run, indeed, first of all is also in Australia and I say how adorable it is.
So I've created a function, I've got some goodies, some some data there, I've got a function,
I'm calling a function, I've got instance, I've got member variables, I've got those methods.
This is a broken paradigm over here, by the way. Or maybe it's called an idiom.
This is a broken idiom where every time I create a quokka, I want to set its name, how adorable it is and its location.
It's many, many lines of code. When I see chunks of code that are repeated,
what should I start thinking of doing When I see chunks of code that are repeated throughout my my file make a function very, very good.
So what I want to do is a function that when I create a quokka, its it sets its name for me and how adorable it is and its location.
So let's do that. And I'm going to actually make that I could do I could do this two ways.
I could just say Quokka, cue one and I could do Q one dot set info and pass it.
Name. How adorable. Location. But what function do I already know is going to get called automatically when I create Q one the constructor function.
And so why not just use the constructor function to set that for us automatically?
What I can do is create a second constructor function that actually takes parameters and sets all this stuff up for me.
So I'll do a string name and I'll do Integer.
How adorable. And I'm not going to pass it the location because I happen to know that all of these are located in Australia,
so I don't need to pass it the location.
I'm just going to set that here manually, but I will pass it to another string because I have a crazy kooky idea.
I'm going to keep track of where the profile pic is for this thing and do something interesting with this as we go through the lecture here.
So let me add a new a new field over here, a new member variable, steady string.
This is going to be its profile pic. This is going to be like the name of a file where its profile picture is located.
And then here this function I'm going to call this constructor and I'll pass at the name and I'll just say the name.
This is remember, I use an underscore here. So this refers to the variable inside the quokka.
I'll just add that equal to the name that was passed into the function. And then how adorable is this thing?
I'll set that to the how adorable value of the function.
And then what's the profile pic for this thing? I'll set that to the profile pic variable passed into this function.
And then where is it located? It's located in Australia.
I didn't even need to pass that into the function. All the quokkas are in Australia and some of them have been kidnaped and taken to the zoo.
I don't know. I haven't been keeping tabs on all of them and so what I get to do now is I can
call this function like this five and then this was how many dot jpg like that.
Let me I'm out of screen real estate here.
This is so sad. Okay. So heavy like that. Oh my gosh.
It's a metaphor for the real world. We're out of real estate. Oh, interesting.
The existential dread is setting in. Okay, good. So Percival is over here like this, Percival like that.
And. Okay, so it's yelling at me. What did I not do?
I created a constructor function in my CP file, and I'm calling it from Main.
What's the missing step that I didn't do? Gee, if you see it, just shout it out.
Or raise your hand because I know. Continued starting up. Yeah. Go in the back. Yeah.
I need to add it to the header file. The file over here.
I need to add it to the menu because this is the thing that I'm LB including to come over here.
So it needs to be listed. There is a thing that actually exists.
So let me just go over here and add another constructor function and I'll just take this and put it down here with a semicolon after it.
When you put the semicolon after it, that just creates for us.
That's our functional prototype. Oh, but over here I need to study colon.
Colon because I didn't using namespace because using namespace is considered perform in your files.
Aha. Oh, no. Extra hoodie.
Whoo! Oh, And then over here, you don't need to do Coca Cola and colon in front of those when you're defining.
You only do that in your sleep files. Uh huh.
Okay, so this works over here. Everything's moving forward in terms of we've got functionality, things are working.
And what is that called, By the way, when I have two functions that have the same name, I've overloaded the function.
Yeah. Someone might still want to create a QR code where they go in and manually set some pieces of information.
Someone might not want to do that. So this, by the way, I don't know if I use these terms.
These variables govern the state that we're in with this Quokka and these member functions.
These are the behaviors of the Quokka. So we have functions and variables.
We have behaviors, and we have the state that we're in. Now,
one of the things that we sometimes do with our with our with our variables and even with certain with
certain functions is sometimes you don't want people to be able to access these and jack these up.
So check this out. One of the things I mentioned is when you create a vector vector into V like this,
the vector has at least two pieces of data that it's keeping track of behind the scenes.
One, it's got the list of elements that you've put in here. Two, it keeps track of how many elements you've put in there.
So if you call V dot size, that function that's built into the vector, it just immediately returns to you.
There are elements here. It doesn't need to count them up. It doesn't need to loop through them.
It's just keeping track behind the scenes. That size is what we call a private member of our vector.
So check this out. Suppose it weren't. Suppose we could do this virus at the number ten, and 
You know that V size right now should be equal to, what, three?
I've added three elements. Imagine if size this variable in size, the inside the vector.
Imagine if people were just allowed to change it willy nilly.
Then someone might create a vector here, put three elements in it, and they're like, Oh, I want to add a fourth element.
And they just try to set that equal to four like that. If size were something that we were allowed to modify,
someone could create a vector and then just set the size equal to some value that has no ruins the internal state of the vector.
The vector has three elements. If the internal size integer is set to four,
then we've entered a broken state where maybe we're going to try to loop through those elements and print four of them.
But there are only three there, and so the program might crash spectacularly.
So we often have information that we use behind the scenes for bookkeeping purposes, and we don't want someone to be able to modify those things.
And so we make those things private. So that means that no one can modify them directly.
If something's private, you can only modify it in the CPP implementation for that class, not in other files where you're a consumer of that class.
And we often do that because we don't want people to break things.
If we give people access,
like imagine that you're implementing a stack and we have push and pop and then you give someone access to like the vector where that's being stored.
Well, they could actually just go in there and remove stuff from the vector, put stuff in and change the order.
Things are in there and then you're no longer actually getting push pop behaviors.
They could break your data structure. So we often protect, ah, protect the internal goodies of a class.
By doing this, you might have noticed this and I kind of skimmed over it when I opened the class.
Q To create or created this thing, it says Public Colon. All of these things are now accessible to anyone who uses a quokka.
But if I do this, if I do private colon, what happens is all the stuff after public lines through 
anyone who creates a quokka can call this functions. But now everything after line 
In this file, anyone who creates a quokka, they're not allowed to touch those things except Quokka CP itself, where I'm defining the functionality.
So check this out.
Right now I've made the name private, so if I do Q one that name equals and maybe I try to go in there and be like [INAUDIBLE] or something like that,
or that's maybe that's too mean muffin face like that. That's still a little bit mean, but you see that it's red underline highlighted right there.
If I try to come in pilots and run, it's hard to see down here, but it says this is private.
You're not allowed to change the name directly. But over here in this code, it's not red underlined because that's my definition of the class.
The definition of the class has to be able to touch all those variables. But that over there is outside my class.
It's a consumer of my class. It can't touch private stuff.
So this is the implementation of the class. It touches private stuff. That's a consumer of the class.
That's what we are when we use the Stanford C++ vector or the Q or the stack.
We're the consumers. We can't touch the private stuff. But Stanford's like stacks up the implementation.
Of course it can touch the private stuff and mess with the internal state of that thing.
So if we're not allowed to change, say, say, we want to protect this.
Suppose when we create a quokka, we want to give it a name and we want that name to be immutable.
It cannot mutate, it cannot change. That's the name of the Quokka over its life.
So here we have that functionality. I can't change the name over the course of its life, but if you want.
To print out the name and just want it. You want to know what the name is and you want to print it out like this.
You also can't do that because you're not allowed to see that see out.
He wanted that name. You're not allowed to access that private variable from over here.
So what we often do, if you have a variable and you want it to like no one from outside can set it, but you want to be able to see it.
And this happens with the vector, by the way, right?
When you create a vector, you can't just be like size equals and like make stuff up like that, but you can check what the size is.
We have a function that returns to the size. So oftentimes with private variables, we create what we call getter functions.
These are getters. All they do is you use the name of the variable itself.
String name. And it just returns the name of the Quokka return name.
So in this way, when I create this and by the way, now that I've created that,
I need to put the functional prototype over here and say that that's public.
I need to study here and I need to put the class name in front of it over here.
Well, now I can just call dot name with parentheses.
That is a public function that just returns the name.
So anyone now who is a client of this class, this Quokka class, anyone can get to the name.
They're just not allowed to set the name.
I made it private, and the only way to get it then was to write a function that was public that returns that information.
So these are called getters. Let me do a getter for each of these then.
So I want to do a getter for how adorable what the location is and what the profile pic is.
So this is profile pic. This is the location.
This is the. How adorable. How adorable.
These are all getters. This is an intouch adorable and it returns how adorable we are or how adorable that thing is.
The location. And then this returns the profile pic. So I've now created those.
I also then need to come over here and take those functional prototypes.
Let me just put them here really quickly and get rid of all of this stuff here.
I need to take this functional prototypes doo doo doo and put them over here so that they can actually be called publicly.
Get rid of that one there. Do, do, do. And then I need to also get rid of that.
And I also need to STD, colon. Colon. So when you copy those functional prototypes over,
you need to STD for anything that was standard and you need to get rid of that quokka colon, colon so that those things work there.
And so now I have access to all of those. I can read them, but they're kind of like read only, like what's the location for this thing?
I can call a function and it will tell me what that location is. It's in Australia, but I can't do this.
I can't do. Q one dot underscore location equals your mom's house.
Like, that's just not allowed. It won't compile right now. It's red underlined.
So I can't just go in and manually change that thing like that. So those are called getters.
Sometimes we also want to write a function that can set something.
So let's write a set name function here. So this is going to be called a setter.
If you have both a getter and a setter for some variable,
then what will often do is put a set name and then in just so just calling this name here, we might call this get name.
Now, if you have both of those, we might call one and one get.
And sometimes if you have both of them, people will just use this as the name for the get function.
It's just a convenient thing that the name of the function kind of matches the variable that we're trying to retrieve,
except for it's missing the underscore here. So set name, you might be looking at this and saying, well,
why not make that public if you're going to write a function that allows you to set the name and a function that allows you to get the name,
just make it public, you can change it and you can read it if you're public.
Right. Why would you use functions to do that?
And one of the reasons why we sometimes make something private and then use setters and getters.
By the way, are you with me on that? If I made it public, I wouldn't need setters and getters.
If I made the name public, I would just come over here and I would be like, Yeah. Q One name equals your mom like that.
And then I would do see out Q one dot underscore name like that.
And if it were public, that would work. And so you might be saying like, well, why create setters and getters?
Why force us to do this? Why force us to now do.
Q one dot set name to your mom like that and then do a getter like this in order to print out what the name is.
There was like a giggle when I mentioned your mom's house. But now that I'm naming the Quokka after your mom, people are like, Whoa.
Like, there was no giggling when that happened. Okay, interesting. Well, that's why we might want to write a satire, actually,
is if you want to ensure that people can't just change a variable to any value they please, but maybe place some restrictions on it.
Then you would make them call a function. So in this function, I could check and I say I could say, And by the way, this function is bogus right now.
It should actually be void and it shouldn't return anything. So it should just be it's going to do stuff.
It's going to set name equal to and I'll pass a string.
This will be the new name. I'll pass that in there and just set that equal to the new name like that.
That's my setter. And let me now take that over here and make sure that this exists.
This is my void set name function that takes a standard string, the new name, and that's that thing over there.
But I could put a little gateway here that says, if name contains mom, No, that's not allowed.
We could do something like that. And it actually brought with me today a list of I brought with me just a list of bad words.
I have bad words that text here.
And I want to actually implement this functionality that we cannot put into this string any of the words that are in bad words, not text.
So there's if you're working through this new assignment that's released for you, you've already seen the have you seen the lexicon?
And actually, I think the lexicon came up in a section problem or two already,
but there's in the Stanford C++ Library, there's this thing called the Lexicon class.
The lexicon class. When you create one, it looks like this.
Let me just create one for you and I'll kind of talk through it here. So this is in the Stanford C++ Library.
This is Lexicon H and I'm going to create a lexicon in here.
I'm going to do Lexicon. Lexi And here in parentheses, you can put the name of a file like bad words, like text.
This is a function that gets called automatically when you create a lexicon.
What kind of function am I calling then? It's the constructor function for my lexicon.
What this does is it reads all the words in that file, into this data structure, into this into this object here, the Lexi object.
And then I can just check if Lexi contains certain things or I can loop through all of the strings there that are in the Lexi.
So it has right now a list of bad words. And what I can do is this I can do for every string s in Lexi.
So I'll just loop through all of the stuff that just got loaded automatically into the lexicon for me.
And I'll say if the new name and in the Stanford C++ library, this is the string lib dot H in the Stanford C++ library,
there is a string contains functions I can check if string contains and I'll check does the new name contain?
And so I'm looping through actually all the bad words. So this is for each bad word in this lexicon.
I'll say if string contains that bad word, let's just do an error.
Actually error. Naughty name.
And I'll just do and we'll print out what that new name is. Like this.
And then. Yeah.
Otherwise, if this'll crash the program, it'll kill the program dead.
And otherwise, if I get down here, if I. If I loop through every word in that lexicon and none of them were naughty and I didn't crash the program,
then I'll get down here and I'll set that name equal to that thing over there. So this is the the lexicon.
Now, one of the things that I might need to worry about is, um.
Is this might not actually work. Can anyone think of a situation where this might there might be a bad word and bad words that text.
But then the name has that bad word, but it actually doesn't get caught.
Can anyone think of a situation that might cause that to happen?
Yeah. Good word. Yeah. Capitalization. Right.
So, like, maybe maybe the new name doesn't begin with a capital letter F, maybe it's A or whatever letter we're dealing with.
Maybe it begins with a lowercase in this file over here.
So let's just convert all of these two lowercase like this are two lowercase like that.
And so everything's lowercase when we do our comparisons over there. Now, the thing is, to test this, we do need to test it.
And so I am going to open bad words that t t here. I hope everything's okay with this.
Okay, so we have this. I don't know if you remember e zoom from earlier in the quarter.
It's mus spelled backwards I Urban dictionary too that after class I was like, Is this a bad word?
And it wasn't. I don't know if you've added it since then.
So over here, if I try to like set name to coffee face like this and I give this a compile and run.
It says naughty name that has coffee in it. Okay.
But I can do like muffin face like this. And that runs just fine.
And that one's okay. Um, we can also, then.
Oh, by the way, let me just mention this. There's also a destructor function.
So when you put a tilde in front of this constructor function name that creates a destructor, and that's called whenever one of these things dies.
So check this out at the end of your program, all of the variables that you created get cleared up.
They all die. And so they all these quokkas were constructed when I ran my program.
When I hit this return zero line, all of them get deconstructed and this method gets called automatically.
What's this see out? I'll do IP. And then the name of this thing and all.
And that gets called automatically. You see that when the program when I hit the end of the program, it did RIP.
First of all, R.I.P. Muffin Face, there's all they all died,
they got deconstructed and this function gets called automatically when they get deconstructed.
Um, let's create a vector of these things really quickly, so I'll do a vector of quokkas.
This will be my, my, I'll just call it.
Q My vector. Q You can actually create these without creating variables for each Quokka.
You can do cute ad And then when you use the Quokka the class name and just put parentheses after the class name,
that creates a new Quokka and I'm just adding that to my vector without giving it its own separate variable name.
I suppose you could think of that as this is Q add and I'll create a new Quokka called Percival like this.
And then I want to loop through all of this. Quokka So let me do this for Quokka.
Oh. Q You in the Q the Quokka thing and I could maybe print them all out.
Like this. I could do up in print info.
Oh no. Sorry. This should be queue you is the name of the variable there.
So Q you print info and so and you see, by the way, when I put these things into a vector, there are bunch of copies that are getting made.
So they're being created and dying behind the scenes. Lots of copying happens when you're playing with vectors.
Let's create a few more, a few more quokkas here.
So I have I don't know. That's the wrong I have here.
Just a bunch of quokkas. They're so they're so wonderful.
That one is named Lovelace. That's clean. I forget what his name is.
That's Muffin face. Okay, so let's.
I just want to kind of create those really quickly here. So let's throw them all into this vector.
You add muffin face, and this is from Muffin Face that jpg And let me go.
I know that I have four more. What are they named for? Five, six and seven.
Let me do this. This is 
I know. I name that one. Lovelace. Lovelace.
Oh six Glenn. Oh, this is Lovelace here. Glenn.
I don't know. We'll make up Fred. And then last quarter I showed them some quokkas and I asked them to name one and someone shouts out, Night Tara.
They were like, really afraid of quokkas. So we have all of these quokkas in this vector over here.
Oh, and there's just the Quokka death all over the place. You can see us that are coming and going.
They're all getting. Before class today.
I got all of this together. I have some extra files that I just want to add to this project over here.
I don't know if you. Remember this or if you were around for this, like back in the early days of the Internet,
there was this thing called Geocities, and all Web pages basically looked like this.
This is like what the early Internet looked like. It was really wild times and sad.
I hope none of these are dirty. I'm just clicking on them indiscriminately.
And I thought, how fun would it be if I created some functionality with the C++,
the graphics windows in the graphics libraries, created some functionality to to emulate that with our quokkas.
And so let me add a new class to this. This is my Geocities class.
Geocities I kind of want to do like Geocities emulation here, so I'm going to add those files there.
Those should get added. Okay, so those opened up for me.
Let me just kind of copy and paste this. This is Geocities dot H and then I have Geocities dot c.p.
And in Geocities dot CPF this and I have here a function called Where did it Go in Geocities?
H I have a function called render profile. And so I just want to add to that really quickly.
I'm going to do over here.
This is going to be void display profile, and I'll add that over here really quickly to let's say you Geocities dot CP or no, sorry, coconut soup.
Let me just do here void Quokka display profile like this and it's going to call render Geocities page.
Oh, by the way,
if you want to call a function and pass it like suppose you call one of these Quokka functions and you want to pass the Quokka itself to a function.
The keyword to do that is this.
This refers to the quokka that I am calling display profile on, and I created a render Geocities function in Geocities.
So let me include here Geocities dot h like that.
Did that get happy down there? Yes. And then if I do here display profile like that.
Oh, no Quokka class. It's upset about my get name O instead of I just have this called get name here get name and let me go back to This is not mean.
Did I call get name over there? No. Oh no.
It's still unhappy about that name. I called it getting a name over here.
Sorry, I had it called a different thing. Oh, hurray.
And so we get all these cute little and I'll post that code for you to play with in in, in your lecture notes.
Thanks for being here. I appreciate that.
Everyone, welcome back to one of Today we're going over recursive backtracking.
So overall, recursive backtracking when if you aren't comfortable, Chris, of backtracking,
you can kind of think of it as one of those choose your own adventure books or story based games.
And that's really the exact same thing. You decide, Oh, I want to go down one path, you explore it, maybe make a horrible mistake, end up dying.
You decide to go back a few pages unexplored that path, and then keep on doing that until you reach a desired solution or outcome.
When you're dealing with Chris backtracking, it's exactly the same thing. You explore a path.
You try to see if a story works or fits your needs. If it doesn't, you go back a few steps, backtrack,
and then keep doing that until you either find something that matches your needs or have explored every possible outcome or decided,
okay, this isn't going to work, and you can decide that, Oh, I was looking for something.
It doesn't exist. So once again,
what is backtracking besides the horrible analogy I just used that tracking help solve problems
for which we need try many and I mean many different options to find the desired outcome.
That means if you take a step in the wrong direction, that's okay. That's expected to happen.
You need to backtrack on do that step and try a different option.
Essentially, you're trying every possible scenario and you won't know if the scenario that you're trying is good until you've actually tried it.
Once you find out that it isn't a good scenario, that's where you going to backtrack and try a different scenario.
One thing to keep in mind is to construct a back tracking solution. You likely in most cases, have to recurs on all types of possible options.
And if you don't have to, you should expect to and be prepared to use the end of an option.
Find success. That's how you know that you've found a solution. So now you may be considering when is backtracking useful.
You've done recursion in shorthand in prior assignments, which didn't exactly have back tracking.
Why do you need backtracking? Well, when you have a large group of inputs that would be difficult to hand check, recursion is helpful.
Even though we've done recursion before that doesn't have the such large inputs that would be difficult to hand check.
Backtracking is really good for all those times where you have large data sets are trying
to find some combination or subset of them and that can be really hard to check by hand,
but really easy to check by computer and want to be specifically at least backtracking
primarily for three scenarios to find a solution or the first solution that you encounter.
That means that you're going to recursive python that matches your needs. You can return immediately the next one with your find all solutions.
And that's going to be the same idea as finding all combinations or all permutations of a certain set or ordering,
ordering and backtracking go hand in hand.
So if you ever find yourself trying to find it, ordering things or trying to find all solutions, that track is probably the way to go.
And last would be to find the best or the most optimal solution.
This means you're going to try every possible scenario exactly same as the one above,
but you're going to be storing something that you're using as a comparison factor as you go along.
So for this assignment, backtracking, There's four parts.
We're gonna start with a warm up and debugging, and this will give some practice with stepping through your debugger.
Next, we're going to have a section on text prediction,
which is really useful for a predictive text when you get numbers such as on a numerical keypad.
More on that later.
Then you'll have the bands up Power index or voting blocs portion of the assignment, which shows you how if you have a bunch of voting blocks,
I can vote every possible scenario to know if a vote is what we call critical, if you know what that means, more than that as well.
Finally, we have redistricting,
which is a really good case study on how gerrymandering affects specifically the US population and how we can create districts
and redistrict votes such that gerrymandering isn't affected in order to strive for equality for computer science abilities.
So let's dive in with the warm up. Before we do that.
Actually, I lied. There's some tips and tricks that I want to revisit from last night,
which is the fact that recursion is all about breaking down a problem into small and smaller pieces and tackling one at a time.
Just you have to understand what the task is. You need to know how to break it down into easier portions.
So draw pictures, draw the tree. I'm going to say this every single time we have recursion.
These two steps are very essential and you should not stick them.
And you'll even see in these slides, I've been drawing trees, so now it's time for more of debugging.
First, we're going to go over the towers of NOI. This is like the block puzzle where you may have a tower starting position and you want to do it
such that you can only move block at the top of a pillar and then move it to a different pillar.
Your goal is to get this exact same output on the opposite side, but you cannot place a block that is larger on top of block, that is smaller.
You can do this through recursive process. Now this function is mostly written, but there's a bug.
Your job is to step through the wood using your debugger in order to find what the bug is and fix it.
Now this will give you practice with the three step commands.
If you haven't got them already, step over skips to the next line or breakpoint depending on where you are in your debugging process.
And what that does is it runs it and skips over it. It doesn't allow you to step into it and look at what happens.
But essentially you say, I'm at this point, I know this line works. I'm just going to step over it.
Next step into that enters a function's call. So if you have a breakpoint on a function and you know that something breaks within that function,
you may want to step into that function to find out where it breaks within there in order to find out how to fix the bug next to step out,
you can kind of think of that step into is going deeper, step out is going less deep, it's going further up, more abstraction.
So you can think of it as undoing into or going the opposite direction as into if you
want to leave something that you've looked at because you're pretty confident it's okay.
So when you do this, you're going to be practicing testing and debugging programs,
but you have some few questions to answer as well, such as what's the smallest input you can use to trigger a bug in this program?
And then for this program as well, we've stated that there's a one character error in the program.
Your job is to find the character one character error. Explain why it causes the bug.
Next one to text predict.
So for text predict, we want you to think of a flip phone keypad if you don't know what that looks like, it's not on the right.
If you typed out high, the numbers pressed would be four four.
Now note that this is the numbers pressed her character.
Technically you pressed the number four twice for the letter I but we're not looking to that or twice for a lot of three times a letter.
All we care about is which number you pressed that correspond to a specific character.
If you mapped that out to a map, you get something like this data structure below.
You're going to be using that to go the other way. Let's say you have just the input.
How could you predict what was actually typed? How would you even start?
Well, if you asked for to start, you should draw the tree. So let's do all the treat first.
The first number is for for starts of g, H and I. So at first input, you have three possible strings that you've amassed so far.
You have g, H and I. Now on to the second number, which is also for.
So from each of these three strings that you've amassed so far, you can add a G agent by to that string,
which is the following options for strings, which I'm not going to say out loud.
So you have these filing options, but only some of these are actual words that you would expect to be predicted in the English lexicon.
So your job is to add only the real words contained in the lexicon to a set of string suggestions and for a lexicon.
If we called our function predict on the input string suggestions and less,
we would get the suggestions equals that this so your goal is to extract the text predict takes in strings of
digits a lexicon which is essentially English dictionary and a set of strings suggestions to be filled out.
Now note that the return value is void. There's no return value.
Instead, you're modifying the set past I reference. All this function does is modify the set.
So here's some tips. First, look at helper functions that we're going to talk about pruning or making sure that your code runs faster to not waste
time and also not exceed any sort of memory issues as well as handle some assumptions that make me your job easier.
First, because our helper functions predict must be it to match the prototype.
Exactly. That means you're going to need at least one helper function as a side view on some raptor and helper functions.
If you don't understand why you have to have that function. So when should use wrapper function?
We are told to implement a certain function better. That's a really good reason to use it.
But also your inputs that you were taking in from, let's say a user are quite the same inputs that you want to use in your recursive process.
So maybe you taken the string that they entered in, but you know, Oh, I'm going to have to keep track of a string that tracks so far.
I'm going to have to keep track of all the possible scenarios, all the possible things that I can look at.
Even though you don't ask the use of fret, that's something you want to use our person.
Typically you split it up to the wrapper, accepts what the user takes in,
and then all the work is that's done behind the scenes is done in the recursive function.
That's a really great idea. So in your wrapper function, you want to initialize more variables that you're going to use in your recursive function.
So typically use the rapport to initialize variables and then make your first recursive call.
You then use and modify the output from the recursive function that calls itself.
That last step is optional, but you'll even see that you're doing that on this assignment later on.
Note the proper function typically does not call itself recursively.
They'll run into some issues of your initialize and data. That's really the point of having the extra recursive function.
That way you avoid any issues such as that. So speaking of the helper function, let's look back at the tree that we drew earlier.
Were you keeping track of anything that wasn't in the original function header
that may be useful to have in the of case but can't be in the wrappers header?
So you would have a critical function next to pruning.
Pruning is cleanly handled by adding a base case to detect a dead end and immediately returning without making further recursive calls.
Why would you do that? Well, for example, if you had this TV in the English lexicon, there's no words that start with PB.
So there's no point even going down that tree further, since you know that you're only adding characters to the end of the string as you append it.
So just ignore that tree. You want to return early and escape it.
Return early sounds like a base case. So think of the fact that if you're pruning, you're trying to stop the process early,
you're trying to save time that typically sources to a base case. I also want to think of are there any other biscuits that you might want?
So if you think of our tree from earlier, when we start our overall process, how does that translate to code?
Next are some assumptions that make make your life easier.
I recommend that you read them, but you don't have to be too worried about somewhere in that screw script you cup.
Next round to fans of Power index, or as I have to call it,
voting blocs because I don't want pronounce that word incorrectly so many times in this video.
Next is the block voting systems. So this voting part of the assignment very closely is related to the United States Electoral College for voting.
The idea here is that if you have a bunch of blocs that are voting, you can find a coalition as a group of blocs that all vote for the same candidate.
So when you have a coalition of votes, you could describe another bloc that is not yet part of that coalition as a critical or swing vote.
If when you add that bloc to that coalition, it changes the outcome of the election.
So if you lost the election, if you don't have the vote,
but you are that voting bloc and you win the election, that would be described as a swing vote.
Now that the count of coalitions for which a bloc has a critical vote is used to compute its balance of power index.
That is its relative power in terms of adding it compared to all the other blocs in the coalition.
That is typically oh, how many swing votes do I present for all the coalitions that could exist compared to the other blocs in my coalition?
So. So again, each block has an assigned number of votes which is cast in unison.
This is all voting for the same candidate like in the Electoral College.
Coalition is a group of blocks voting for the same candidate. You consider a coalition the same as a combination of voting blocs.
And remember what I said. Whenever you're doing something with combinations, you're going to be doing recursion.
Last is a critical swing vote is a vote that changes the election's outcome.
And the power index is the index computed based on the number of coalitions for which a block is a critical vote.
Winning requires a strict majority.
That means the total votes over to plus one, and you have to either match or exceed that value from your whole coalition combined.
So here's the header that is actually from the header that only takes in blocks containing all the blocks for the system.
So that's all the voting areas. The building blocks now counts.
The critical votes to determine the voting power for block is what you should be doing,
but that returns a map of the bands of power indexes for each block.
So if you feed in the lions, tigers and bears example, where lions has votes, Tigers has and bears have one,
you would find out that lions has approximately % of the entire tigers has %, and bears has %.
So your final map, if you put in the map of the key lions legal which represents a percentage.
Now note that due to rounding some of all the indexes may not be exactly 
For example, if you have the power evenly split by three groups, it would be 
That's okay. That's expected. But you have other issues that don't match our test cases.
That's something to be aware. So you may be wondering how we went from this voting bloc to these percentages.
And the idea here is to look at the coalitions coalitions or just combinations that voted for each candidate.
So if you have lions and tigers and bears like on this page, you can form all the coalitions where you combine them.
So the combinations and find out the number of votes. So lions and tigers has votes.
This is a coalition. This is a coalition. These are all coalitions.
And there's a coalition that has nobody in it. This coalition that exists of just one, a coalition that exists of all.
So how would you approach this voting blocs problem? First, let's look at counting the number of critical votes for a single block.
In order to do that. You want to make all possible coalitions without block B,
so not that without even trying to count the critical votes for block B, you construct all coalitions.
Without block B, first coalitions in combination.
So you're going to be doing backtracking for each coalition that loses the election without block B,
that is, it doesn't have more the majority of the votes. See if adding B would result in winning the election.
That is the definition of a critical vote. So here are some tips.
You notice that your folks are heretics and just a vector of blocs,
which means you're going to need to write a and helper function because there's almost no way to keep track of that.
All the information you need cleanly with just taking input vector blocks and the recursive process,
you should create coalitions recursively as you go.
So you should find every coalition and then stored them somewhere because that will be a waste of space and slow down your runtime very much.
Lastly, in order to get every possible coalition you can add every block, as you saw from this slide here, there are coalitions that have none.
In order to had lions and tigers or lions and bears, you had to skip bears here.
You have to skip tigers here. So what that means is when you occurs through blocs to add a coalition,
you need one branch on a tree that includes a block and one branch or a tree that excludes or skips that block.
As you go through, think of a base cases. At what point can your block not be a critical vote?
If you ever reach this point, then you know that there are zero critical votes possible from this coalition subset.
So just return early and save time.
There's no point on branching down the tree anymore if you know that the block that you're looking at cannot be critical.
If you reach a point where there's no more blocks at the coalition, stop.
Makes sense. But still remember to check if adding be on top of this would result in a critical vote.
That is, do you not win the election without B? If I add the B, I win the election.
The idea here is if B is the last one to vote will determine the election standings.
Another thing is to think of the information that you want to keep track of. How do you know if adding these votes would win the election?
How do you know what number you need to pass in order to win an election?
Those numbers that you might have to calculate and find beforehand in the wrapper before you put it into the recursive function.
Also, think about the return value, the function that return values, a map of percentages.
Now, when you think of putting things into the map, you don't have to change the percentages immediately.
That doesn't require the recursive process. You can do that very simply without recursion.
For example, if you start with lions, tigers and bears and find the count of critical votes by the total critical votes,
then you can just find the percentage very quickly. And you don't have to do that with recursion.
Oh, it does mean is it requires you to find all the critical votes for a block first.
One last tip on efficiency is we've gone over many examples in the lecture of removing
things from our collection during a recursive call and then adding it later. However, in this case, it's not strictly necessary to do that.
You could do this problem without removing some from your vector.
The more important thing is doing so is extremely, extremely slow.
So like really slow. to minutes for stress tests.
You don't want to do this. You're going to have a bad time. And I don't want to wait minutes to grade your site.
So instead, think of a way to track what block in your vector you want to look at next without changing the vector.
That's going to be very similar for a map. Passing a map by reference is expensive.
So instead, what you can do is you can add the map to the map in wrapper function, not the recursive function.
So when you're going through your blocks, you don't want to be removing and adding to the block.
You just wanna keep track of which block you're going to look at next as well for the map.
You don't want to add to the map and pass the map by reference.
All you should do is add to the map in the wrapper function.
Once you already have the counts of critical blocks from the cursor, call back in the wrapper.
Last part of the segment is computational redistricting or redistricting for short.
Now redistricting is based on U.S. states and the idea that all districts in the U.S. have the same population for the state,
each district vote will impact elections. Enter Gerrymandering.
Gerrymandering is the manipulation of district lines to favor certain political parties voting outcomes.
Now, this issue has been exacerbated with sophisticated algorithms that can determine where we
want to draw lines in order to get a vote that will help you in an oncoming election.
For example, these are two ideas of the above districts for Texas.
If you look at the darker colors are going to be a stronger margin for one side or another.
And the lighter colors mean that it's closer.
If you just have this current Texas district and you propose this district, you can see how the voting power changes.
A lot of colors get darker, a lot of colors get lighter. And this can theoretically change the outcome of an election.
The idea here is to avoid that our test is, in fact,
a transparent redistricting algorithm that does not allow bad actors to manipulate the outcome of an election in their favor.
Now, an idea behind this is what's called the shortest split light algorithm, which is a geometry based redistricting approach,
which means you're going to be splitting things in lines to split regions into the shortest straight line that achieves desired.
In this case, this means equal division recursively splitting sub partitions until no more are needed.
That means are going to be going smaller and smaller and smaller.
We're going to be use a simplified version of the split line instead of the shorter split like we're going to do.
Horizontal and vertical split line. So.
Horizontal, vertical split line. We'll get to that later.
One thing to keep in know is for our header County District returns whether or not we can redistrict a state into end districts.
We're giving the number of people in every square mile and states and the number of districts we should create each campus a certain square miles.
So given the number of people and we're given the number of districts. Our idea is to divide things evenly.
So let's say there are nine square miles in Nevada. Not sure.
Just pretend the total population would be all these numbers summed equals 
If we want to apportion Nevada into four districts, target size for all districts will be people by four.
We can create a valid redistricting user algorithm. If you look here, you can add up each of these district blocks and see each of them have 
An invalid example would be this one with Wyoming with only four blocks.
If the sum of the population of this district is we divide by two blocks to get 
There's only two possibilities for redistricting, with two final districts split once horizontally or once vertically.
But no matter how you do it, you're going to end up with people in your group with at least one district and in the other at least.
So it's not going to work out. That's a bad example. This is a simple way to do this.
Each step choose to either slice horizontally or slice vertically and divide the remaining grid into two sections.
Then you're going to recursively slice those sections. Over and over and over again.
If at any point the results for your slices aren't valid like we saw in the past example, you're going to backtrack, undo that slice.
Try again with a different slice. You're going to continue until we succeed.
So find the first valid result results or tried all possible redistricting, in which case there's no bad results.
So here's some tips you're going to want to work for on a range of the grid at once, not just on an individual cell.
So divide each grid into districts. This is going to use a new data type called grid location range, and the documentations attach the slides.
One thing to know is do you want to keep track of a range of cells with row one column one wrote to column two.
So the blue range starts at zero zero, goes to zero two, the orange range starts out one zero and goes to two to.
Think of the base case, success would be if the population is exactly the target size.
In that case, you want to return. True, but in another case you're going to fail.
Return false. What happens? What's an easy way to return false?
What if the sum of your populations isn't a multiple of your target district size?
Then you want a return pulse. Now, think about this for a moment.
If you had people and you want to split into groups of ten, that's not going to work.
Exact same for districts. If your goal is to get even groups of but the sum of all people is, for example, 
There's no way to ever reach that. So there's no point in trying. You can just return false.
Backtrack, try to scenario or return false preemptively, very quickly.
Here's an example of the recursive process. You want to make one split and then recursive.
So for this example, you want to choose between horizontal and vertical split lines.
And there's many options you can do. You can do a horizontal line in the first row, the second row, the first column or the second column.
These are the four possible steps for three by three grid. The great location ranges for each section,
so each section is above where it starts and ends for the blue and orange, respectively, at the top and bottom.
So that's how you're going to split.
And then for each of these sections, you're going to split again and again until you can't or until you've returned.
True. And went up the page the entire time and have recursive.
So you want to focus on both sub ranges. If both succeed, great.
If not, you want to backtrack and try another split.
If all export lines end in failure, you want to return false to allow other earlier decisions to backtrack faster.
What it means is if you know that all the lines that you've explored have failed,
you want to return false, make that go up the tree so that we can explore other areas.
And if there's no other areas to explore, that's going to go back up the tree and return false for your overall function.
Another note, you'll need a rapid recursive function. Almost certainly you want at least one recursive helper, as usual.
Think of any additional information to store. That'll be helpful as you recursive.
Now I do recommend decomposing liberally and writing a lot of helper functions.
And there's a reason to do that is because it's much easier to debug this assignment that historically has required a lot of debugging.
And if you do put it into helper functions, debugging becomes easier.
And once you've tested one function thoroughly,
you're confident when you call it function that the bug may not be in how the functions infected, but rather in how you've called it.
So that's going to be more important. Another thing to note is that your function only needs to return a boolean cheerful value.
You don't need to actively store the division in districts, just state whether it's possible to make an even split.
One last thing is that there is a graphics course for this assignment. This is optional.
However, there's a group graphics module that can display the grid in split lines.
This may make it much easier to debug if you have a supplement. So that's something to keep in mind.
Instead of having to go through the debugger and look at, everything's on their data information,
you can just look at the representation visually and that make it might make it a
lot clearer when you slice it properly or what information you're not looking at.
Lastly, there are some ethical considerations for redistricting. You just create a code once you've finished to redistrict an entire state.
Consider some questions. What does the algorithm prioritize within its districts?
And how could this algorithm be manipulated in an act of gerrymandering to prioritize something else?
How do you prevent such misuse as a developer?
Generally, how should engineers incorporate or consider possible misuse or consequences of their products into the design process?
Should they? Should they not? It's up to you to answer.
Of that. Let's rehearse. I wish all the best of luck. Feel free to reach out if you have any questions.
Hello. Welcome. Happy Friday, everyone. Where are we?
So your mid-quarter exam, of course, is coming up next week. I'm going to unlock a page later this afternoon.
Oh, this microphone is so loud. And there's usually a quieter one up here that's missing today.
I won't do it later this afternoon. I don't know exactly what time.
Sometime after my office hours probably unlock for you a page on the website that has a bunch of exam review materials,
including a some sample exams from previous quarters.
And my recommendation to you with those with those practice exams is to actually maybe
these little slide one of them to treat as an actual exam where you sit down and you
try to work through it without referring to any notes and you time yourself and you see
how it feels to work through that in hours and you work through everything on paper.
There you also have a new quiz series. I didn't unlock your lecture quiz for Wednesday yet.
I'm going to do that later today. And then today's lecture quiz will also unlock later today.
Those aren't going to be due next Wednesday because I don't want you to have that as a distraction as you're preparing for your exam.
I'll actually make those due the following Wednesday when we get back from when we get back from that little break.
You have a day off on Monday. Another thing that I want to mention is the applications are currently open for people to apply to be section leader.
So if you're interested in section leading, joining our section leading program that takes care of our b courses.
It's a chance to join just a really great community of awesome people,
get some teaching experience and also just like learn this material even better from teaching this material.
So there's applications we're going to post that link for you on. ED. Those applications are due next.
I think the th is next Saturday at p.m. and the pay is really good to starting out.
So do look into that link and consider applying if you want to join that community.
The other announcement that I have before we dig into new material today is I am shifting the schedule a bit.
So one of the things that I would love to do heading into Exam one is just give you a day off or have a day that we can just kind of take a breather.
And unfortunately, just in terms of our need to push through seven assignments and unlock those at
reasonable times and give you a reasonable amount of time to work on those,
we just have to cover enough material to unlock another assignment for you.
We're not going to market next Wednesday.
We're going to look at right after your exam and we'll give you a full week plus that extra weekend to work on it so you have more time than usual.
But we do need to keep pushing through content in order to satisfy the department's requirements for what has to be covered in this course.
But what I can do, even though I don't have any room in the schedule to give you a day off before
the exam is take this day here and turn it into what I'm going to refer to as a
mental health day where we're just not going to meet that day and you're going to
do whatever it takes to kind of kind of take care of your mental health that day,
whether it's getting like a spa day or working on your next assignment,
reviewing some of the notes that you just didn't have time to review, maybe going to Tahoe.
And so I like that because it turns into an extra long weekend for you where you have that Friday off now as well
as the following Monday to kind of take take that I'll take that as a bit of a reset coming out of the exam.
Use that wisely to catch up and be sure that coming into class that following Wednesday you're all caught
up on everything and ready to move forward at the breakneck speed at which we do move through the quarter.
So that's what's happening there. A little schedule shift for you. So let's dive into some content.
And on Wednesday, of course, we talked about classes, we talked about object oriented programing, and I talked about that interface implementation,
that implicit interface implementation divide and how to create those,
start each files and DHCP files and make them play nicely together in terms of creating your own classes and whatnot.
The so, so kind of in the back there, I can, I can hear you all like chatting if you could just like keep it down a little bit.
It's reaching me all the way up here so I'd appreciate it and I'm sure everyone around you would appreciate it also if you would not do that.
And maybe actually, let's touch base after class, please. I'd like you to speak with me after class.
You're nodding for a second of pointing, giving me a thumbs up. Yeah, I'd like to chat about that.
Okay. So moving forward, then, with new material, what I want to talk about today is it's not really strictly related to classes.
We're shifting gears a little bit and talking about this thing called pointers,
which are kind of complex and crazy and twisty when you first see them.
And the idea is we're going to mix pointers and classes, today's material and last ones this past Wednesday's material,
we're going to mix those together on Monday and do some cool things. But for now,
I kind of need to break from what we talked about with classes that was just one unit teach you something different
and we're going to put all of that together on Friday when we talk about this thing called dynamic memory management.
And to kick off our discussion of pointers today, I want to kind of highlight something that I've mentioned in passing,
but maybe not really like harped on a whole lot so far this quarter, which is when you call a function and you create a variable in that function,
that variable dies when you leave that function, and it actually happens in pretty much any code block like here.
This. I I've talked about I've used the word scoped before this quarter.
So this all exists only in the scope of this for loop.
Once this code block terminates the variable, I no longer exists.
If you tried to access it down here on line if you tried to compile on your program, it would give you an error.
It would be like there's no I in the scope. What are you talking about? And similarly,
when I leave this function that I it's just creating a vector and it's populating it
with random integers and then it returns that vector when I leave this function,
that vector that I created actually dies. It no longer exists once I've left this function.
And that's a good thing. If you called a function and all the variables that it created continue to linger in memory when you left that function.
Then over the course of running a program and calling a function many, many times you would just be filling memory up with variables,
variables, variables, and your system would just run out of memory eventually.
So when you leave a function, the variables inside that function actually die.
And when I get back here to Main, I mean, if I printed out this vector, you'll actually see the contents of that vector when I print this out.
And you might say, Well, wait a second, that doesn't jive with what you just said.
You said that the variable that vector dies when I leave the function.
And in fact, it does. What's happening is there are two copies of this vector in memory.
When I call this function, I'm creating a vector over here, and when I return it, it's getting copied into this vector over here in main.
So that's taking time to be like loop, loop and copy all those elements over here into the vector in main and then also for split
seconds takes up a little bit of extra space that I have two copies of that vector in memory.
But then when I leave this function and I finish that kind of return operation, this vector dies and no longer exists.
I'm getting a copy of this thing. And the big problem with that is this is slow.
If you have a function that creates an object for you in memory, and maybe it has a gig of data associated with that object,
and then we just return that back to whoever called the function.
It's a slow operation to take all of that stuff in memory and copy it into this new in
this new version of that object over here in whatever function that you're returning to.
So what I want to build up to and ultimately do on Monday is a kind of programing necromancy where I can call a function and create a variable,
create some sort of object that lives beyond the lifecycle of that function, that when I call that function,
create that thing, and then I return that the variable actually does not die, that it lives on.
And if I can accomplish that, then what I can do is I'll call this function and I'll create this object in the function.
The function will die, but this thing will live on,
and then I'll just tether it to a variable that I haven't whatever function called this function over here.
And just creating that little tether will be a fast memory, efficient and speedy operation.
I'll just have that one copy instead of taking all that data and copying it back.
And so in order to accomplish that, I need to talk to you about what pointers are.
By the way, at some point in class today, I don't know when would be an appropriate point to do this.
What I want to do is prove to you that actually this vector here is a separate copy from this vector here.
And I'm trying to think of like what time would maybe be appropriate when maybe when the clock strikes noon.
Just start shouting as a group. Prove it. Prove it.
And if you do it emphatically enough, I'll actually prove to you and confidently enough,
I'll actually prove to you that these are two separate vectors in memory.
So I'll leave that code lingering around here for now.
But to build up to that, what I want to do is talk about this thing called a pointer.
Talk about what a pointer is. When you create a variable in your programs, when you do something like this,
when you do like an index equals what's happening in memory is your operating system is binding.
Every time you run a program,
finding places in memory that you can use for all of the stuff that your program needs to do and what's happening in memory.
If I can spell main correctly and maybe actually like blow this up a little bit for you, what's happening in memory is I get this little box called X,
and in that box I have the number and there's nothing crazy or new or groundbreaking going on with that statement so far.
But what I want you to know is that every variable in memory has an address associated with it.
So just like every host on a on a block of an a block of houses on city streets, every house has a unique address associated with it.
So too does every variable that you create in memory have a unique address associated with it?
And we can actually look at that address the address for a given variable.
We can look at addresses for our variables by putting an ampersand in from those variables when we go to print them out.
So if I just print X over here again, nothing crazy, nothing novel here.
I've just got the number 
But if I put an ampersand in front of that, the ampersand starts with the letter A and also what starts with the letter A is address.
This gives us the memory address of X.
And so if I go ahead and give this a compile and run, you see that I have this weird looking entity xf, blah blah, blah, cc
And so that's the memory address where this thing is located. And if I were drawing some diagrams because.
I wanted to keep track of where things were in memory.
Maybe I'm working on a really hard programing assignment that involves dealing with memory addresses.
I maybe draw this memory diagram and I just like abbreviate that memory address, but put that up there.
So the memory diagram, what I'm showing here is there's a variable called x. You can think of that as a box that holds the value.
The value that it holds is and the memory address.
Its location in memory is xf, c
That's just how memory addresses are represented as these.
With these they're called hexadecimal values, which you learn more about in in one of seven when you go in to take one or seven.
But for now, you can just look at that and be like, Oh, that thing is an address.
Well, if I wanted to then store that address in some sort of variable, I need a new data type to do it because that addresses zero x, blah blah, blah.
That's not an int, that's not a single char, that's not a floating point value.
It's actually not a string, although you might look at that and conjecture that it could be a string.
There's a special data type though, that I used to hold onto memory addresses and that data type is a pointer.
So here's the fundamental nature of a pointer. A pointer is a variable that stores a memory address.
A pointer is a variable that stores a memory address.
And if you want to create one of those, the syntax for that is you do the data type to be pointed to,
and then you put an asterisk, a star, and then your variable name.
So, for example, if I want to create a variable, a pointer variable that can hold this memory address.
First of all, the data type for X is integer. So I want to have what we will call a pointer to an integer.
Another way to say that is I want to store the memory address of an integer because a pointer is a memory address.
A memory address is a pointer. So to create a variable that can hold this memory address,
I do the data type of the thing I want to hold onto, and then a star and then just some variable name.
What this does for me is it creates a new box in memory called P.
That's the name of this variable and P's sole purpose in life.
And by the way, P has its own memory address. Like, let me just I don't know, I'm just keyboard bashing there and making something up for now.
So. PS whole purpose in life, like, like X, it's data type was this x is an integer.
Its purpose in life is it wants to hold on to a whole number. PS Whole purpose in life is it's an integer pointer.
It just wants to get the address of some integer.
I don't know. There's maybe a metaphor for loneliness there or desperation.
It just wants the address of some sort of integer. That's its whole purpose in life.
So knowing that, my question to you is, can someone raise their hand and say,
just based on what I've built up to so far, P wants to hold inside of it the address of an integer.
What could I type on this place that I just highlighted on the screen to set this up so that it gets what it wants in life?
The address of an integer so that I put inside of it. The address of an integer.
Yeah, you go for it. You're up. Yeah, yeah.
And percent x give it the address of x. So ampersand X gets the address of x.
That's this little thing right here. And then after I've created this pointer, so this is creating a pointer over here.
I'm saying set it equal to something. If I say set it equal to X, then this is what I'm putting inside that box called P.
And we now say that P points to x.
P has the memory address of X. Inside it we say P is pointing to X, so you could go up to P and be like, Hey p, where is X located?
I kind of want to go like hang out with X or like deliver to it a new integer that I think it'll really like.
And P can then go, Oh, it's over there at address xbloody body, body, body, blah is what's going on there.
Now if I print these out then. So if I do see out, if I print out p I should be able to print that out.
And then if I print out the address of P, we should see that it has its own memory address.
Let me, let me ask you here, of these four lines that I'm printing out,
I'm going to print x, the address of x, I'm going to print p, the address of P.
Can someone raise their hand and tell us which of those two lines should actually print the same value?
So like, is X the same as the address of X? If so, you would say, Oh, I think lines and we're going to print the same value.
Which of these two lines will print the same value? Anyone want to take a stab at it?
Yeah, go for it. and 
Yeah. Bingo. Perfect. Perfect. Perfect. So the address of X address of X online that's going to print this thing right here.
And then when I print P, that's to say whatever is in the box called P, Print that out.
Well, that's the address of X, That's the thing that we put inside.
P It's the address of X. So when I get this a compile and run, you'll see that indeed that did it.
These two lines here are the same that the address of X is held inside P and so we say P is a pointer to X.
What we really have then is this I'm trying to learn to speak young people language.
So I brought a meme with me. So there's an integer over there in memory.
That's our integer x. And then this thing is this thing is our pointer the pointer x, so integer or the pointer P.
So in star P, this thing is our pointer and it's got the address of our integer.
It's pointing over the integer and saying, There it is. And it would guide us over there if we wanted to go over there in memory.
And here's actually how you can use that to get over there in memory and change what's inside.
X. If you wanted to change what's inside X right now, by the way, you could just do something like this.
You could say, Oh, let's either equal to you could do that.
But what I want to show you is how we can use this pointer P to change what's inside X.
So one way to change what's inside x is to say x equals whatever.
If I, if I do this, by the way, if I say P equals this does not actually go change.
What's an X? How can someone raise their hand and tell me what would I need to change in my diagrams right now to accurately reflect what I said?
P equals What is that really changing over here?
Does it change? Like does it change this to the number ?
Does it change this to the number ? What does that mean when you say variable equals whatever?
Yeah, go for it back there.
And so we're sure that go in these diagrams over here, should it go inside this first box, should it go above the second box?
Where does the go? If you say say it louder in PE.
And so does that does that mean like here outside this box or what was that?
Yeah, it goes inside the box. Very good.
So I'm saying when I say set P equals to equal to that's saying that we're putting that inside the box called PE the value 
Well this is nonsense. Now I mean that's not a valid memory address.
This thing is just pointing to address in memory, which is probably somewhere where we shouldn't be.
And you'll actually see that my compiler or my my interface here is giving me an error and saying you can't just set that thing equal to 
That's not valid over there. So what should ours.
All right, so that's there. If I want to use this to then change what's an X?
Here's the way we do it. We put a star in front of P and this is called D referencing P.
The star is called is de referencing P. What the star says is, Hey, the thing to my right is a memory address.
Let's go to that memory address. And so P holds the address.
If I can undo this over here. P holds the address x
When we when we do star P that says go on a journey to that address and we actually go to that place, we go to the address.
Seven f, cWe go up here in memory and up there in memory.
We set whatever is in that box equal to So I go to the box, this address right here, and that's where I deliver the 
So the star I don't know if you've ever done this before or if this is just like super antiquated.
You know how there maybe be like ads on the radio every now and then that are like dial LB whatever for legal services.
Something, something something. You've heard of that before, right? Dial LB Whatever.
Have you ever dialed Star Something on your phone. I don't know if that actually how many you've heard what I'm talking about with the pound whatever
before some people just disengaged or how many if dial is like a start thing before on their phone.
Okay. Only a few people. I wasn't sure if that still happened. Like back in the day actually before cell phones.
If you wanted to, like, know who called you, like the last person there, there's like, a number that you could dial to see who had called you last.
It was like star or something. And then also, if you wanted to call someone and would block the caller idea thing,
you did like star before you called them or something like that. But anyway, I think about that when I,
when I'm using pointers is this you can think of this almost as like I hate to mix phone numbers and memory addresses,
but see if you can follow me through this analogy.
You can almost think of that as like the phone number that access X and this is saying dial up that phone number.
And so we actually get over to X and then we deliver at the 
So this is D referencing. Now, one of the really crappy things about the way pointers work is the ampersand operator means
two different things in C++ and the asterisk operator also means two different things in C++.
So check this out. This asterisk operator over here, this was involved with the creation of a pointer.
So let me say this star, in conjunction with variable variable creation, makes a pointer for you Star.
So here I used a star to create a variable. I created a pointer.
But down on line there, I'm not I'm not doing a variable declaration P already exists.
So star in conjunction with an existing variable.
D reference is a D reference.
Is it so star online I'm using that to create a pointer star on line 
I'm using it to d reference a point that I created already.
So those are two different things. And then also the ampersand is two different things in two different contexts.
So let me actually just copy and paste these lines over here. So the ampersand in conjunction with an existing variable, takes its address.
And I did that on line when I took the ampersand X there.
X exists. I created it on another line. I'm just getting its address on line and also on line 
X already exists by the time I hit line I'm just getting its address by using that there.
But if I use the star. Oh, sorry, I'm actually mixing.
I'm getting this backwards over here. The the ampersand in conjunction with a variable that already.
Oh, no, I copy the wrong thing down here. I don't know this thing over here.
Nope. When we use it in conjunction with an existing variable, the thing that I was saying is what is the correct thing there,
which is when you use it in connection with an existing variable, gets the address.
If you use the ampersand in conjunction with a variable creation, what does that do for us?
You can just shout it out if you know. Yeah, it gives us a reference.
Very good. So up here, when I did. Oh, I wasn't actually using a reference anywhere here.
If I don't know if I passed something in here by reference,
like suppose I passed a vector of integers and I put a reference like that, this is involved with the, the variable creation here.
It's attached to the data type. It's in a segment of code I've highlighted that is creating a variable x.
When I use the ampersand there, I'm actually creating a reference.
But when I use the ampersand down here on an existing variable that gets a memory address.
I'm sorry that C++ does that to you.
I didn't create the language and there are actually people who are very anti pointer in the world that are people who say this is one of the
most crazy things that no one should ever have to deal with in a programing language is memory management with pointers and so on and so forth.
And actually a lot of languages abstracts away from us.
The stuff that I'm doing with pointers today where I'm applying the, the, the star operator to do reference things.
Actually, that's what references do behind the scenes automatically.
And the original C language that wasn't a behavior references didn't exist in the C language.
We only had pointers.
And so references are kind of an evolution of this that are a little bit nicer to play with than what we have with pointers and whatnot here.
Okay, so that's how we d reference things. That's where we are. The star operator means different things in different contexts.
Oh, by the way, you can create pointers to different things.
So sometimes I sometimes do this where I, I create a pointer in class using int star P and then I'll ask someone to create a pointer to a string.
And so we have like a string S equals hello like this and ask them to create a pointer that string and they'll say aha.
INT star PR equals the address of my string like this.
But remember, and people sometimes do this because this is just what they've seen and it's
the first pointer they saw and they just remember int Star creates a pointer.
But remember when I create a pointer, I don't just want to do it star, I want to do data type.
Star data type is whatever this pointer is going to point to.
So here I would type string star p tr gets the address of that thing.
P TR wants to point to the address of the string and I gave it the address of a string.
So you can do that there. And by the way, you can have multiple pointers to the same place in memory.
So you could do something like this. You could you it start. Q also equals that the address of X Oh, what else could I type here actually like?
Suppose I wanted to create another pointer queue, so let me actually create that over here in memory.
I'll create another pointer queue if I wanted to create another point and this has to go,
you know, I'll just give it its own separate memory address over here.
If I wanted to queue x, one of the things I could type here is queue equals the address of x,
so that would take the address of X and put it inside this box called queue.
Can someone raise their hand and tell me what's another thing I could type here to make x point to.
Sorry to make a queue point to x and don't say x by the way, because if you say queue equals x,
that when you say equals x, that just says whatever's in x. Let's try to put that down here in queue.
Oh that's not going to work out so well. So what else could I type here besides putting the address of X if I wanted queue to point to this thing.
Does anyone see it? Yeah, go for it. Who? Start acting like this.
If I do this na like this. Can anyone does anyone want raise their hand and tell us like, what would star Pete give us?
Yeah, go for it. Give them a piece of. It doesn't give the location of its story.
Doesn't give the location of P. Yeah. Yeah.
Yeah. The star says follow the thing that he's pointing to.
So go to the address. Seven f, cand the star P.
Once we get there, it'll just pick up the thing inside the box.
So if I star P right now that's saying go into the box that P is pointing to and get me the thing that's there,
get me that and I don't want to put a in the box called. Q So does anyone see what the alternate the solution is here.
Yeah, you wanna go for it? So another proposal is let's do ampersand P If I do ampersand P, though,
that's given Q the address of P and remember online it says Q wants to point to an integer.
That's Q's preference or orientation.
It wants to go to the club and hit on integers and get their addresses, which I guess is a bit intrusive.
Like why are you asking someone where they live?
Where you okay, don't take like that's not meant to be advice on how to go to a club and get someone's.
Maybe they're trying to get someone's number. Yeah. Let's go back to the phone number metaphor here.
So what we're doing two Q online 
Oh, what a coincidence that you're using the letter Q here.
So, so so what we're doing the Q on online is we're kind of not ordering its preference like it wants the address of an integer,
and we're giving it the address of something that it's not into. We're giving it the address of P, and P is an integer pointer.
Q doesn't want the address of integer pointers. That's a data type.
It's not into its into integers. So what could I type here?
What could I type here to give it the address of x other than just typing the address of x?
Does anyone work? Yeah, just regular old pe. Ding, ding ding ding ding.
So p, when you go to this box called P, we find inside it this address and this is saying whatever is in the box copy,
put it in the box called Q So that would take this address of X and put that down here in the box called Q So this is the solution,
and I'm glad that people shared those other answers so we can explore what those would mean and why they're not the correct thing, right?
We don't just want to set it equal to X or star P or the address of P.
It's really P itself that does this correctly or the address of X.
We could do it that way too. Okay. So that's just kind of like some some side knowledge there.
Let's move on to another thing. Oh, let's write a function using pointers.
So we earlier this quarter wrote a treasure hunt function that did something like this.
We could do like int treasure hunt. And we did.
We actually did this. We had like references A, B and C, and we passed in references to various hoards and we had our total booty was equal to zero.
And then we said total booty plus equals A, B and C.
So we went through and just like robbed these treasure hoards and then we set A and B and C all equal to zero.
And then we returned our total booty from this function.
And so down here, let me maybe get rid of some of this stuff over here a little, maybe come up at some point in the lecture today.
So down here we could do something like this. We could do it. Treasure hoard one equals gold pieces.
Treasure hoard two equals gold pieces, treasure hoard three equals gold pieces.
And then we could do like see out treasure hunt and we could give it our treasure hoard.
One treasure word. I don't know. It's not doing the whole thing.
They're trying to hoard one treasure or two treasure, hoard three like this.
And because we're passing those by reference, not only when I give this a run, do I expect that this is returning.
That we got a thousand gold pieces from that plus plus 
But if I then down in mean tried to print out what these treasure words are equal to what I should see is that they've
they've been robbed they've been emptied out here they've been zeroed out because I passed these by reference.
Right. I passed them by reference.
So when I set those things to zero, A is a reference to this, B is a reference to this, C is a reference to treasure worth three.
So when I get back to Main and print those out, I see. Indeed, those were all robbed.
Those have been set equal to zero. Now if I wanted to do this with pointers instead.
So pointers can help us accomplish the same thing.
I could pass into this function memory addresses and if I pass into this function memory addresses,
then what I would do is I would enable the treasure hunt. Oh my gosh.
It's like I'm passing it a treasure map. The address where the treasure hoards are located.
Let me pass those in as pointers. So if I wanted to pass these in as pointers, what I would do here is give it the address of this treasure hoard,
the address of this treasure board and the address of this treasure hoard.
And then if I'm passing in addresses, those are no longer references.
Can someone raise their hand and tell us, like,
what should be the data type here for A If I'm passing in the address of that integer, what should I type you exactly?
Go for it. Say it. Say it louder because I'm old.
Say it again. Star like this star.
It started. Yeah. Yeah. Hurray. So it's a pointer over here.
So we just make each of these pointers like this. And what I have happening now is.
Initially in Maine, I had created these treasure hoards like this that each had their own addresses and contents.
And then I called this function, this treasure hunt function,
and I've created three variables A, B, and C, And what I want to know is what did these contain?
Like the way that I've called this function, if these are my variables and these are the addresses where those things are located,
what should I put inside this box so that it represents what I actually get when I call the treasure hunt function.
You can just shout it out if you see what I should put inside this box. Or you could raise your hand, because now I think you're probably too shy.
The moment has passed to just shout it out. What should I type inside this box so that it accurately represents what I'm doing here in memory?
Yeah. Go for it. Would it be? Yeah. I'm just the just the box that I'm highlighting right now.
What should I put there exactly? Should I type the number five?
Should it have the value? Go for it. 
Sorry. I got so excited. I started saying with you. What were the last couple days of that?
Yeah. C So I took the address of Treasure Ward one and passed it up here and put it in the pointer called A.
That's the address of Treasure Ward one and I'm putting it in the variable called A.
And similarly for the address of treasure words to that stored in the variable
B and the address of treasure Hoard three goes in the variable called C.
So these treasure hoards now have the addresses of those hoards back in main.
The problem, though, is if I just say equals B equal C equals zero, that doesn't actually zero.
Those things out back in mean that would just set these boxes here to have values zero inside of them.
And that's not the desired effect. What I want to do is actually go back to these boxes here and put zeros inside of them there.
So what do I need to change about line ? Can someone raise their hand and tell us if I actually want to go back to Main?
I don't want to put zeros. I don't want to set a equal to zero, be equal to zero C equal to zero.
I want to get here and put a zero here and put a zero here and put a zero here.
Can someone raise their hand and tell us, Yeah, go for it. But yeah, I'll put a star in front of each of these variables.
Amazing. So that says go to the address A is pointing to and go to the address.
B is pointing to go to the box that C is pointing to and put zeros in all of those boxes over there.
The other thing that this is upset about right now is it's saying you don't want to add to total booty.
A If I tried to add A to my total value here, that's adding seven for to C to my total value.
That's not the number of gold coins that are at that location in memory.
So what should I change about to actually steal the treasure at this particular address?
Do someone want to raise their hand and go for that one? What needs to change to actually get to that address and steal the treasure?
Yeah. You go for it when you get started. Yeah. Wait.
Do what? Star. Star. Okay.
Yeah. I thought you said star. And then I wasn't sure if you said star hint. And then it was like.
I don't know. We have to have a discussion if you want me to just type star into here. Okay. Yeah, I would just.
And what is that called? Everyone. When I applied the star operator, I did reference those variables like that.
So this says go to the box, pointed to by A and steal the gold pieces due to the box pointed to by B steal the gold pieces.
Go to the box point that you buy C steal those gold pieces and want to give this a compile and run.
You see that we do in fact get that behavior. We stole all the treasure and we got back to Maine.
These were all set to zero. So pointers.
Tara Pointers are wild. And if you're looking at this, I don't know what you're thinking as you're looking at this.
I don't know. If you look at this, something like that, dude, we got it. Or you're looking at it and you're like, Oh, we got other stars everywhere.
We don't know what's going on. I don't know how many of you feel kind of, okay, like this is kind of coming.
Okay. Lots of hands are going up there. Okay, great. Okay. So that's what's going on there with the treasure hunt.
Oh. Bloody Mary blah.
Let's maybe shift gears then and talk about something else. Oh, hurray.
I've been waiting for it. I thought you were just going to interrupt me midstream earlier and just starting proof.
It was like, Oh, no, it's and they're going to we're in the middle of the treasure hunt and they're going to.
You did like the perfect timing. That was amazing. Like you waited politely for a little bit of a gap.
Okay, So I want to prove to you that this vector is actually different from this vector here that I was getting in in Maine.
And my question to you then is, why don't you prove it?
How would you prove, based on what I've given you so far?
So I mentioned the thing that I was saying was that this is Oh no, create random vector over here.
I modified that function's signature at one point because I was just about something.
So what I said is the vector that I created in here is a separate vector from the one that I created down here.
And when I returned that vector that actually just copied it into this vector down here.
Does anyone have any thoughts on how I could prove that to you using things that I've already talked about in class so far today?
Where are you raising your hand? I don't know. Yeah. Perfect.
Amazing. Yeah. What I could do is print out the memory address of each of these.
So if I do over here, see out V's address in create random vector,
and I'll just print out the address of V, and then I'll copy and paste that line down here.
But this will be the address of V down in main, and I'll just show you.
These are two actually different vectors. They're located at two completely different addresses.
So this address up here ended in zero zero. And this one down here, BD zero.
So those are actually two different copies of the vector. It's not just the same vector in the same place.
So what I said to you was true. If you had this vector with a billion elements and you returned it over here,
a billion of those elements had to get copied over, that's a slow, sad operation.
And so what I want to do on Monday is actually create a function where the vector we create inside it will be immortal and live on.
And when that function dies and I can just hook this using a pointer,
I'll just hook a variable and main up to that vector that I create in this function.
But that's for Monday before we get there.
There's another thing that I want to talk about with you that's kind of somewhat related to two pointers, but it's a little bit of a shift in topics.
I want to talk about arrays. How many have seen arrays before?
Can I just get some clear hands? How many have not seen arrays before?
Because when you don't raise your hands, I never know if you're just shy or if the answer is the negative.
Okay, so an array is basically a vector with a couple key differences.
So first of all, an array is a built in part of the C++ language.
It's going to give you just a bunch of elements that are numbered zero through however many there are minus one.
So if you have a vector of five elements, you know, those are numbered zero through four.
Similarly, an array of five elements, those are numbered zero through four, just like vectors.
Arrays are homogenous in terms of their data type. You can create a vector of integers.
Those are all going to be integers of an array of integers. They're all integers also just like vectors.
The elements in an array are stored continuously in memory.
They're right next to one another in memory. Here's how they differ from vectors, though.
One vectors expand automatically. You want to add something to a vector.
The vector is like, okay, I'll take care of that. Behind the scenes of actually a vector.
Behind the scenes is built using an array. And behind the scenes, what it has is an array.
And if you try to add too much stuff to that array, it actually just creates a new array,
Copies the stuff from the old smaller array into the new array gets rid of that old, smaller array.
I was like, Yeah, I've got this now spacious array. And when you call out, I can continue to add elements behind the scenes.
Arrays don't do that. They don't expand automatically.
The other thing is a vector. If you try to go out of bounds in memory,
suppose you try to go to vector index negative one or you have a vector of length five and you try to go to index five.
Remember zero through four for the valid indices. Five is not the vector will actually crash your program and give you a useful, useful error message.
That's like, Oh, you tried to access index six. That's not a valid index in this vector.
The array is just like, okay, low. So let me show you that the syntax for creating an array is you do data type and then your variable name,
and then in brackets how many elements you want to store.
So if I want to create an array of length five, I would say int that's my data type and I'll maybe just call it a RR for array.
And if I want five elements in there, I just do that.
I now have five integers. What was the C words that I just used?
They're arranged how in memory there can contiguous.
They're contiguous in memory. They're all right next to one another.
And if I want to play with those, I do the thing that I've done before so I could do for int equals zero is less than five
I plus plus and maybe do like array sub I equals and I'll do I plus one times ten.
So you know, the indices here are going to be four.
If I add one to those and multiply by ten I'm getting ten, 
And so I could then go ahead and print this out for I equals zero.
I is less than five I plus plus a race sub oops array sub I I'll just put that out see out array sub I and l like this and I get my ten,
But if I try to.
So here's a terrible thing that happens with arrays. Suppose I try to go to index like this and I try to put the number there.
The program just oh no, the program didn't die.
I was hoping it would die. It's not crashing.
This is just the worst. It's.
I want you to be unhappy with me. Let's go to position million.
Okay, So just crashes here. And the error message isn't helpful.
It just says we're right. When your program crashed, bad things happened.
You went somewhere to an invalid memory address. This is what we call a segmentation fault.
Here's. Here's what this means.
When you do a race and you put a bracket there behind the scenes, what C++ is doing is it's saying, okay, like a race up three.
What you want to do is starting at the beginning of the array, you want to that's the race up zero.
So you want to jump forward three cells, one, two, three.
So just does some math behind the scenes and it very quickly figures out what address should I go to for that element.
It just jumps to that address. That's an order, one operation.
What's the other word we have for order one? That's a runtime that is constant, a constant runtime.
So it's just really, really fast like that. The problem with the reason C++ is even if you have an array that's a small,
it's got five elements and you're like, Let's go to position in the array.
What C++ does is it's like, okay, I know where the array begins.
If you want to move elements forward, I can compute what address that would be at.
And it just jumps to that address.
Even though this was the array right here, it just figures out cells forward from this address would be way over here and it takes you there.
And sometimes that takes you to a segment of memory that you shouldn't be in and that will crash your program with a segmentation fault.
It's called What's Worse is actually what I showed you before.
So. So sometimes you go so far out of bounds in an array that you're somewhere you shouldn't be.
Your program crashes, but this was actually the worst thing over here where the program didn't crash.
And you might think like, Well, no, that's great. My program didn't crash. I love when my program doesn't crash.
That's like a good day for me when my program doesn't crash. And yes, I feel that way as well.
But this is really bad because it went to somewhere in memory and wrote in number and who knows what it just corrupted in memory.
That could have been a flag. Are you okay? Who are you laughing at?
Me or something else? Like you're in the array. Why are you laughing at the array?
Oh, because it wasn't supposed to go there. Oh, yeah. That was like minutes ago that that happened.
There was like, a lot of people laughing and I was like, Did I just say something like, silly without intending to?
I was like, What's happening here? Okay, yeah, it's great. The the array is bad.
Things are happening behind the scenes. We love to see it. So but the problem is it just went to a position.
It's like, lo, let me write the number there. What if that was the variable that said like the user has not been authenticated?
Don't let them into this bank account and you just go put the number there and then someone comes through later in the software and they're like,
Hey, is this variable set to true? And C++ is like, Yeah, the number sounds true to me and it's let someone into a bank account.
This is actually a genuine thing called a buffer overflow attack where people will
figure to look at source code and figure out that something unsafe is happening,
where someone's going out of bounds in an array and they're like, Oh,
if I take advantage of that and go to this position and write a value there, I can actually break the software in a way that I can benefit from.
So you could Google Buffer overflow attack if you want to read about it.
And in fact it's a watch this int x equals ten maybe actually when we put actual numbers like two, int y equals three into Z equals four.
I used to do this example in class where. So check this out, I'll do see out and I'll print X, Y and z on separate lines here.
And I used to do this example where you so these will print two, three and four because I set them equal to two, three and four.
But then watch this. Let me just go slightly out of bounds in this array too.
Like, you know, it has indices zero one, two, three and four. Let me go to index five and set that equal to and then I'll print X, Y and Z again.
And it used to be that when I compiled and ran this sort of, Oh, sorry, I just want to print them again.
When I compiled and ran this in class, what would happen is X would it?
Because I declared X right after the array, it would be like x would get overwritten and oh, I need a semicolon here, X would get overwritten.
And what you see is actually two, three, four, two, three, four, X didn't get overwritten.
And even actually you might conjecture that oh, maybe these are being like declared in reverse order X, y, z.
If you put them ahead of the array, then you'll get the behavior there where they're actually just after the array.
And that actually doesn't work either. What happens many years ago is compiler creators got smart and they said people create arrays and they tends to
accidentally go past the end of an array and overwrite important values that are just past the end of an array.
So what my compiler is doing right now and what it was doing when I did this as well was it said,
I know you're a programmer and I know programmers make mistakes instead of putting the array here and these variables here
and then you as a programmer make an error where you go out of bounds in the array and accidentally overwrite these,
the compiler is like, Let me just make sure these variables come in front of your array behind the scenes.
No matter what order I declare my array and my my integer variables in it's rearranging them.
So the arrays, the array actually comes after the integer so that if I go off the end of the array,
I don't accidentally corrupt one of those integers. And so you can actually see that by printing out the addresses.
If I actually print out the address of this, this and this.
And then how do you suppose I would get the address of the very beginning of the array?
Well, what is the very beginning of the array, Everyone. It's just Yeah, array, subzero.
And if I put an ampersand in front of that, get the address of array subzero.
Here's what you'll see with the addresses is this is one C 
Okay, so comes after the and then once you use hexadecimal, don't worry about what that means right now.
But indeed it's coming later in memory.
And even if I rearrange these and I'm like, Oh, let's put them in front of this like that, and I then give this a rerun.
It's always setting it up so that the array comes after these over here, so that if I go out of bounds in the array, it's not corrupting these.
But I came up with this instead. What if we go backwards past the array like this?
So if I do negative one, negative two. Now what you see is indeed.
Oh, I guess I should print these for you. What we'll see is that some of these have actually gotten corrupted now a ha.
So Y and Z actually got corrupted. So if you go out of bounds in an array, you can overwrite a variable accidentally.
And this is so frustrating because like if you have a bug like this and you're
unlikely to type negative one because that's never a valid index in an array,
but if you have a variable I and you're not careful, go to a for loop that can that variable,
I can become negative and then go out of bounds in your array.
And so what's really terrible about this bug is you're looking at X, Y, Z, you're like, I initialized X, y, z, I printed them.
I didn't touch variables X, Y, Z on these lines of code, but somehow here they've changed.
And this is really frustrating, especially if instead of two lines of code in between those statements,
you have or or lines of code and you're like, How are X, Y, and Z changing?
I never set them equal to something else. It's often that people just went out of bounds in an array.
The reason I'm showing you arrays is because we will use those.
I mean, those are used to build the vector class and so we need to know how to work with and play with those things.
The array, by the way.
So one of the things that I just did down here was I printed out for you the address of array subzero, the address of array subzero like this.
And I also want you to know that what I call a naked array variable name, if you just print a RR, that variable,
that array variable without any brackets at the end and I give this a compile and run,
what you'll see is that is actually synonymous with the base address of the array.
So I could go through and print the addresses of all of these cells individually.
I could do four equals zero is less than five I plus plus.
Let's just go through and print the address of array sub I and you'll see that starting at
index zero here we have whatever that address is and then let me do another end over here.
So this is kind of like separated from the rest. So you'll see that each of these cells in the array has a different address.
But the address of cell zero, that is what you get when you just type this naked array variable name.
And by naked I mean it's not dressed up with any brackets or anything there.
So what's happening behind the scenes when you apply brackets to a variable is C++ is going, Oh, you want to use square brackets.
What that means is the thing to my left air must be a memory address, the address of the first element of that array.
In this case, it's the address of an integer in an array and a memory address is just a pointer.
So kind of behind the scenes, an array variable name is very similar to a pointer.
In fact, you could do this down here. I could create a new integer pointer and set that equal to a r r.
So this is that address that ends in C 
I'm putting it in a new variable here. P I'm putting that address that ends in C inside this variable.
P This is Now if I printed it out, it's the same thing as what I've got up there.
But watch this. Let me just first of all, just put that out and show you.
Okay. So P is also pointing to the beginning of the array.
R is kind of a pointer to the beginning of the array. P is also pointed at the beginning of the array.
Well, that means that using my knowledge of square brackets, I should be able to do this.
I should just be able to replace this with P and print out everything that's in that array, loop through it and print it out.
So this is just the base address of the array.
And when I apply brackets to that, that's going to say, okay, go to that address and skip forward by zero integers.
Go to that address, Skip word by one integer. Go to that address.
Skip forward by several integers, and this will print out the values that are inside the array.
And I deleted the loop that was. Let me actually go back and put some stuff in the array.
So a race of I equals. I'll just set a race about equal to I plus one.
So I'll have one, two, three, four, five in the array. And when I use P to put that out, I've just got that base address there.
The brackets are just D referencing the base address behind the scenes.
The key distinction between a pointer and an array is that the array variable this RR is bound to that location.
I can't do like RR equals the address of x.
I can't change that. If I try to do that right now, it'll refuse to compile and run and be like, You're trying to change this thing.
That's not allowed. But I can speak with the address of X, so a regular pointer that I create is allowed and I need to initialize this to something.
A regular pointer that I create is allowed on.
Re declaring that thing actually exists above a regular pointer is allowed to point to new places in memory,
but when you create an array like this, its length is set in stone and so is the place that it's pointing to in memory.
And on Friday we'll use all of this pointer magic to create immortal data structures inside our functions.
Thanks for being here, everyone. I'll see you on Monday.
Alrighty. Hello. Hello. Happy Monday, everyone.
Hello. Hello. Hello.
Hello. Whenever you're.
Whenever you're ready. I'll wait for you if you want.
If you want to continue the conversation. Okay, great.
So let's go ahead and dig in to some announcements really quickly here.
You, of course, knew that your exam is coming up this Thursday, to p.m.
If you have accommodations, Clinton should have sent you an email saying where you should go for that exam.
If you do not receive that email, then contact him. But for the rest of you on the course website and in an announcement,
there's a list depending on what your last name begins with, of which rooms to go to to take your exam.
There are some exam review materials posted online and there will be actually a review session tomorrow,
Tuesday, and the details for that have not been posted yet.
But keep an eye on edge for an announcement about when that will be a friendly reminder.
There's no lecture this Friday that's just for this class that I'm giving you, Mental Health Day.
I don't want you to think that that's a Stanford wide thing and you just skip
all of your classes and then this is maybe a little bit of a curveball here.
Sections are canceled this Thursday starting at p.m. So from p.m. onward, if you have your section at that time,
that will not be happening, partly so that you have a little bit of a break leading into the exam.
What will happen is we'll post an announcement sometime soon on edX about how you can make up that section.
You do if you have a section p.m. or later on Thursdays.
That will not happen this week. But you do need to make that up. And the details on how to make that up will be posted in AD.
And what we'll probably have is some of the section leaders are pitching in to create some alternative virtual sections for the week.
But for those of you who have an in-person section that is not p.m. or later on Thursday, you do have to attend your normal section this week.
So all those details will be coming in. Ed, and the exam is coming up this Thursday.
Hopefully you're having a good time preparing for that and having fun with this material.
I want to dive in today to a topic that combines what we talked about last week, classes, object oriented programing.
And then on Friday of last week we talked about pointers.
So I want to mix those two together and to remind you of a problem that we looked at last week.
I talked about this problem here where we write a function that creates a vector
that just is populated with random integers and return that vector back to main.
And if we give this a compile and run, you see that we get the same results, the same vector in both these functions.
I'm printing that out on line I printed that out on line One is in the function, one is back in main.
We have the same values in this vector. But one of the things that I showed you last week is these are actually different vectors.
If I print out the address of this vector over here and the address of the vector back in main, remember that ampersand symbol gives us the addresses.
You see that these are two different addresses right here.
And whether you read hexadecimal or not, you can see that those values are different, even if you're not sure what this values mean.
And that's okay for this class not to know what the hexadecimal values mean exactly,
but just to be able to look at them and know that these two are different. So this is happening at different addresses.
So the big issue here is if that vector is really huge, if we put a billion elements into that vector and we tried to return that,
to me that's taking time to copy all billion of those back to mean.
And also it's for a split second, they're taking up some extra space.
You have the billion elements over here, you create the vector add main, you're copying them all back and then these ones disappear eventually.
But there's this like split moment. There's a split second of time where you have all those values may be represented multiple times in memory.
But the main consideration here, the main problem is the amount of time it takes to pass those things back.
So I want to solve this problem today by creating showing you how you can create things that don't just die when you leave a function.
Let me first give you another example to show you that that things die when we leave a function.
And you might remember from when we talked about recursion that when you call a function,
what is the data structure that's keeping track of all the function calls? It's the the call stack.
Yeah. So all these calls are going on the call stack.
So the variables that you create inside a function, when you make a function call, all of those are part of the stack frame for that function call.
And when you leave that function and it gets popped off the stack, all the variables associated with it die and go away as well.
So we want to create if we want to create a variable that lives beyond the lifecycle of a function,
we actually need to find somewhere else to store that thing besides the stack frame,
because the stack frame is going to be cleared up when we leave that function.
But let me show you really quickly another example that kind of shows that when we leave a function, our variables die.
Let me go back to really quickly here just creating a class.
So let me this is the subject for today's dynamic memory, and I'll talk about what that means in a second.
But that's the name of this program over here. Let me add a new class. Remember to do that.
We right click over there on our project. We had a C++ class.
I just want to go back to basic Quokka class here and throw down some some code for you really quickly.
And probably this will maybe just be a little bit of quick reinforcement for some of the stuff that we saw last week related to classes.
So you see these files have populated through to my project.
Over here I have Quokka, dot H, quokka duck soup. What is this function called that has the same name as the class?
I just created everyone. My constructor, it's called automatically when I create a new Quokka.
And then if I put a tilde in front of that, what's what is what is this function called?
Everyone The destructor. It's the function that's called automatically when I leave or sorry when one of these quokkas.
The variable dies when it goes out of scope, when it's removed from memory.
So let me write a function here, a constructor that takes a string name, and I'm just going to give each of these quokkas a name.
I'm going to do something really light basic version of of the Quokka class.
I'm not going to implement all the functionality that we saw last time.
Remember, when you implement these functions in your CP file, you need to have the class name colon, colon in front of all those functions.
This is my destructor function over here and I just want to print a little message that shows us, Oh, this will be string.
This is the name I want to print a little message that just shows us that the constructor was called and a little message that
shows us that the destructor was called so we can kind of track where these things are happening in order to use a string.
I could maybe include IO stream like this and then using namespace stuff like this to get that string area to go away over there.
And then I'll just do this. I'll say the name and remember I use underscores for class variables.
For those member variables are their name equals the name that we passed through in this function.
And then I'll just do SEO. Hello, and then I'll do the name exclamation point.
So just do a little hello message. And then when this destructor is called, that means the quokka is dying.
And so I'll say RIP. And then the name of that quokka over there like that.
And over this and over here, like this. And then you see that I'm getting the red underline over here.
Maybe let me include I could include string or io stream and then using namespace steady to get that string oops using namespace steady.
And you see that when I save this, the red underline here goes away.
What did I do badly just now in terms of how I made the error string was underlined over here in my daughter file.
What was bad about? Yeah. Yeah. Go for it. Was it Michelle? Yeah. Yeah.
Michelle, what's up? Yeah, very good.
We never in a dot age file want to using namespace and then put a namespace
because then when someone pound includes the start each file in their program,
that namespace automatically leaks into that thing. Maybe they wanted to use a different namespace and now extrude them over by making that leak over.
So we don't do that in our H files. We do. STD colon.
Colon. To get access to things in the standard namespace in our data file.
And then over here I'm including Quokka on H.
So that's okay. Like that. Let me then go to Main and I'll just get rid of this huge.
I want to just do that for now. Let me do here. I'll just write to create Quokka functions.
So create Quokka in main. Like this and let me write a create a function.
I'm hesitant to delete this. I don't know if I'm going to want it back.
Let me actually just put it over here in a graveyard file in case I want that thing back.
So let me just do void create Quokka. I really just want to call that Quokka constructor.
Create Quokka and give this thing a name Muffin face.
I'm calling that constructor. Oh. In order to call that, I need to include Quokka h over there like that.
So then what am I even doing here? Quokka queue, muffin face like this.
So when I give this a compile and run, you see that we got Hello, Muffin face and R.I.P. Muffin Face.
I want to give you an indication of where this thing is getting created and where the destructor is getting called.
So let me pepper this with some C out statements. So you see out about to call create Quokka, and then I'll kind of pause the program a little bit.
I'll just run this and get mine from function from our Simple Zero library.
It'll just pause and wait for me to enter a line so simple.
H So I want to print a bunch of messages, but give a little bit of a pause so we can see the behavior step by step.
This is we returned from Create Quokka when we get here.
And then here I'll say we're now in create Quokka and then I'll create Muffin face over there and then I'll say about to leave, create Quokka.
And so with this functionality over here will be able to let me actually just kill that window over there and do this one over here.
So with all these lines, with all these lines here, this output available to us,
we should be able to trace through and see exactly where the quokka is getting created and destroyed and so on and so forth.
So it says about to create Quokka.
So right now I'm paused kind of on this line right here we see the constructor has not yet been called, so we're about to create the Quokka.
And then when I hit Enter, it says We're now in Quokka. So I went to this line here we called Great Create Quokka.
We're up here on this line. We haven't yet created Muffin Face. We're just kind of paused above the clock.
And I want to hit this again. It says, Hello, muffin face, and we're about to leave the Quokka function.
So I'm paused right now on this line where it's waiting for me to give my input.
It just printed. We're about to leave the Create Quokka function. But before that you see that the constructor was indeed called.
We created Muffin Face right there on that line, line 
And then when I hit Enter again, what you see is we hit this line here that says we returned from Create Quokka.
But before we get that line returned from Create Quokka, it printed R.i.p muffin face.
So r.i.p muffin face that Quokka dying was not because main it terminated.
In fact, Main is not terminated yet. I'm paused online I have not yet reached return zero in Maine.
Maine is still life as of right now.
But when I left the create Quokka function, that is when the Q variable went out of scope and when the Q variable went out of scope,
that stack frame got eliminated and all of the memory associated with it got cleared up,
that Quokka got cleared up also, and the destructor was called behind the scenes.
That's where our AP muffin face comes from.
And then if I hit enter here, then the program actually you might have seen over here that the program finally terminated.
So the moral of the story here is when you create something locally inside a function, if you give that function, it dies.
And I want to create things that can live beyond the lifecycle of that function.
Again, because of that vector example I gave, if I created something huge inside a function, I don't want have to return that by value.
I want to be able to just have that thing live on and and find a quick way to just have that one
thing in memory and return information about where that is to the function that called this one.
And so that's where this new technique called dynamic memory management or dynamic memory alcohol management.
What I'm going to show you first is dynamic memory allocation.
I'm just going to show you the incantations we use to create a variable that lives beyond the lifespan
of our function in order to create something that's going to live beyond the lifespan of our function.
Instead of doing this traditional. This is how we've done it so far. We've always done data type and then variable name.
That's how we create variables of a particular type in C++ in order to create something that lives beyond the lifespan of our function,
we actually use the key words new data type to create a new one of those.
So what I'm going to do to create a new Quokka is I'm going to type new Quokka and I can call the constructor and pass that muffin face.
I'm going to create the Quokka that way.
So new Quokka, so new data type is going to create a variable that lives beyond the lifespan of this function.
Now, I haven't given this a variable name. I've just said this is new and then the data type for what I want.
What this does, when you do new data type, it not only creates this in a place in memory that isn't going to get cleared up,
so it's not creating it in the stock frame.
Because remember, when Create Quokka returns, the stock gets popped off the stock frame and everything inside it disappears.
So new creates this in a separate place called heap space.
So let me write that up here for you. So we're going to create this thing in a place called heap space.
And what new does is it returns to you a pointer, a memory address to where it just created this thing.
So if I want to hold onto this thing that was just created for me, new is giving me the memory address where it's stored.
I need to create a pointer variable in order to store that thing. So I'll do here, I'll do Cuoco.
Star Q equals this. So again, the paradigm here is new is giving us a pointer to that thing that I just created.
And so I created. Or is returning the memory address where that thing is.
So I created a pointer variable, a quark a pointer called Q Q gets the address of that particular Quokka.
And if I give this a trace now, let me actually kill the program and rerun it here with with this pointer happening at this point here.
So let's restore and see what happens. So I'm about to call create quokkas on pause right here on line 
Then I hit enter and it's like we're in Create Quokka. So we've gotten to this point right here.
And then I hit Enter and it's like, Ooh, we've created muffin face.
This variable now exists. I called my quark constructor, created Muffin Face.
I did it. It's this is called Dynamically Dynamic Memory Management.
I'll talk a little bit about what dynamically means in a second, but I created that dynamically.
And now we're paused here on this line. We're about to leave the Create Quokka function and watch what happens when I hit enter.
It says Down here, we've now hit this line. It says, We returned from Create Quokka, but we never got our app.
Muffin face. Muffin Face now lives This Quokka lives beyond the lifespan of that create Quokka function.
We've created our mortal clock. It just lives forever and ever and ever.
And that's actually problematic. It's just suffering eternally in our system.
It's not getting cleared out at all.
When you create something dynamically like this, and when I say dynamically, what I mean is we used the new keywords to create it.
We put it in a heap space instead of on the call stack.
So you'll hear people distinguish between heap space that's dynamically allocated memory.
That's stuff that lives beyond the lifecycle of a function versus stack space.
That's stuff that we put on the stack that's just local regular variable declarations like we've been doing so far all quarter long.
Those are on the stack. And when you pop the stack, those variables disappear with the stack frame that goes away.
So this one is in heap space. When you create something in heap space, it's up to you to kill it.
When you're finished with it. Stuff is created in heap space does automatically get cleared up when your program dies.
So actually you'll see here when I leave Main when I hit enter again to go past this line and hit the return zero back in main.
So let me hit enter. Um, it's actually still unhappy.
Oh, because we're bamboozling you. I forgot about this thing over here. Okay.
The program hasn't actually, like, totally terminated. This main is actually like a sub main that's kind of secretly running in this window over here.
You'll see that when I actually when I close this window down here,
we closed the window and it actually doesn't show us that muffin face got cleared up so that we didn't get a repeat muffin face over there.
So one of the things that you have to do if you want to clear this memory up and it didn't get cleared up behind the scenes, by the way,
when you when you close the program, the memory that associated with it,
your operating system does clear up all of the stuff that it was that it was using.
But if you don't want that thing to just linger in memory for the whole entire lifespan of your function, you have to manually get rid of it.
And if you don't, that's actually problematic. So imagine this.
Imagine that you open chrome or whatever web browser you're using and you load some sort of website and that's all maybe like rendered in heap space.
All of the data associate with that website's remember rendered heap space and then you close like whatever tab you're in.
Imagine if like if, if your web browser were poorly written and it didn't clear up all the memory that it was putting in heap space.
And you just continue to run your browser and like even though that tab is gone,
all that stuff is sitting behind the scenes, taking up space in memory and slowing your computer down.
And that actually happens in a lot of programs that are poorly written.
Have you ever run a program before where your computer just starts grinding to a halt?
But if you kill the program, all of a sudden your computer's like running faster, like you restart the program.
That's because that program is probably taking up a lot of memory or maybe it's
actually just taking up a lot of it's doing like a lot of intensive processing.
But if it seems to be doing nothing intensive,
like it's not doing an interesting task or anything that should be taking a lot of processing power and your computer's slowing down,
probably that's the result of that thing, having a bunch of memory that it's taking up and hogging.
And then your system's becoming really slow because it's like, Ooh, I don't know where to find memory,
to put other little bits of information for the processes that I'm running.
So your, your system starts to really slow down and freak out there So this might not look like a huge deal.
Like I created a single Quokka and here it lived beyond the call to this function.
This was taking up a little tiny bit of memory to store muffin face and any other.
Just a couple pieces of data associated with that particular object,
the clock that I created there, and that might not look like a huge deal, but check this out.
This is maybe a huge deal. What if I said four equals zero is less than billion?
I can't count and say billion at the same time. That's not a number in C++.
Okay. billion. And if I call this Quokka repeatedly, this create Quokka function.
This is actually a huge disaster right now. What's happening?
Every time I call this function, it's like new quokka in memory. And then I call it again.
It's like new quokka in memory. And there's a new clock in memory. New clock in memory.
It's just creating all of these that quokkas in memory. They're just filling up memory.
And so you can imagine if this auditorium were a memory and someone were doing this in a loop here, it's just quokkas appearing everywhere.
And eventually we would just all get asphyxiated or smooshed to death by the quokkas and die.
So it's another one of those really dangerous things about the one XP.
They're just a lot of ways that you can get hurt.
It's just one of six BE and one of them is this situation. We call this a memory leak.
A memory leak is when you've created something in heap space, but you've lost track of it, and so you have no way to access this.
I'm creating these pointers up here online at Team News, giving me the address where these things were created, and I'm just ignoring them.
You can almost think of this as like new is kind of like a helium balloon vendor.
And so what new does is it blows up a balloon and it hands it to you and that's that string that you would hold onto with that balloon.
That's the memory address that you would try to hold on to. Well, here what's happening is we're just kind of letting go of that string.
No one is keeping track of that of that pointer back in mean there's just like we've we've completely lost it over here.
So I have some diagrams to show you a little bit what's going on in memory.
Where even did I put my diagrams? Okay.
So initially when we were doing static memory allocation, this is what was happening.
I was calling this function. And in that function I had a variable called queue.
And when I left that function, poof, that variable called queue just got cleared out and I went back to Main.
There were no local variables and my heap space was empty. That was my the complement of or the opposite of dynamic is static.
We call that static memory allocation when you're not using the new keyword, when you're not using heap space,
you're just allocating things on the stack like using like int I or quokka queue.
That's called static memory allocation. This other one that we're doing now new is dynamic, so it's static.
You leave the function and poof, muffin face is gone. Here's what's happening with dynamic memory allocation.
So with dynamic memory allocation, when I first call this function and the dynamic Quokka, what happens this time is in my Create Quokka function,
I had a variable queue and I was setting that pointer queue equal to the memory address that new gave me.
So if I can go back to my code here, I said queue equals and I call it new.
So what you did was it created this quokka down here in heap space at some at some
place and then it returns an address and I stored that here in this variable queue.
This address where the clock was located was stored here in the variable queue.
And then when I leave this function, what happens is this queue disappears.
This whole thing, this queue variable disappears, poof like that when I leave the function.
But muffin face still lingers in memory because it's dynamically allocated, it doesn't disappear automatically.
We're going to have to get rid of that thing ourselves in order to make that thing disappear.
So we ended up with with that situation there.
Well, what I'm doing, what I'm doing now, where I have like this thing in a loop where I'm just calling Create Quokka over and over again.
Let's actually take a look at what that looks like in memory.
So this is I have these leaky quokka files where we can trace through.
So initially we're just chillin in main and like,
very kind of innocently approaching this for a loop and maybe not realizing our lives are about to get really terrible.
And then we call, we go into the sport loop and we call Create Quokka.
The very first thing that happens when we call Create Quokka is it creates a quokka in deep space.
And then I return from that function and that quokka is just lingering in hip space.
Nobody knows what address it's showing up because I didn't return that address back to Main.
There's no variable down in Main to keep track of where that quokka is. So just a quokka chillin in memory.
Well then I loop back around and call create quokka again. So I do this. Poof.
Another version of Quokka appears in memory and heap space, and then I loop back around and I call Create Quokka Again and poof!
Another version of that, Quokka appears in hip spaces. Every time I call this, it's creating a new quokka in memory.
They're all accumulating.
And in the background you just hear these quokkas screaming, desperate to be released from their their eternal suffering effectively.
So this is called a memory leak.
We have lost track of these quokkas. They're all just taking up space uselessly.
So the thing to do is, first of all, when you have a function that creates something that's immortal,
returning that point or back to whoever called this told you Quokka, this is going to return a Quokka pointer.
Let me get rid of all this stuff over here. It creates a Quokka.
And then let me return that pointer. So I'll return Q Q holds the memory address.
So when I return. Q that says whatever memory address, like what you've lost return that back to me.
And then in main, I'll actually capture that. I'll do here Quokka Star Q equals this thing over here.
So I'm creating a Quokka, putting the actress and Q returning it back to me.
And Maine has its own copy of Q where it captures that thing. So I've now got some indication of where that thing is in memory.
And I have then something that's more along these lines.
Like this. Initially, when I initially when I call this this urban to kick things out before I'm
finished calling create a queue just has some garbage and who knows what it is.
Then the first time in my group I call Create Quokka, which creates a quokka at this memory address.
That memory address gets returns to Main. So this happens like that.
So when I get back here after the first iteration of my loop memory looks like this.
If I keep on just looping around, what will happen is the cue pointer will just continue to point to new quokkas
and I'll just still have a huge collection of quokkas accumulating in memory.
What I need to do is before I loop around, before I lose this memory address and Q is set to hold a new memory address.
What I need to go do is go in here and say, I'm finished with this Quokka.
Let me destroy the quokka and the way that you do that, the syntax for doing that is you type delete and then you pass.
It will not pass. It's a keyword built in C++. After delete, you put the pointer, the address that you want to get rid of.
So CU holds this address right now. Bloody party boss zero zero.
I'm giving that address to delete and saying Hey delete.
There's some space taken up at cI dynamically allocated that space at one point, but I'm finished with it.
I don't want it anymore. Could you please communicate back to the operating system that that space is no
longer in use and other processes can come along and use that if they'd like.
And that's exactly what delete does. So new and delete are in cahoots with one another.
New keeps a ledger of all the space that it gives to you the addresses where all that spaces that set aside from it and then delete goes.
So that ledger when you pass the memory address and it gets rid of anything that was kind of stored at that memory address.
So delete queue over there, it's going to get rid of this. So after when we call delete queue, we actually get this poof,
this space gets cleared up and the operating system is like, Oh, I can go use that for other processes.
So instead of memory just getting cluttered and cluttered and more cluttered,
what we have is we use some space and then we clear it up and we say back to the operating system, you can have this back again.
So then as this continues to go, what we have is what even was this this was for.
So then I'll call it again and we'll create. This was at cwhen I call the function,
it'll maybe create a code at a different address and then that address gets returns to Main and put it in here.
And then I delete that poof before I do it back around and I call the function again.
And so for four zero, maybe it puts this a new socket e
That address gets returns back to Main right here like that.
And then I call delete on that and that poof goes away. That gets cleared up.
So this is now a memory leak free version of dynamic memory allocation.
It's creating a clock and then destroying it, creating a quokka, then destroying it, creating a quokka, then destroying it.
And maybe that's not particularly useful. It's a really it's a really basic example of dynamic memory management.
Not to say that it's like easy to understand what the heck is going on when we talk about dynamic memory management ever,
but it is doing nothing particularly interesting or useful.
But you could do something like this then with your create vector function.
So if you wanted to create a vector that lives on beyond the life span of your of your old man,
Before I forget, let me mention let me mention this really quickly if you want to inside this Quokka,
if you want to access the name and print it out, what we do is with classes,
if you have an object of a particular type, you do cute dot and then like the name that you want it like.
So this is the field. So maybe I want to print that out. You would normally do Q dot.
Well, this Q is not a quokka. Q is a pointer to a quokka.
And so one of the things that you'll see is when I try to access this using
the DOT and I do underscore name and I hit tab to auto complete this for me,
dot underscore name, it turns that dot into an arrow.
We use dots with actual quokkas or actual objects instances of some class.
If you have a pointer to that class, we use the arrow operator instead and kind of a way that you could maybe remember that is that arrow there.
Another word for arrow is pointer. It's a pointer thing. We use the arrow when you have a pointer.
So Q is a pointer. If you were just a regular old Quokka like I did Quokka Q one and then gave it a name like that,
you would do Q one dot underscore name to print that out.
But this is not a regular Quokka, it's a pointer to a quokka.
And so let me just show you that that works.
If I do see out over here and then you end out like that, if I give this a compile and run, Oh, well, it's got all of those messages.
Oh no, don't worry about that. There are a lot of it is a lot of Quokka creation and Quokka death was happening behind the scenes there.
So we could do the same thing with with our vector, just to kind of sketch that out if you wanted to do something like that vector.
INT And we had something like create a random vector like this, I would say this is how I do it.
I would say vector int like that pointer v equals a new.
Vector INT And having created that new vector of integers,
I could then loop through and populate it and then ultimately return V and I could capture that down here in this function.
By doing something like this, I could do vector int pointer v equals create ran the vector like that.
And if I give this a compiler run, actually you'll see that these two vectors are the same.
So if I see out, I don't here want to see out the address of the I'm just going to see a V itself.
V is a pointer. It holds the address of the vector that I just created dynamically.
And when I get down here to main, if I print out that again, this is a pointer, it holds the address of the vector that I created dynamically.
If I give this a compile and run, of course we see that those are the same address.
So if I put stuff into my vector up here and by the way, I wouldn't do v dot ad, I would do v arrow ad.
So let me just the arrow add ten, and and if I print the vector.
Oh, well, here's the thing. How would you print the vector?
Because if I print V, that's actually just the pointer to the vector.
Can someone raise their hand and tell us if I have a pointer to a vector,
I want to get to the actual vector so that I can print out its contents in the back in the blue sweater.
Yeah, I would start it. And what is that called? Everyone. It begins with the letter D I am D referencing the pointer.
Yeah. And so if I d reference it that says go to that memory address and print out what's there and you'll see when we get back to Main,
the contents of this vector lived on and managed to come back to me.
Oh, but I have a memory leak. Would I need to delete that thing?
I need to delete V like that and then give it a run again and okay, it still works through,
but when you have a memory leak that's so bad, it's like a little mini emergency happening.
You should be freaking out a little bit.
Oh, a kind of a rule of thumb is for every call to new that you make when you run a program, you should have a corresponding call to delete.
So in this program I called create random vector once and then create redo vector.
I used knew exactly once and so I need it since there's one new being executed here in the lifespan of the program,
I need one corresponding delete to free up that whole thing, to free up all the dynamically allocated memory associated with that thing.
So here's what I want to do with this information, and I want to build our own stock class in the time that we have remaining today.
And I want to create a stack that is just implemented using an array behind the scenes.
But the problem with implementing a stack using an array is like, suppose that in my stack class and I'm about to create a new class.
Suppose in my stack class I put just in there an integer array of like five.
Well, the problem with that then is I could put five integers in my stack, but then if I wanted to put a sixth integer in there,
I've got an array of like five and arrays are set in length once you create them.
We saw this on Friday. Once you create an array, it's set in length.
You can't change its length. And, and so that's actually where the word static really comes into play.
Dynamic means changing movement, evolving different static means same, not changing non dynamic.
So if I created a stack class that had something like this as one of its members,
it was just like int here are my elements and you could put like five integers in there.
We call this a static array declaration. It's always an array of like five that's static, that's bound there.
When I typed that number five, it's just always going to be an array of like five.
What I would like is for my stack to have a dynamic array inside it, an array that can expand and grow and accommodate new elements.
So my idea for that is this When I try to add stuff to my stack,
I can maybe start with an array of like five and I'll just add element stack thing and I'll treat it like a stack.
And then if I want to add more elements, I've got five in here already.
What I will do is I'll just create a new array that's a longer maybe of length ten, and I'll take these five elements.
I have it copy them into the array of length. Ten. I will delete the array of like five so they don't have a memory leak.
And then in this new longer array, I'll have some space and I'll continue going from there.
And I can't do that with static memory allocation.
If you call a function like push and you have a stack class and you're trying to push something into an array,
and in that push function you try to create a new array, but you do it statically a new array of like ten.
Well, when you leave that push function, the array of length ten disappears.
If it was created statically, we have to do it dynamically so that when I call push and it expands my array,
creates a new larger array underlying my stack that when I return from push, that array still has the ability to continue existing.
So that's the idea behind the stack is I'll start with a small array.
Oh, by the way, I'll just fill the array up from left to right and then when I pop.
So suppose I do this, I go, Push, push, push. Where should I pop from?
Should I pop the leftmost element or should I pop the rightmost element?
Right. Yeah, the rightmost. Because that's how stack work is.
Life of data structure. Right? If I go ten, then when I pop I should get my ten.
So I'll just add stuff to the end of my array and then I'll remove stuff from the end of the array as I go.
So maybe let me do this a little bit more concretely before I start implementing it.
I could create an array that looks like this and suppose I push ten, 
I'll push ten. Oh, and by the way, I'll keep track of behind the scenes what the size of my stack is.
So right now I have one element in that stack and then I'll push a 
So I've got two elements in my stack and I'll push a I've got three elements in my stack.
If this is an array, then you know that the indices for these elements are zero one and two.
If this is how I've represented my stack, I've got an array coupled with an integer the size of that thing.
How do I know what index to go to to pop my stack?
I mean, you and I can look at this and be like, Oh yeah, I'll go to the last index there. It's two.
But programmatically, how, where does the number two come from?
Just based on the data that I have on the screen that I'm going to store when I code up my stack, I'll have a size variable and an array variable.
How do I know what index to go to when it's time to pop that thing?
Yeah, go for. Yeah, it's always going to be position size minus one.
If there are three elements in your stack, you know that the last index is three minus one is to think of 
So size minus one always tells us what index to go do to pop.
Suppose this is an array and the array length is five.
And so actually I'll keep track of that. Also, I'll say the capacity of this thing is five.
I created an array that could hold five elements. I've only put three useful elements in there so far.
If I push a right now, I want to go to index.
Would index what I pushed for. Yet everyone just shouted out index three and how would you know programmatically what index to go to like you?
And I can figure that out just by looking at the screen.
But if you were coding this up and you had access to just the data that I have here in these comments, how would you know?
I'm going to go to index three to add something to the stack. What's the key there?
Are you Don't to raise your hand. Go for it. Yeah. It's just the size.
Size always. So. So there are three elements, you know, that they're indices zero one and two.
So three is the next open thing. So when I push, I'll go to index size, and when I pop, I'll go to index size minus one.
And also, if I try to push the right now, if I pushed and then I to do this, would go here, would go here.
I would say now have five elements in there. And if I tried to push again, I would check and I would say, Oh, the size is equal to the capacity.
This thing is now filled up. And so what I would do is I would create a new longer array.
Maybe I would do something like this behind the scenes. I would create a new longer array that is, Oh, maybe I should do it like this.
It can hold maybe one, two, three, four, five, six, seven, eight, nine, ten elements in it.
So I'll create that new longer array and then I'll copy the array contents from my old array down into this store.
Copy the ten, the the the and the and then I'll delete this array.
Poof. And then I'll make sure that the stack now internally points to this array over here.
The other key piece of information we need in order to start cutting this up is I don't know if you remember this from from Friday,
but when I create an array, if I do something like this, if I do like int array ten like that, what is array?
What is the nature of a naked array variable name?
Does anyone remember what? Yeah. Yeah. Go for it. Yeah.
Very, very good. It's a pointer. It's the memory address of the very beginning of this array.
And so you could also you could do something like this.
You could do in star P equals array, because this is just the base address of the array and then P become synonymous with array.
If you do array, sub five, four equals ten.
That's the same as doing piece up four equals ten, because this is just saying, Hey, go to the address to my left and skip forward ten or four places.
And same here. It's saying go to the address to my left, support for places.
You can store the base address of an array in a pointer and basically use that pointer as if it were an array.
And that's how I'm going to implement this dynamic behavior, because when I call new, we're going to use new to create a new array.
It's going to give me a pointer, the base address of my array. So let me start putting these pieces all together.
That's kind of like a high level, very fast overview of what the heck is going on in this code.
Let me start actually getting it together.
Let me do over here a new class. And I'm not going to call this stack because I don't want this program to get confused
with like the built in stack in the standard C++ libraries or in the C++ libraries,
the default ones. So let me just call this our array based stack.
I'm going to create an array based stack like this and split view.
Let's do the H file over here. And this is the thing over here.
So I want a constructor, a destructor, and then I want to be able to push pop peek, get the size and check if this thing is empty and to push.
Well, it's just an action to pop. I'll pop an integer out of this to peek.
That'll give me an integer. The size is an integer, isn't it?
And then a boolean is empty.
So those are the this is kind of the menu of functions that I want to write, and then I'll keep track of the size and capacity.
So remember, the size is how many elements I've taken up in the array.
The capacity is how many cells there are. And then this is the tricky part, the elements.
I'll actually just make this a pointer to the array that I'm going to dynamically allocate to hold those elements.
This pointer is going to hold the base address of the array that can expand luxuriously to take up more space.
Who which of these should be public and which of these should be private.
I should maybe just let me the simpler question or a more straightforward way to ask
the question is of these things that have created these functions and these variables,
does anyone want to sit here and tell us which ones should be private?
Which ones are you like, Ooh, I don't want someone manually touching those things because they might accidentally ruin the internal state of my stack.
I mean, certainly they should be able to call push, right? Like if you can't push it in your stack then it's useless.
So which of these should be made private? Yeah, go for the size.
The size should be private. I don't want someone to be able to just come in and be like size equals lol.
And then like there's one element there and we just try to print elements and we go out of bounds and we
crash in our array so that one should be private and the others that should be private besides the size.
Yeah, go for it. The capacity should also be private.
Yeah, because if I create an array of like five and I'm like, yeah,
the capacity of this ray is five and someone comes in and they're like, Low capacity now equals 
They think they're being funny. Then what'll happen is that array like will try to loop past the end of the array.
We'll go into memory where we shouldn't be. That's a bad idea.
Any other things here that you think should be private that people shouldn't be just touching directly?
Yeah. Yeah. Go for it. Yeah. Elements itself should also be private.
What if I. If this is a stack, then what I don't want is someone is like I have access to the elements.
Let me just, like, jump way over here and put an element and then let me just.
There are five elements in there. Let me change one of them to three randomly.
Like no, they shouldn't be allowed to manually edit those elements.
They should have to use the push and the pop functions to interface with these elements on the stack,
because otherwise they could destroy it and make it non stack.
We want it to continue to be a stack. Okay, so those are the things over there. So let me do private.
Oh, um. Oh, by the way, a fun factoid for you.
If you have a function that is just supposed to observe your class,
observe information about the data structure like is empty, is just supposed to observe whether the stack is empty or not.
It's not supposed to like add elements, remove elements, change the capacity, change the size.
If you want a function that's not allowed to change anything, it's only allowed to report back to you about the state of your class.
You can put the word contact after it. That means keep all the stuff inside This constant don't change anything.
So picking, checking the size, checking if something's empty, that shouldn't change the stack.
It should just observe and report back to us. But push and pop those change the stack.
Okay, let's start implementing those functions.
Oh, the other thing that I want to do really quickly is let's create just an initial stack capacity and I'll use that with using LB define.
So do init stack capacity r three.
This syntax just creates a constant called a NIT stack capacity.
We typically capitalize all the letters in our constants.
In C++, you could also do a static const, which you might which you might have seen appearing in some of your programing assignments.
I'm just going to use this one for now anyway. That'll be the new default capacity for my stack and it making it really small
because what I want to do is show I'm going to print every time this expands.
I want to print out that it's expanding. So I want to create a small stack so that when I add up to it, it will actually expand.
And the expansion formula I'm going to use, by the way, I'm not just going to double the size.
I'm not just going to say, Oh, my stack was three, let me make it length six.
Now I'm always going to double the size and add one. So from three I'll double that to six and add one.
So from three I'll go to seven and from seven. If I double that and add one, I'll get an array of like 
And then if I double down, add one to get an array of like And that's really common in the field.
And the reason people often do that instead of just like doubling the capacity,
like you're adding stuff in is just like bloop and you expand that thing.
And so just doubling it, some people will do double plus one because if your stack size,
if someone coded this up in a bad way where initially your stack,
your array length was zero, if you just double zero, you're still stuck at zero no matter how much you double it.
But if you double zero and add one, then you've got one and then you double that and out another one,
well, that gives you three and then double that, not one, you get seven and so on.
So every time I expand the stack, I'll double it and then add one. So let me just throw this down.
So to create the stack, I'll do this. I'll say elements equals new.
Oh, and here's how you create an array dynamically.
You say new data type, and then you give the number over here. So this will be my init stack capacity like this.
And then what's the size when I first create this of the data structure? Everyone.
How many elements are there? Zero. And then what's the capacity equal to?
Yeah, someone up here said it and it come out the capacity over here like that.
And then I'll just do see out created stack with capacity and then I'll do capacity like that and I'll just like that.
Um, and then if I want to, oh I want to be able to see out.
So let me include io stream like this and then if I want to using namespace standard also namespace, stuff like that.
Also if I want to let me actually make that go away over there so you can have a little bit more code like this.
Okay, so that's that thing there. Let me just write all these functions then.
Oh, one of the annoying things then is so this is array based stack I need to go through and you always this is a little bit obnoxious actually,
this comes before the function name, but after the data type.
So you have to like squeeze it in the middle here, the name of the class that we're dealing with.
So this is peak, this is size, this is, is empty like this.
And then here, let me make these functions like that, function function.
Function. Function. Okay.
All of those are functions you do check out. The stack is empty. I'll just return.
We're going to say something. Oh, yeah. The constant that comes after the function will.
We'll give it a go and see if it compiles and if it's happy. Okay, so here, I'm just going to do it.
Return size is equal to zero. If this is true, then I'm returning true that this is empty.
Otherwise, you know, return. Oh, and by the way, if I tried, let me show you.
Like, if I tried to set size equal to five in a constant function like this, it should yell at me and not allow that.
Let me just return zero here and return zero here as a temporary placeholder and return zero here and then with any of these others.
And when I try to give it a compile and run. It actually says down here, it says this is a read only object.
It prevented me from compiling with this line. So Constant is doing its thing there.
It's actually it's happy return size from the size function.
Super easy to return peak. I'll just return the elements.
What indexed it. We say the last element is going to be if we're implementing a stack using an array.
Everyone. Yeah. Size minus one.
Very good. I'll just return size minus one. Now, this could actually break if the stack is empty, so I could check this.
I could say if the stack is empty. Let me just error out.
Error cannot peak on empty stack like this and let me include error.
H So it will actually do that. And then I'll do a similar thing up here for all this other stuff.
So to pop, well, you cannot pop an empty stack. Let me do this.
So if is empty, we cannot pop on an empty stack.
In other words, I don't just want to return that.
I actually want to say like int equals elements at that position and then I need to decrement the size.
There's actually one less thing in that stack if I pop something out of that.
So get that last element, but then decrement the size to keep track of how many elements are in there.
And then similarly for push, so say here, push if the stack actually if the size is equal to the capacity we need to expand,
let me do see out expanded cap two and I'll do the new capacity like this, capacity like that and all.
Otherwise what I want to do ultimately is this I want to say elements at position, size.
Remember, size told us what to go to is equal to the value that I didn't pass into this, but now I'm passing it in interval like that.
And let me go over here. This is push a value like that and then I don't need to return anything there and then I increment the size.
Now the big problem here is the capacity.
So if I need to expand the capacity, let me create a new like I had a capacity of of three and I've got three elements.
I want to blow this thing up, so let me do it. Star New array equals new int of length capacity times two plus one and then I'll say capacity equals.
Capacity. Capacity times two plus one.
I'll copy everything over. So four entire equals zero is less than you'd better actually do this before.
Or maybe I didn't need to do that less than a size I plus plus. Let's copy everything into the new array.
So new array sub I equals the element sub.
I like this and then I'll just so I'm copying all the elements over, then I'll say elements equals the new array.
This is the new pointer that I just got with that new. But before I do that, this would create a memory leak.
I would lose the pointer that was in the elements. And so what I need to do is delete the elements.
And when you want to delete an array, you have to put brackets there like that.
And then by the way, when it gets deconstructed, I should delete whatever elements were left over like that.
I don't know. Let's take a look.
Let's go to mean I'm going to include the array based stack and then just do this and just be like array based stack s at start push ten, 
And then do stop pop, and I'll do sea out and oh, oh, I want to make it actually, like, expand.
So let me put a fourth thing in there. Hopefully this will expand to a new Oh my gosh, amazing.
And expanded to capacity seven. And then we got all those elements and they popped out of there.
I know. It's so exciting. I'll see you on Wednesday.
We'll talk about the topic of your next assignment and then all [INAUDIBLE] breaks loose on your exam.
See you soon, everyone. Oh, yeah, yeah, yeah, yeah.
Cause. Yes.
Well, that time I just kind of.
Yeah. Right.
Right. Yeah. And the answer is, you know, and here's the the more you use and the more pushing back.
So if you want to do something, we can sit around for something to work on that.
But we can see what they're going to do, what happens.
I mean, even if you gave it to me and I'm missing something.
Okay. So I think I'm going to be to give you more of an indication of that of.
But those are. They ask.
And we are doing it because we want people to think. Put him out as quickly as possible, but also write more of the day.
So this is the structure of this. Yeah, but this is the structure of what's going on here.
If I'm going. Mark Colvin, I.
Yeah. Oh.
Oh, yeah. Yeah, that's true. Exams tomorrow? Yeah.
I haven't finished writing yet for Thursday, so that's all.
Yeah. I'm guessing music has not either, because I have not seen that.
Interesting. Okay, so I'm not even going to be like I started working on a problem.
And the problem is like it's a two page write up to the podium, and I just don't know if they can have.
Yeah, Yeah. So I don't know.
Yeah. And it takes so long to explain. Yeah.
All right. Hello, everyone. Happy whatever day it is. Wednesday, I suppose.
I want to talk a little bit about the exam and then dive into a new topic for today and actually have a little bit to say about backtracking.
The main thing that I want to say about the exam right now, I guess I have a few things to say.
One is when you get into the exam tomorrow, remember, to some degree time is of the essence.
So what you don't want to do is you look at a problem that's kind of hard and you're like, Let me just work on this until I complete it.
And then you look up because time flies when you're having fun.
So you look up and you're like, Oh, an hour and a half has passed and I've got no points so far.
So not all points on the exam are created equal.
One of the things that you'll see is there actually is like one question that I think objectively you would say is like easier than another question,
and they're both worth the same number of points. So the idea there is I want to show something that's like really maybe going
to take a lot of time and is maybe the most challenging question on the exam.
I don't want that to be with the most points on the exam because then if you really have trouble with that,
that actually hurts your score quite a lot. So we're looking, you know, strategize, look through the exam.
If you see something that's a little bit overwhelming, maybe just glance through it really quickly and then move on to the next question
and let your mind maybe work on solving that problem as a background process.
Just kind of ignore it.
Like if you ever had that happen where you're struggling with a problem and then you just like take a nap and when you come back to it,
you're like, Oh, the answer so obvious now? Or you're just like, you go for a walk or something and then the solution comes to you.
Well, maybe instead of a walk or taking a nap, you could just move on to problem number two,
and that'll be like a nice little refreshing walk or whatever the case may be.
So. So there's not there. The other thing is when you get into the exam tomorrow,
you're going to find that you need to carefully read a few of those problems because it's just like you need to see what the problem is asking.
And part of the problem is just reading and seeing what it's asking.
So if at first you look at something, you're like, Oh, this is kind of complex, dig into it and embrace it.
You can do it. You can figure out what the question is asking, but there might be something where it's not just like immediately,
straightforwardly create a function and then it's just kind of like based on rote memorization of something.
There might be some problems We have to like read and kind of think about what is this asking, Play with the problem a little bit.
There are only going to be four questions, and one of them, I think will go pretty quickly.
And so even in the worst case, you could budget minutes for each question.
But I think one of them will go pretty quickly for you. And then you have all this other time to work on the other ones.
So so budget that carefully.
The other thing that I want you to to do as you're going into an exam is to think of it as I actually want to rebrand that,
rebrand them at some point and stop calling them exams and start calling them celebrations of knowledge.
So tomorrow at p.m., we're having a class wide celebration of knowledge.
You just get to come in and show what you know.
And in terms of the points that you were in on the exam, I'd also like you to think of each point that you earn as an award.
So even if you get like a on the exam, a %, that's awards.
And how many other people do you know who've won awards in a single day?
So we want to we want to give you credit. We want to celebrate your achievement.
And, you know, even if you only get awards that day, you can get even more when you retake the course next quarter.
Just just kidding. But but we are we're looking to celebrate you and your success and the things that you're that you're able to achieve on that exam.
So I encourage you to go with that mindset. Don't forget to look at the course website that says based on your last name,
where you should be, what room you should be in if you have accommodations.
Clinton should have sent you an email already telling you what room you should be in for that exam.
And you know, you can bring a one page sheet of notes front and back.
And we will also provide to you that reference sheet that's linked on the exam page that has the runtimes and
operations for a lot of the eighties and the Stanford built in the Stanford C++ Goodies or Stanford C++ libraries.
So that's what's going on there. So the exam is tomorrow.
Don't forget about it. Don't miss it.
Before we get into today's new topic, there's something I've been wanting to show you for quite a while and I just haven't gotten around to it.
It hasn't. I just haven't been able to squeeze it into a lecture.
There's this problem called the Queens problem, which is given a chessboard of length and width.
And so in this case and is for I have a xchessboard, can we place four Queen's on that chessboard such that none of them can attack one another?
Now, if you're not familiar with how Queen's move in chess, they can move any number of spaces horizontally.
Vertically, diagonally, like this way and diagonally this way.
And if you look at those moves for all of these queens, you see that I've placed four queens on this board such that none of them,
with all the movement that they can make, none of them are kind of they don't have like line of sight on any other queens here.
Like this can move up and down and wouldn't hit. A queen left and right wouldn't hit a queen diagonally here and a diagonal here wouldn't hit queen.
So the queen's problem says, given an end by end chessboard, can you place and queens on it?
Even an eight by eight chessboard? Could you place eight queens on it?
And you can actually solve this problem using backtracking? I'm not going to go through the solution with you.
It's a it's a pretty famous backtracking problem. You could look it up if you're interested.
But the idea is you want you need to place one queen per column, because if you have multiple queens per column, they can attack one.
Or if I have an empty column, than you necessarily don't have enough queens if you're only doing one queen per column,
but then you also have an empty one.
So you can just try in this first column, try to put a queen in the top position, then move on to the next column and try to put a queen there.
And oh, these going to talk one another. So undo that. Come back here and try to put this queen lower and then move on to the next
column and try to put a queen here and they can attack one another diagonally. So backtrack, try it over again.
And so what I've written here is I have a little program that I put together where
I feed a number the size of a chessboard and it prints out to me the result.
So on a xboard. These are actually the two configurations.
There are only two solutions to the four Queens problem. This is how you could place four Queens on a board such that none can attack one another.
Or if you do ten by ten boards, this prints out all of the ten by ten boards that are ways to place ten
queens on a ten by ten board such that none of them can attack one another.
If you get to a larger board, something interesting happens. As it's printing out all of these results.
It almost looks like the queens are moving a little bit.
Here is it's printing out all of these results. And one of the things that I want to show you, like let me rerun this again.
One of the things I want to show you is kind of focus on where my mouse cursor is right here.
When I start running the program. There is a queen there, right there, and then boom, it jumped all the way down here.
And what's happening there is we're seeing the power of backtracking in action.
Let me show that again. So there's this queen up here and then, boom, it jumps all the way down there.
My code is actually trying to take that queen and place it there and then place it one cell below, one cell below one.
So it looks like it's jumping really quickly because what's happening here with backtracking is when we place the queen in that position,
we quickly find that it's going to lead to Queens being able to attack one another.
As we try to fill in all of these other columns over here. So backtracking says abandon hope.
This is not going to lead to a solution if two queens can attack each other here in the first couple of columns,
it's a fool's errand to try to move on to the other columns and try to start placing queen queens there.
And so the power of backtracking is that as soon as we enter a failed state,
as soon as we get some sort of inclination that going down this path is going to lead to failure, like you're counting up votes, Right.
Who has more votes so far, A or B?
Well, as soon as you see that B is is in the lead or tied with a if you're trying, count up how many times or how many ways you can be in the lead.
You just stopped going down that recursive path, really, because this is over. Game over.
Let's go try a different path. And that's exactly what's happening here.
Is this this queen actually as you try to place it in the next so the next cell, the next cell, it very quickly collides with all the queens.
And so it looks like the program just kind of goes through that really quickly and moves on and finds a position
where the queen isn't in conflict with other Queens immediately and starts to do more backtracking there.
So we have this kind of pruning aspect where we see that the move is infeasible and then like these moves here were also very quickly infeasible.
And then you see it moving and you can actually see this queen here marching on down as it does its thing.
But every now and then these queens will take a big jump.
And that's because we went into a part of the recursive tree diagram where queens were conflicting with one other.
And instead of generating all of those states over there, the program is like, now backtrack.
That's not working return. So that's the key power of backtracking.
And I haven't really kind of shown that to you visually before. I think it's this idea of just cutting off a branch.
We call it pruning, which you saw in your assignment for right up. So there's some pruning that's going on.
There is kind of a thing that I wanted to show you.
Let's move on to the next topic then for today.
This next topic, actually, it's it's really this is where we start to get into just like classical to bee material.
This next topic is just us exploring a data structure.
I'm nervous about whether this is why is it not showing up? Okay, hurray.
We're going to just explore a data structure today,
talk about the different operations we can perform on this data structure and explore the runtimes associate.
I can't get back to my laptop over here now,
explore all the runtimes associated with the operations that we perform on this data structure and and take a look at this thing here.
So today's topic is heaps. Heaps.
We will we'll talk specifically about mini heaps and there's this analogous thing called a max heap.
But once you know what a mini heap is, the max heap is just really similar and it's very easy to do it.
Once you've locked down your understanding of mini heaps, the max heap is just that becomes actually trivial to understand what's going on with that.
We sometimes call these by the way, you'll hear them refer to it's priority QS priority query,
and this is actually going to form the basis for your next assignment is implementing these.
But of course, you know, remember you have this, this break on Friday.
The mental health data kind of recuperate after the exam. Monday is a holiday.
Things are kind of kind of lining up nicely there. We don't have the fall break this quarter.
There's really just like no break to kind of give you a breather. And I think that's just really essential as we get to exam time in this class.
So use that time for whatever you need, whether it's just disconnecting, taking a break from the material or if you've fallen behind,
use it to catch up, watch the lectures, do all the quizzes you do have a quiz do before we meet again.
So that. Is is going to be due next Wednesday. Coming into class.
Do you have a quiz? Do so. I won't see you Friday. Won't see you Monday. So remember that you have those four quizzes do actually next Wednesday.
Okay, so let's dive into heaps.
So it's a data structure where we're going to organize data in a particular way, be able to perform particular operations.
I'll tell you how this data structure works and then I'll show you some applications for this data structure.
We'll talk about what it can be used for. So as I mentioned, we'll focus on mini heaps here.
So preliminarily, one of the definitions that I need to give you as we dive into this is this is a tree,
and I've used that term already this quarter when I've talked about recursive tree diagrams,
I've drawn those dots with those little lines coming out of them to represent calls to a function
and then the calls that it makes that kind of branch off from there and so on and so forth.
So this is a tree, and I want to give you some nomenclature related to trees here, and we will see other types of trees this quarter.
This will come up again, this little circle here with a value in it.
We call these the nodes. These are the things that contain data in this data structure.
So just like in arrays, you have cells. Those are the entities that hold our values.
In trees, you have nodes, those are the entities that hold our values inside of those nodes.
That's where we have our actual values. So we have a value ten we have values nine, three, four and That's what's going on there.
And then these lines here, these are what we refer to as the edges.
Those lines that connect nodes are the edges and the lines.
And the spatial orientation of the nodes is conveying a hierarchical relationship, a parent child relationship.
So we say ten being above and having nine and three spawned from it.
Ten is the parent of nine and three. Nine is the parent of three is the parent of four and 
We could say that ten is the grandparent of and 
So we have parent child relationships that are articulated by the spatial orientation of these things.
The fact that one thing is above the others, the in a tree, there is always a single node at the very top from which everything flows.
This tree is referred to as the root node of the tree.
The very like if I turn this upside down, that's where it kind of starts.
And I did this with the present it kind of starts it doesn't look like a tree,
it's maybe more like a little bush, but a bush is just like a tree that tried.
And it's just really you know, it's still a little bit of like a photo tree here.
But this is the idea at the very base of this tree, right?
Like in a tree in the real world, if you go down to the very bottom of it, underneath the trunk, you have the roots.
And so this is the root of the tree. We refer to it as their this in particular, there's this is a special flavor of tree.
This is what we call a binary tree.
So binary, you know, by means two or both the were the the prefix by their so binary implies that every well not even implies a binary tree.
The binary means that the tree each node in the tree has at most two children.
So by meaning both are by meaning two. So we have at most two children.
Here we refer to those children as the left and right children.
So four is the left child of three and is the right child of three.
So those are the children. And in a binary tree you don't have like a third child.
There's no awkward middle child allowed. So if you're a middle child, you're probably not.
Well, I don't know if you're accurate or not. It doesn't matter, though. I embrace that and honor and respect you and your journey through life.
But in binary trees, there's no awkward middle child. There's just the left and the right child.
And if you look at this diagram, you might say, well, what is the right child over here?
Well, the right child, if we were coding this up with pointers, we would maybe just set that to two.
And I mentioned this in the notes, there's this thing called null pointer that you can set something to to say that there's nothing there.
But if we were coding this up using some sort of note struck, there would be two pointers inside that note struct.
There'd be a pointer that could get you to the left child and a pointer that could get you to the right child.
There I actually see a different representation, a different way to code these up as we move forward.
Is everything okay with this terminology then? It's a tree. We have these branches, we have these children in the edges.
Any questions about that terminology before I move forward?
But this tree data structure then forms the foundation for the data structure that I want to talk about today, which is the min heap.
So a min he is but a binary tree with the following structural and ordering properties.
And this actually happens with a lot of data structures. I don't think we've seen a data structure so far this quarter where this has happened.
This might be the first one. But we you know, we define properties of data structures, like when we talk about a stack,
there's this idea of the top of the stack, the bottom of the stack. Those are structural things.
The idea that when we push into a stack, the new element goes on the top.
When we remove, things, come off of the top. Those are all structural things there.
There's with a lot of data structures we counter maybe what I would call two different flavors of properties.
We have structural properties, things like what does this look like?
How or this was this made of? How are the elements arranged? And so there's the things like we just talked about what a tree is, right?
That's a very structural thing.
And then we have ordering properties to things like if you have a sorted vector, then there would be an ordering property to that.
Smaller things come before larger things in the vector.
So ordering property and the mini heap has both of these properties.
I want to focus first on what the structural properties are and then I'll move on to the ordering properties for what THEM inhibitors.
And again, we will then see some applications for like White Hacker. We've been talking about this.
So the structural property for this thing, this is actually like when you see what this is,
it's a very straightforward concept, but it's kind of hard to articulate succinctly.
The idea behind the structural property for a mini heap is, first of all, this thing is a binary tree.
So we've already talked about what is a tree or specifically what is a binary tree, A tree where there are at most two children per node.
There are trees in the world, by the way, trees in computer science where you have more trees or more children per node.
And that's actually allowed. But with a binary tree of at most two children.
But the structural property for them in heap is not only is it a binary tree, but it's a complete binary tree.
So a complete binary tree is one that fills up from left to right with no gaps before we move on to the next level.
So if you want your tree to be complete, you have to fill up the first level.
Then you move on to the next level and you need to fill that level up completely before you're allowed to move on to the third level.
And that one needs to fill up completely and it needs to happen from left to right before you move on to the next level.
And when you get to that next level, it's either completely filled up or if not all the nodes are flushed to the left.
There can't be any gaps. It needs to be filling up from left to right. So I'd like to take a pop quiz on this definition.
If you could take out a piece of paper. This is that pop quiz in the syllabus where I said, like at some point in the quarter,
there will be a pop quiz worth about % of your grade and lecture ten.
And I'm just kidding. That's not actually I thing I don't know if you were a few people really worried there.
I don't remember that. Okay. So, no, that's not really a thing.
But let's take a pop quiz and kind of see what you think.
And if you can process this definition in real time here, I want to know if something is a complete binary tree.
First of all, forget the complete part for a second. Is this a binary tree?
You can just started out. It's not binary tree. Yeah, it's a binary tree.
What are your thoughts on the completeness? Take a second to think about that definition and take a second to look at this this
tree and kind of reflect on that as is whether this is a complete binary tree.
Everything's filling up from left, right. Before we move on to the next level, what are your thoughts?
Yes or no? Is it looking complete or no? Yes. Yes. In fact, this is a complete binary tree.
Every level has filled up except for the last level, but also nodes on the last level.
They seem to be filling up from left to right. I don't have any gaps as I move forward.
So this one is complete and I'll give it a little bit of a happy face there before we move on.
All right. What about this next one over here? This tree over here?
Is this one a complete binary tree? You can just shout it out if you have thoughts on that.
Is a complete binary tree. No, no. Okay. So who can raise their hand and tell us why it's not a complete binary tree?
Like demystify that for someone who's maybe Michelle. There's someone right behind you.
And. And what's your name? So say it again. Louder. Zoe.
Okay, so what's it? Yeah. It's not filling up from left to right.
So down here, instead of filling up from left to right. I did fill up the first level before moving on to the next one.
But I've got this gap over here. You're not allowed to have gaps. This is not a complete binary tree.
You can't have gaps here. You'd have to have this node flushed to the left so it's not complete.
It didn't go from left to right. What about this next one over here?
So take a second to think about that one. I'm going to, of course, ask you if that's complete or not.
Is it filling up from left to right? What are your thoughts?
Complete or not complete? You can just shout it out. No, it's not.
So this one usually gets a lot of people because they look at the last level noise.
Yeah, that's filling up from left to right. But what's missing here is that it doesn't have a right child here.
We didn't completely fill up this level before we moved on to the next one.
So that is not a complete binary tree. This we need to fill up every level from left to right before we're allowed to move on to the next level.
And so we would have had to have put a node right here, But I'll give it a happy face, even though it's not complete,
because maybe it doesn't subscribe to society's notions of what it means to lead a complete life.
Maybe it's okay with the fact that it's over and it's Valentine's Day and it's still single and is probably going to die alone.
You know, like we don't need to judge its life choices there. Okay. Oh, interesting.
Okay. Okay. Anyway, what about this one here with Happy Valentine's Day?
What about this one here with just a single node? Is that a complete binary tree?
Yeah, this one is complete. It filled up from every level. Everything is flushed from left to right before it moved on to the next levels.
And what about this last one here? Complete or not complete? No, it's not.
Because this last level I filled up every level before I got to the bottom here.
But then this one is not filling up from left to right. That one's not complete over there.
Any questions about the definition of complete?
I mean, it's on I mean, it's related to mean heaps, but we haven't yet really talked about what I mean.
He basically had to go to the ordering property. But is this part of the definition okay, Are there any questions for clarification about this?
Are you feeling okay with it? Can I get a little bit of a nod if you're following? And this is making sense.
Okay, great. Okay, so then that's the structural property. Let's take a look next then at the ordering property.
So the ordering property is in a min heap every node's priority.
And by the way, there's those numbers inside the nodes. We sometimes call them values.
We sometimes call them priorities. People just have different language for this data structure.
Some people call it a mean heap, some call it a priority queue.
And so whether we call it a priority or value, the idea is that those numbers inside those nodes at every node,
the number that you have there has to be less than or equal to the values in its child nodes.
So it has to be less than or equal to. So the key phrase there in min heap the min part of it, right?
Minimum smaller. So smaller things are higher than larger things.
Minimum things are higher. They have we sometimes call that.
So the priority here, well, we'll see the priority in a second.
What I mean by this, when you have a really low priority, that's a smaller number that actually goes to the top of the tree.
And maybe we usually think I think usually what we consider like a high priority is something that should be maybe taken care of first.
But we'll see. There's an inverted notion of of priorities when we talk about these benefits.
So let's take a look at whether these are valid min hits or not. So we have the structural.
One of the things you have to do when you look at a data structure like this and you won't know if it's a heap,
you have to first ask yourself, does it satisfy the structural property and then does it satisfy?
Well, I guess you can do it in any order, but it needs to be satisfying both the structural property and the ordering property.
So here, structurally, is this a complete binary tree, everyone?
Yeah, it's a complete binary tree. Is this a does it satisfy my ordering property?
As you look at every node, is every node, does it have a value less than or equal to the nodes in its children?
Yeah.
So five is less than or equal to and is less than or equal to nine is less than or equal to all of the values in its subtree is as well.
There are just no values there. So this one is indeed a nice, happy, valid min heap.
What about this one over here? Is this structurally complete? Yes.
Does it satisfy my ordering property? No. Oh no.
So who can raise their hand to tell us? Where is the ordering property being violated here?
Yeah. Yeah, go for it. But first I just thought about was.
Well, for which values specifically? Yeah.
So if we look at that value should be less than or equal to all the values in the children nodes.
If this were a valid mean heap, and that's not the case. So this is actually not development heap.
I violated my ordering property. This is not smaller than or equal to everything that comes in.
It's a subtree so that's not a valid min here. Let's take a look at another one over here.
So is this one a valid min heap? No, but the ordering like eight is less than or equal to the and 
is less than or equal to What are your thoughts on why it's not a valid min here?
Yeah, go for it. You've got to you.
Yeah, the structural property is violated here. It's not complete because I have a gap here.
I'm not filling this level up from left to right. So this one is not a mine here.
What about this one over here? The root is one. The right child is billion.
What's the log base? Two of billion, by the way, Every 
And so remember, we love to see a logarithmic runtime, because if a logarithmic operation encounters,
say, a data structure with a billion elements in it, we can get through that in about steps of work.
Amazing. And then the lovechild is two, and then the left side over here is three.
What are your thoughts about this one? Is this one a minute? You're going to shout out your thoughts on this.
Yeah. Yes. Okay. Often if sometimes people will say no, often,
sometimes I often have people say no as as we showed up that answer because I look at this and say, Well, wait a second, I have a billion.
And that's higher than the three. I thought that things had just got bigger as we went down through the tree.
But the kind of culture there is three is not in billion sub trees.
It's not one of its children.
So this is actually totally fine that we have a smaller value, lower than a higher value because there was no edge connecting those.
So that's just this is still a valid mean heap at this point.
By the way, I mentioned over here, well,
for this I mentioned over here with nine it it smaller than or equal to all of its children values and the same is true over here you could say
like one is less than or equal to two and is less than or equal to three and billion is less than or equal to all of its children.
When you make a statement about the empty set, which is what I'm doing there,
when I say a billion is less than or equal to the values in all of its child nodes, there are no child's nodes.
The set of entities I'm talking about, they're the child nodes of a billion is empty.
When you make a statement about the empty set. I don't know if you've heard this term before.
There's a term that where it's like a bit of a bit really true.
A statement about the empty set is always going to be true.
Does anyone know what that word is that begins with V? Yeah.
Amazing. Vacuous. Leigh True. So when you make a statement about the empty set, it's vacuous.
Leigh True. You can say anything you want about that and it's true. So you could say like a billion.
The a billion is less than or equal to all of the child nodes here.
Or you could say all of the children of a billion are greater than a billion and had breakfast in bed with your mom this morning.
Like that's a true statement actually, because that's an empty set there.
That statement is vacuous. LEIGH True. Amazing. So let's take a look then at some operations that we can perform with on these men.
Heaps then mean the operations that I want to talk about.
The operations that will perform here are insertion.
Sometimes we call it NQ if we're referring to this as a priority.
Q The delete min, which we sometimes refer to as de Cuba, referring to this as a priority.
Q And then find men or get men or sometimes called peak those operations there.
These are the primary operations that we perform on a min heap data structure.
You can also check if it's empty, you can check its size, get kind of like logistical information about that thing.
But these are the operations that kind of play with the data that's going on there.
I want to talk about the best case and worst case runtimes for each of these operations and how these operations work.
I find men, by the way, in a mean heap. Does anyone see how we would how we would do that?
Like, how do you find someone want to raise their hand? How would you find the smallest element in a minute?
Yeah, I go for it. Michelle.
Yeah, it's always the root node because the root is less than or equal to its children, and its children are less than or equal to their children.
And so that property kind of flows recursively through the tree that this is less than these.
These are less than those. And if this is less than these and these are less than those, then this is also less than those.
So the smallest thing is always going to be at the top by that kind of chain of implications there.
We call that syllogism. That kind of chain of implications. Okay, great.
So actually, these are just going to end up being order of one operation.
Oh, actually, no. Yeah. Just to like to find the smallest thing.
You just look at the root of your tree. There it is. That's ordered one time.
If we want to remove that thing or insert, that's going to become a different story.
One of the interesting things then I want you to know about Mean Heaps is they only
support the deletion of the minimum value in the heap you like in the min heap.
There's no operation called like rummage, just rummage around and find if there's a in the min heap.
All you can do is insert stuff into them in heap and remove the smallest thing from them in heap.
So if you find yourself trying to write a program where you're like, Oh,
I really just need to be able to like loop through this and check if this is sorted or I need to loop through
this and find if the value is in there or it needs to be able to just like I have this data structure,
need to be able go find and pull that out of the data structure then you don't want to
keep the min heap is really good for applications where you're like every step of the way.
I need to know what is the smallest remaining element and pull that out of this data structure.
It just surfaces up to you the smallest remaining element, not arbitrary elements.
And we've seen that kind of restrictive behavior before, right? Like we talked about with stacks.
With stacks, you can push and pop. You can't just go like searching down into the middle of the stack to find a particular element.
And same with Qs, you can and Q and Q.
You can't just go searching in the middle to find if there's something in there. Let's talk about how this insertion operation works.
I would talk about insertion, deletion, how these are coded up, and then we'll finally get to some applications.
So if you want to, in certain elements into a mean heap,
the first thing that you do is you find the next open position and put it there and you use that to preserve the structural property of the heap.
And then from there we kind of re state the ordering property.
So let's take a look at an example here.
I've already got an eight over there. We'll talk about that in a second.
I want to insert into this this data structure over here, first of all, is isn't a valid heap.
What are your thoughts as as valid looking again? No, it's not.
Why is it not? Yeah, the is bigger than the eight.
We can't do that. This needs to be less than or equal to all the stuff in it.
Sub trees. But I can kind of reinstate the I can make this a mean heap by just doing the old report card trick where you're like,
Oh, I didn't get an eight on that exam. I got points on that exam.
So that's what's going on there. Now, this is a valid heap. Let me in queue.
Let me add it to this mini heap. The first thing that I want to do, as I mentioned, is put it in the next open position.
Can someone raise their hand and tell me then? Like, where should that go if I want this to be a complete binary tree?
I need to start by putting it. Yeah, go for it. Right. Yeah.
So it'll be and the way that I say that is, it's the right child of 
That's the next open position. So it's the, it becomes the right child of 
That's where I inserted at first because that's just the next if I'm filling this up from left to right,
keeping it complete, that's the next open position that I can put something into. Now, I violated the ordering property here,
but sometimes that happens when we're operating on a data structure while we're in the middle of performing an operation on it For a second there,
things kind of get turned on their head and we're violating a few properties, but we're going to fix them up.
So now I perform this operation.
Now that I place that in there, perform this operation called Percolate Up, or some people call it swift up or bubble up,
there are a lot of different terms for it in the literature, but I call it percolate up.
So to percolate up, what we do is we just look at where we put this and we ask,
Does this needs to swap up with its parent in order to kind of restore our ordering property.
You all tell me, should eight swap up with the ? Yeah, because it's too small to sit below the 
We want smaller things to move up and larger things to move down.
So just kind of swap these up over here. I'll swap the down to this position and then the eight moves up over here like this.
And you might think, Well, oh no, what if I move that thing up?
I just swapped those things. And what if it turns out that the eight is like, bigger than the thing to the left over there?
That Maybe I need to swap it down to the left. And that can never happen because check this out.
This number was bigger than this one.
But this number, just by virtue of being up here, we know that it was bigger than or equal to the thing to its left already.
Well, if this is bigger than that and that is bigger than this thing, then just by a chain of logic there, this must be bigger than that thing also.
So when I move it up, it certainly can stay there.
It's definitely going to be I think it said bigger than I meant to say smaller than it's going to be smaller than this thing over here.
Does it need to keep percolating up? Does the eight need to swap places with the five everyone?
No, because it's it's bigger than the five. The smaller thing is up top.
And so we're good to go. This is actually a nice happy minute. At this point.
The structural property is preserved and the ordering property is restored through that operation, that percolate up operation.
Oh, let's do another example of insertion then. Let's kind of test that test your your real term absorption of that process.
Is this a mean heap over here, everyone? Yes, this one is a min heap.
It's and The min heap properties are all there.
They're all in place. It's a it's a complete binary tree and I've got that ordering property so let's put a one there.
Where should I put the one. Tell me it should go to the left or right.
It should be left child. A right child just showed it like it's the left child of 
Like where should it go? Everyone Yeah.
Initially what I do is I preserve the structural completeness of the tree I open, I fill in that next open position right there.
So that's where it goes. That's where it goes to begin with as it went down there to the left.
And then where was the name of the operation that I needed to perform Next?
Everyone percolate up. Oh, no, that's okay.
That's Kelly. And Mary J. Blige has a song about that.
Let's get it percolating. Oh, you can't really see the the hip hop video happening behind the scenes over here.
Okay. So it's the percolate operation. It's the percolate operation.
She has the video about it. Mary J. Blige is a secret computer scientist.
So, yeah, the one does it need to swap up with the nine?
You all tell me, should I swap them, yes or no? Yes, because it's smaller than the nine, so I don't want the nine to stay above it.
I'll swap that there. And then what you do is you just keep going.
Oh no, you just keep on going until you reach a spot where no more percolation needs to happen.
So should the one swap up with the five everyone?
Yes, because it's smaller than five. So swap that one up there like that and then there's nowhere else for it to swap up.
And again, we don't need to swap to the left. It was less than five.
Five we knew was less than eight. It had to be less than or equal to its left childs just to be sitting where it was.
If one is less than five, five and five is less than eight, it necessarily follows from that.
That one is less than eight. And you could do that with with arbitrary variables, right?
You can say if X is less than Y and Y is less than Z than X necessarily was less than Z is going on there.
So this is a big heap here.
Well, I want to talk about what's the runtime for the insertion into a min heap and like, what's the best case and worst case scenario here?
And actually you tell me in terms of the best case scenario and worst case scenario for what I described, let me say this.
Actually, I have a trick that I'll show you in a minute where if I want to find the next open position,
I can get to that next open position in order one time.
I just have a trick to jump down there in order one time.
And so can someone raise their hand and tell us then what's the best case scenario when I try to insert into a mini heap,
like what's the best thing that could happen and or what's its runtime? Yeah, go for.
Say it again. Yeah. Order one. And why? What would lead to that?
Order one runtime. Yeah, but I just add it and when I go to percolate it, it doesn't need to move up.
So right now if I inserted a I would just put the over here in order one time and I was like oh doesn't need to percolate up.
It's already bigger than the thing above it.
So if you insert an element that doesn't have to percolate up at all, we get a runtime of order one for that insertion over there.
So that's actually we can insertion best case or one we just jump and put it there and it doesn't have to percolate up.
Um, what's the worst case thing that could happen in terms of trying to insert something into this mine here?
What's your. Don't need. Give me the runtime. But just like, what's the situation?
Yeah, Yeah. Go for it. Yeah.
If I insert something new, like right now, if I inserted negative three in this position here,
it would have to percolate all the way up to the root position, the entire height of the tree.
It would swap with the the eight and the one, and it would become the new root.
So if you insert a new smallest element or just an element, that's well, yeah,
I would have to be a small settlement in order to finally take the root position because that was the previous smallest element.
So if you insert a new, smallest element has to go all the way up to the height of the tree.
This would have to do one, two, three swaps over there.
So really the runtime for this operation in the worst case is dependent upon the height of the tree.
If the tree goes levels deep, the worst case scenario is you have to do swaps to get to the top.
If the tree goes five levels deep, the worst case is you have to do five swaps to get to the top.
So what I'd like to know is what is the height of this tree?
If you have an elements in your mean heap, how tall is it?
If I know how tall it is, I know how many swaps I would have to do in the worst case to reach all the way to the top of the tree.
So let me actually. Oh, no, I just lost the paper that I had the.
Oh, here it is Over here. Nobody panic. I found the paper.
So how tall is a min heap? What I want to do is look at the height of various trees.
And so let me just say, if you have a single element in your main heap, we formally define the height of that thing.
We define it as having a height of zero. And I think this feels counterintuitive when people first see it.
I think people look at that node and they're like, There's one note there. This should be a height of one, a height.
The height of a tree is actually formally defined as the number of edges that you can go in that tree.
And so right now, if you start at the root, you go zero steps and you've gone as deep as you can from that root.
There are zero steps that you can take to go any deeper. So the height is zero.
When I add a second note to my min heap, regardless of what the values are,
this is what the structure would look like if I had two elements in my heap.
I say here that the height is one. I can go from the root, I can go one level deep, the height is one.
And if I add a third node to keep my tree complete, it would have to go there.
That does not change the height of my tree. The height is still one. I can go one level deep to the left or I can go one level deep to the right.
The height is still one. But when add a fourth node to keep my tree structurally complete, it would have to go there.
And the fourth node caused my height to become to the the deepest that I can go from the root.
I can actually go one two levels deep. So we say that this is a that this has height too.
You can maybe think of that as a unit of measure, right? Like it's it's one unit of measure two units of measure tall.
Well, what's the next node that's actually going to cause this height to bump up?
Like if I add the fifth node, that of course would go here because I'm filling up from left to right.
Which node is going to cause this to bump up everyone? Yeah, like the sixth one would go here, the seventh one would go here.
The eighth one causes my height to bump up to three.
And what's the next one that would cause me to bump up? Yeah, I would go nine, ten, 
Aha. It's the th one that causes me to bump up.
Now I've got a height of one, two, three, four. I want to know what the height is equal to in terms of and I want a formula that
will tell me how many levels I might need to percolate up in the worst case.
Does anyone see? Does anyone want raise their hands? Do you see a relationship between these two columns?
Do you see a formula that gives us one of these? In terms of the other?
Yeah. Go for. Yeah.
Yeah, absolutely. I don't know. I'm always hesitant to start with the log version because I don't know if, like,
if everyone has an intuitive feel of what logs are, but the inverse of the log operation is the what is exponents?
Does anyone see the exponential relationship here? That one column is an exponent of the other, actually some sort of exponent?
Yeah. Michelle. Yeah, this is equal to two to the zeroth power.
This is equal to two to the first power. This is two to the second power.
Two to the third is two times. Two times two, which is two times was four.
Four times two is eight and two to the fourth power. Two to the two to the third power was eight.
Multiply that by two, you get The formula here is that n is equal to two to the H power, right?
Like two to this power gave me n
This power gave me n two, two, this power gave me and and so on and so forth.
Two, two. The height power gave me how many nodes there were and that if we want to solve for h that's what
I want to do because that tells me how many moves I might need to make when I proclaim being up.
And this is actually the original form that we got. But if you, if you do it this way, you're like, Oh, I see.
The relationship to the H is equal to N. Well, you know, you can take the log base, two of both sides.
The log base. Two of two to the H gives us log base two of N And what is the log base?
Two of two to the H everyone regular H, right. Log base blood of blood of the BR gives you just the br out of that thing.
So the height is log base two of n, which means that my percolate operation is big.
So how would we write log base to event in bigger notation which would push it right over here?
Yeah, log in. Remember we up the base like a D.J. We just leave the two behind.
It's on the dance floor.
So the runtime for this thing, in the worst case percolating up is logarithmic, because that's the height of the tree is logarithmic.
And so percolate up might take a really tiny new value, smallest value.
They're adding them in here and go all the way up the height of the tree, the logarithmic height of the tree.
Now this formula, by the way, isn't exactly precise because like if I have three elements,
you know that if N is equal to three, that implies that the height is equal to one.
And if you to log base two of three, what is the log base two of the tree everyone.
One point something. Very good. Okay, so it's one point something.
What? Mathematical. It's somewhere between the log of the always two of two in the log base to a four.
It's that one point something. What mathematical operation can I perform on this to get just the one because the height is indeed one.
The height is not one point something. What mathematical. Where are you trying to raise your hand or I don't know if you are.
You want to go here? Yeah, I can just truncate it.
And what mathematical operation do I have that performs truncation the floor.
Yeah. So I don't know if everyone has seen this before, but you, we take the floor so the height is equal to the log base.
Two of MN take the floor. These little symbols mean take the for the forties means integer truncation.
The floor of is just three integer truncation.
The floor of is just three.
The floor of is just three.
So we can take the floor of something. That means just give me the integer portion of it and that's what we get.
So if you if you have, say, nine nodes, well, the log base, two of nine is somewhere between three and four.
It's three point something, but the height indeed is three, one, two, three.
And so we would want to take the floor of the log base two of of nine, and that would give us the actual height, which is three.
Okay.
So the big take away from that is the runtime for this operation is logarithmic because percolation or because the height of the tree is logarithmic.
Let's talk then about how deletion works. Deletion works in a very similar way.
First of all, we preserve the structural property and secondly we restore the ordering property.
So let's take a look here at the process for this one over here.
Suppose I wanted to delete oh, by the way, I mentioned so the first thing I'm going to do is preserve the structural property.
So when I delete from this mean heap, regardless of what value gets deleted, you can actually predict structurally which node is going to be missing.
The value in that node might move to a different position and remain in the tree, but you can predict which node will be missing.
If I want to delete a node structurally when I'm finished, which of these will be gone?
Everyone. Yeah.
The one that has the nine in it. That one will disappear. I can't, like, remove this node.
If there is no root node, the tree just gets disconnected. I can't remove this node because then it would be incomplete.
I can't remove that node because then this thing would be incomplete.
So regardless of which value I destroy, this is the node that gets destroyed and maybe the nine moves into a different position as that happens.
What are your thoughts on if I said actually let's remove from this min heap?
What are your thoughts on how we would go about doing that based on things?
Statements that I've already made about the min heap and things that we do with them in heap?
What if I wanted to? What if I said, let's delete ? Any thoughts on how to go about that process of deleting ?
Yeah. Good for them. No.
Since the right and left the. And so the proposal was moving some node pointers around with the nodes to point to the other two.
That's that's actually not quite the thing I'm looking for. You want to go for it?
I can't do that. I can't pull it. The in the nine and then move the move the other things back.
Michelle. We could do something like that.
But it sounds like a really complicated, expensive operation. This is a tricky question.
Does anyone see the trick? Yeah. Yeah. Go for it. No, no, no.
You can't do it with respect to. It's a lot.
Put it in. Oh, no, we can't do that. And I'm so sorry.
Like, again, it is a trick question in the red Stanford sweater.
Yeah, you can't do it because earlier I said we can only delete the smallest thing from them in heap.
If someone says delete from a minute. That's a good day for you because you're like, I don't have to.
There's no way to do that. I'm not allowed. We're not allowed to rummage and look for that one.
Any one. All you can do is delete the smallest element of the minute.
So there's a delete min operation. There is not a delete arbitrary element operation from this thing.
So if I want to delete the min, it has to be the one.
What we do is this. We know that the nine node structurally this is the one that has to go away.
So when I delete the min, which by the way, is always at the root, this bottom rightmost node goes up to the root position like that.
And then I call an inverse operation of what I did earlier.
What was the operation that I did earlier?
Everyone with the when I was adding things I did what with the what was the name of that operation to move things up?
It was. So yeah, it's time to get it percolating, but this time we're going to percolate down.
My question is, when I percolate down, I have to ask, is mine too large to stay up there?
Yeah, it's larger than eight and five. It can't stay up there. So does anyone have any preference?
I'm either going to swap it down with the eight or I'm going to swap it down with the five.
Anyone have any preference on which way I go? Yeah.
Should be the five. Because if I swap down with the eight, the problem is then the eight moves up and the eight is too big to sit above the five.
When you're percolating down, you want to swap down with the smallest of the children.
The five is smaller. And so if I swap the nine down with the five, the five is small enough to stay here above the eight.
If I swap to the eight up here, it would be above a five. And you can't have that with many hips.
Okay, so that's my percolate down operation. And by the way,
the worst case for percolate down just like with percolate up the worst case is logarithmic it could go down the whole height of the tree.
Let's do another example here. If I delete one, the process is first excised the bottom.
Right, the bottom. The very last note over here, excise it, the 
So the moves up and you should the swap with your everyone.
or Yeah. is the smaller thing.
So goes there, the goes here. Who should swap with now.
or Yeah, the smaller one there, 
And by the way, if these were and the would have stopped percolating down.
It only percolates down if it has a smaller child like that.
So, so that's the percolate down operation.
And it's again, logarithmic because it goes the whole height of the tree. The worst case is the worst case.
By the way, when we when we call this deletion is that it goes down the entire height of the tree logarithmic.
Now sometimes when I ask people what's the best case runtime for this thing?
Sometimes people will say, Oh, the best case runtime would be order one.
Because what if I have a tiny element and I just swap it up here? Then it doesn't need to percolate down.
But you don't have tiny elements. Your biggest elements are at the bottom.
And so I think it starts to look like we must have a logarithmic operation to go all the way down that way.
But that's actually not the case.
And so I built this huge tree to demonstrate that if I want to delete to the last note here, moves up, and then when it percolates down,
it percolates down with a smaller child over here,
and then it just doesn't percolate down any more because it's hit nodes that are bigger than it, so it can't move down further.
So no matter how huge this tree was, I just did a single swap to move that thing up, a single swap down, and then that was that and it was finished.
These priority cues are used for a lot of interesting applications, like you could actually, if you wanted to sort a bunch of data,
just like get from small to large, just throw it all into a mini heap and then pull the elements out one by one.
You would get them in sorted order. And so there's actually a sorting algorithm called heap sort that does that.
You know, that the worst case for inserting an element is logarithmic. If you insert end of them into a min heap, that's order and log in to do it.
And then when you remove them all, the worst case for a single removal is longer than if you do the end times.
That end log in and you could use this for all kinds of applications, like creating maybe a printer queue where you want,
like you associate a print job with the number of pages that it's printing and
you use a mini heap so that when people send jobs to a shared printer in a lab,
the person who wants to print a single page percolate to the top of the heap and the person who's sitting there trying to print a text book,
they keep waiting in the queue is people with just one or two pages to print keep going ahead of them.
The final thing that I want to show you about this then is the representation for the min heap.
The way that we actually represent them in heap is we just use an array where and this is why it's important to keep this structurally complete,
because then you can number these from top to bottom left to right.
And I would just put these in the corresponding cells in the array like this.
And. Then.
So visually we conceive of them in heap as being this.
But in code we code it up using an array and that's actually going to be your next assignment is to play with that idea.
And in order to, by the way, percolate up and down then if your index to in the array like if I want to consider percolating this down,
I need to find its left and right child index in the array.
Or if I want to percolate up,
I need a formula that tells me that sevens parent is an index three in this array over here like to its parent is actually way over here.
And so I need some formulas that tell me how to get up and down through this thing where the parents and children are.
And I'll just give you those formulas to get the left child.
It's two of I it's two I plus one like two times two is four.
Add one, you get five. Three times two is six. At one you get seven, zero times two is zero at one, you get one.
That gives you the index of the left child. In this representation, the right child is just one more than that.
So one times two is to add two to that.
You get four. That gives you the index of the right child.
So if to do this math to figure out where am I going in the array to find the children, and then you just do the inverse of this.
If you take the A node minus one divide by two, so five minus one divide by two.
So that's four divided by two gives you index two for the parent.
And then here like six minus one is five divided that by divide that by two and that gets you but it's an integer that just truncates to two.
So you can use this formula to find the parent there. And so these are really neat because I think of that disconnect so that we have
this abstract idea of a tree and it's represented using actually an array,
which is kind of what you will play with. I wanted to give you a taste of that idea before you get into that next assignment.
Thanks for being here, everyone. I'll see you next Wednesday. Good luck with your exam tomorrow.
I'm rooting for your success.
