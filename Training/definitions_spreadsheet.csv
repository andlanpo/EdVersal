Term,Definition
C++," 
 
 
 
 
 
 
Chapter 1 
An Overview of C++ 
 
 
 
 
 
 
 
 
Out of these various experiments come programs.  "
C++,"— Stokely Carmichael and Charles V. Hamilton, 
Black Power, 1967 
2     Overview of C++ 
 
In Lewis Carroll’s Alice’s Adventures in Wonderland, the King asks the White 
Rabbit to “begin at the beginning and go on till you come to the end: then stop.”  
"
C++,"Some of you, for example, will already understand C++ control structures from 
prior experience with closely related languages such as C or Java.  "
C++,"For others, 
however, the structure of C++ will seem unfamiliar.  "
C++,"This chapter therefore 
“begins at the beginning” and introduces you to those parts of the C++ language 
you will need to write simple programs. 
 
 "
C++,"1.1 Your first C++ program 
As you will learn in more detail in the following section, C++ is an extension of an 
extremely successful programming language called C, which appeared in the early 
1970s.  "
C++,"1.1 Your first C++ program 
As you will learn in more detail in the following section, C++ is an extension of an 
extremely successful programming language called C, which appeared in the early 
1970s.  "
C++,"If you were to rewrite it in C++, the “Hello World” program would end up looking 
something like the code in Figure 1-1. 
 
"
C++,"The exact steps you need to use 
depend on the programming environment you’re using to create and run C++ 
programs.  "
C++,"Your first C++ program     3 
expected to use.  "
C++,"If you are reading this book on your own, you’ll need to refer to 
the documentation that comes with whatever programming environment you’re 
using for C++. 
 
"
C++,"1.2 The history of C++ 
"
C++,"Worse still, each type of computing hardware has its own 
4     Overview of C++ 
machine language, which means that a program written for one machine will not run 
on other types of hardware. 
 
"
C++,"C++ represents the 
joining of two branches in that evolution.  "
C++,"But C++ also descends from a family of languages designed to support a 
different style of programming that has dramatically changed the nature of software 
development in recent years. 
 
"
C++,"The history of C++     5 
Unfortunately, SIMULA did not generate a great deal of interest in the years 
after its introduction.  "
C++,"Although there were several parallel efforts to design 
an object-oriented language based on C, the most successful was the language C++, 
which was developed by Bjarne Stroustrup at AT&T Bell Laboratories in the early 
1980s.  "
C++,"C++ includes standard C as a subset, which makes it possible to integrate 
C++ code into existing C programs in a gradual, evolutionary way. 
 
"
C++,"C++ includes standard C as a subset, which makes it possible to integrate 
C++ code into existing C programs in a gradual, evolutionary way. 
 
"
C++,"The compilation process 
When you write a program in C++, your first step is to create a file that contains the 
text of the program, which is called a source file.  "
C++,"The process of 
6     Overview of C++ 
combining all the individual object files into an executable file is called linking.  
"
C++,"The good news is that 
the C++ programs themselves will look the same.  "
C++,"One of the advantages of 
programming in a higher-level language like C++ is that doing so allows you to 
ignore the particular characteristics of the hardware and create programs that will 
run on many different machines. 
 
 "
C++,"The structure of a C++ program 
The best way to get a feeling for the C++ programming language is to look at some 
sample programs, even before you understand the details of the language.  "
C++,"The structure of a C++ program 
The best way to get a feeling for the C++ programming language is to look at some 
sample programs, even before you understand the details of the language.  "
C++,"Since this book is designed for a 
second course in computer science, you’ve almost certainly written programs that 
read input from the user, store values in variables, use loops to perform repeated 
calculations, and make use of subsidiary functions to simplify the structure of the 
 
1.3 The structure of a C++ program     7 
program.  "
C++,"To illustrate more 
of the features of C++, Figure 1-3 shows the code for a program that lists powers of 
two along with some annotations that describe the various parts of the program. 
 
"
C++,"8     Overview of C++ 
"
C++,"The structure of a C++ program     9 
As you can see from Figure 1-3, the PowersOfTwo program includes a comment 
at the beginning that describes the program as a whole and one before the definition 
of raiseToPower that describes the operation of that function at a lower level of 
detail.  "
C++,"C++ defines a number of 
standard libraries, of which one of the most important is iostream.  "
C++,"This line instructs the C++ compiler to read the relevant definitions from what is 
called a header file.  "
C++,"The angle brackets in this line indicate that the header file is a 
system library that is part of standard C++.  "
C++,"In C++, reading in a header file using #include is often not sufficient by itself 
to use a system library.  "
C++,"To ensure that the names defined in different parts of a 
large system do not interfere with one another, the designers of C++ made it 
possible to segment code into structures called namespaces, each of which keeps 
track of its own set of names.  "
C++,"The standard C++ libraries use a namespace called 
std, which means that you cannot refer to the names defined in standard header 
files like iostream unless you let the compiler know to which namespace those 
definitions belong. 
 
"
C++,"Increasingly, professional C++ programmers specify the namespace explicitly by 
adding the prefix std:: before each name to which it applies.  "
C++,"For someone just learning the language, all those std:: tags make programs 
harder to read, so this book instead adopts the convention of adding the line 
 
using namespace std; 
10     Overview of C++ 
 
at the end of the library inclusion section.  "
C++,"For the moment, however, it is probably easiest to think of the 
 
using namespace std; 
 
as one of the incantations that the C++ compiler requires to work its magic on your 
code. 
 
"
C++,"Function prototypes 
Computation in a C++ program is carried out in the context of functions.  "
C++,"A C++ prototype consists of the first line of the function definition followed by a 
semicolon, as illustrated by the prototype 
 
int raiseToPower(int n, int k); 
 
This prototype tells the compiler everything it needs to know about how to call that 
function when it appears in the code.  "
C++,"C++ requires such prototype declarations so the compiler 
can check whether calls to functions are compatible with the function definitions.  "
C++,"The main program 
Every C++ program must contain a function with the name main.  "
C++,"The structure of a C++ program     11 
The first line of the main function in the PowersOfTwo program is an example 
of a variable declaration, which reserves space for a value used by the program.  "
C++,"When the computer executes this line of the program, it will display the prompt but 
leaves the console cursor—the blinking vertical bar or square that marks the current 
input position—at the end of the line, waiting for the user’s value, as follows: 
 
 
 
12     Overview of C++ 
"
C++,"Like all control statements in C++, the for statement is divided into 
a header line, which defines the nature of the control operation, and a body, which 
indicates which statements are affected by the control operation.  "
C++,"The structure of a C++ program     13 
and finally the end of line marker.  "
C++,"By convention, 
C++ uses the value of the main function to report the status of the entire program.  
"
C++,"In the PowersOfTwo program, the raiseToPower function is used to 
raise an integer to a power—an operation that is not built into C++ and must 
therefore be defined explicitly. 
 
"
C++,"The body of the 
for loop consists of the line 
 
14     Overview of C++ 
result *= n; 
 
which is C++ shorthand for the English sentence “Multiply result by n.”  "
C++,"The body of the 
for loop consists of the line 
 
14     Overview of C++ 
result *= n; 
 
which is C++ shorthand for the English sentence “Multiply result by n.”  "
C++,"The 
purpose of this section is to outline the rules for using variables in C++. 
 
"
C++,"Variable declarations 
In C++, you must declare each variable before you use it.  "
C++,"double n1, n2, n3; 
 
In this case, the variables are each declared to be of type double, which is the type 
C++ uses to represent numbers that can have fractional parts.  "
C++,"In C++, the initial contents of a variable are undefined.  "
C++,"Thus, the declaration 
 
int result = 1; 
 
16     Overview of C++ 
is a shorthand for the following code, in which the declaration and assignment are 
separate: 
 
int result; 
 
result = 1; 
 
An initial value specified as part of a declaration is called an initializer. 
 
"
C++,"In C++, the rules for identifier formation are 
 
1. 
"
C++,"Identifiers can be 
of any length, but C++ compilers are not required to consider any more than the 
first 31 characters in determining whether two names are identical. 
 
"
C++,"A better strategy is to declare it as a global constant like this: 
 
const double PI = 3.14159265358979323846; 
 
The keyword const at the beginning of this declaration indicates that the value will 
not change after the variable is initialized, thereby ensuring that the value remains 
18     Overview of C++ 
constant.  "
C++,"The only difference is that the name is written entirely in 
uppercase to be consistent with the C++ naming conventions for constants. 
 
"
C++,"If C++ had existed in those days, 
you might have declared a constant that looked like this: 
 
const int MAXIMUM_NUMBER_OF_HOSTS = 127; 
 
At some later point, however, the explosive growth of networking would force you 
to raise this bound.  "
C++,"1.5 Data types     19 
 1.5 Data types 
Each variable in a C++ program contains a value constrained to be of a particular 
type.  "
C++,"So far, you have 
seen variables of type int and double, but these types merely scratch the surface 
of the types available in C++.  "
C++,"Learning how to manipulate data of various types is an 
essential part of mastering the basics of any language, including C++. 
 
"
C++,"The concept of a data type 
In C++ , every data value has an associated data type.  "
C++,"As you will learn in the later chapters in this book, much of the power of modern 
programming languages like C++ comes from the fact that you can define new data 
types from existing ones.  "
C++,"To get that process started, C++ includes several 
fundamental types that are defined as part of the language.  "
C++,"Integer types 
Although the concept of an integer seems like a simple one, C++ actually includes 
several different data types for representing integer values.  "
C++,"To get around this problem, 
C++ defines three integer types—short, int, and long—distinguished from each 
other by the size of their domains. 
 
"
C++,"20     Overview of C++ 
Unfortunately, the language definition for C++ does not specify an exact range 
for these three types.  "
C++,"20     Overview of C++ 
Unfortunately, the language definition for C++ does not specify an exact range 
for these three types.  "
C++,"A compiler designer for C++ could, for example, decide to make 
short and int the same size but could not make int smaller than short. 
"
C++,"The designers of C++ could have chosen to define the allowable range of type 
int more precisely.  "
C++,"In C++, each of the integer types int, long, and short may be preceded by the 
keyword unsigned.  "
C++,"C++ allows the type 
unsigned int to be abbreviated to unsigned, and most programmers who use 
this type tend to follow this practice. 
 
"
C++,"C++ defines three different 
floating-point types: float, double, and long double.  "
C++,"Although ANSI C++ 
does not specify the exact representation of these types, the way to think about the 
difference is that the longer types—where long double is longer than double, 
which is in turn longer than float—allow numbers to be represented with greater 
precision at the cost of occupying more memory space.  "
C++,"In keeping with a common convention among 
C++ programmers, this text uses the type double as its standard floating-point 
type. 
 
"
C++,Floating-point constants in C++ are written with a decimal point.  
C++,"For example, the speed of light in meters per 
second can be written in C++ as 
 
2.9979E+8 
 
where the E stands for the words times 10 to the power. 
 
"
C++,"In C++, the Boolean type is called bool.  "
C++,"22     Overview of C++ 
Characters 
In the early days, computers were designed to work only with numeric data and 
were sometimes called number crunchers as a result.  "
C++,"The most primitive elements of text data are individual characters, which are 
represented in C++ using the predefined data type char.  "
C++,"In most implementations of C++, the coding system used 
to represent characters is called ASCII, which stands for the American Standard 
Code for Information Interchange.  "
C++,"You can write a character constant in C++ by enclosing the character in single 
quotes.  "
C++,"In addition to the standard characters, C++ allows you to write special characters 
in a multicharacter form beginning with a backward slash (\).  "
C++,"Table 1-3 shows the escape sequences that C++ supports. 
 
"
C++,"You write string constants in C++ by enclosing the characters contained within 
the string in double quotes.  "
C++,"As with character, C++ uses the escape sequences from 
Table 1-3 to represent special characters.  "
C++,"24     Overview of C++ 
Given that they are essential to so many applications, all modern programming 
languages include special features for working with strings.  "
C++,"Unfortunately, C++ 
complicates the issue by defining two different string types: an older style inherited 
from C and a more sophisticated string library that supports the object-oriented 
paradigm.  "
C++,"For the 
moment, you can simply imagine that C++ offers a built-in data type called string 
whose domain is the set of all sequences of characters.  "
C++,"C++ allows you to define new types simply by listing 
the elements in their domain.  "
C++,"For example, the following definition introduces a new Direction 
type whose values are the four compass directions: 
 
enum Direction { NORTH, EAST, SOUTH, WEST }; 
 
 
1.5 Data types     25 
When the C++ compiler encounters this definition, it assigns values to the constant 
names by numbering them consecutively starting with 0.  "
C++,"C++ allows you to assign explicit underlying values to each of the constants of 
an enumerated type.  "
C++,"If you supply values for some of the 
constants but not others, the C++ compiler will automatically choose values for the 
unassigned constants by numbering them consecutively after the last value you 
supplied.  "
C++,"Moreover, 
because C++ represents a synthesis of the object-oriented and procedural 
26     Overview of C++ 
paradigms, the type system includes both objects and more traditional structures. 
"
C++,"Moreover, 
because C++ represents a synthesis of the object-oriented and procedural 
26     Overview of C++ 
paradigms, the type system includes both objects and more traditional structures. 
"
C++,"In C++, you could compute the first of these solutions 
by writing the following expression: 
 
(-b + sqrt(b * b - 4 * a * c)) /"
C++,"Even so, the C++ form of the expression 
captures the intent of its mathematical counterpart in a way that is quite readable, 
particularly if you’ve written programs in any modern programming language. 
 
"
C++,"In C++, an expression is composed of terms and operators.  "
C++,"A list of the operators available in C++ appears in 
Table 1-4.  "
C++,"When it appears between two operands, as 
it does inside the argument to sqrt, the minus sign is a binary operator signifying 
28     Overview of C++ 
subtraction.  "
C++,"Most operators in C++ are left-associative, which means that the 
leftmost operator is evaluated first.  "
C++,"In C++, you can write an expression that includes values of different numeric types.  
"
C++,"If C++ encounters an operator whose operands are of different types, the compiler 
automatically converts the operands to a common type by choosing the type that 
appears closest to the top of the hierarchy in Table 1-5.  "
C++,"If you 
write an expression like 
 
9 / 4 
 
C++’s rules specify that the result of this operation must be an integer, because both 
operands are of type int.  "
C++,"When C++ evaluates this expression, it divides 9 by 4 
and discards any remainder.  "
C++,"Thus, the value of this expression in C++ is 2, not 
2.25. 
 
"
C++,"The / operator in C++ is closely associated with the % operator, which returns 
the remainder left over when the first operand is divided by the second.  "
C++,"For 
example, the value of 
 
9 % 4 
 
30     Overview of C++ 
is 1, since 4 goes into 9 twice, with 1 left over.  "
C++,"In C++, you can specify explicit conversion by using what is called a type cast, 
which specifies an explicit conversion from one type to another.  "
C++,"In C++, type casts 
are usually written by specifying the name of the desired type followed by the value 
you wish to convert in parentheses.  "
C++,"The assignment operator 
In C++, assignment of values to variables is built into the expression structure.  
"
C++,"C++’s definition of assignment as an operator 
32     Overview of C++ 
makes it possible, instead of writing separate assignment statements, to write a 
single statement like 
 
n1 = n2 = n3 = 0; 
 
which has the effect of setting all three variables to 0.  "
C++,"C++’s definition of assignment as an operator 
32     Overview of C++ 
makes it possible, instead of writing separate assignment statements, to write a 
single statement like 
 
n1 = n2 = n3 = 0; 
 
which has the effect of setting all three variables to 0.  "
C++,"This statement works 
because C++ evaluates assignment operators from right to left.  "
C++,"As a programming convenience, C++ allows you to combine assignment with a 
binary operator to produce a form called a shorthand assignment.  "
C++,"Because this same shorthand applies to any binary operator in C++, you can 
subtract the value of surcharge from balance by writing 
 
balance -= surcharge; 
 
Similarly, you can divide the value of x by 10 using 
 
x /= 10; 
 
 
1.7 Expressions     33 
Increment and decrement operators 
Beyond the shorthand assignment operators, C++ offers a further level of 
abbreviation for the particularly common programming operations of adding or 
subtracting 1 from a variable.  "
C++,"Because this same shorthand applies to any binary operator in C++, you can 
subtract the value of surcharge from balance by writing 
 
balance -= surcharge; 
 
Similarly, you can divide the value of x by 10 using 
 
x /= 10; 
 
 
1.7 Expressions     33 
Increment and decrement operators 
Beyond the shorthand assignment operators, C++ offers a further level of 
abbreviation for the particularly common programming operations of adding or 
subtracting 1 from a variable.  "
C++,"To indicate these operations in an 
extremely compact form, C++ uses the operators ++ and --.  "
C++,"For example, the 
statement 
 
x++; 
 
in C++ has the same effect on the variable x as 
 
x += 1; 
 
which is itself short for 
 
x = x + 1; 
 
Similarly, 
 
y--; 
 
has the same effect as 
 
y -= 1; 
 
or 
 
y = y - 1; 
 
As it happens, these operators are more intricate than the previous examples 
would suggest.  "
C++,"You notice the difference only if you use 
34     Overview of C++ 
these operators as part of a larger expression.  "
C++,"On the other hand, ++ and -- are 
firmly entrenched in the historical tradition shared by the languages C, C++, and 
Java.  "
C++,"Boolean operators 
C++ defines three classes of operators that manipulate Boolean data: the relational 
operators, the logical operators, and the ?: operator.  "
C++,"C++ defines six relational operators, as follows: 
 
== 
Equal 
!"
C++,"This mistake 
can also be very difficult to track down because the C++ compiler does not usually 
catch it as an error.  "
C++,"A single equal sign turns the expression into an embedded 
assignment, which is perfectly legal in C++; it just isn’t at all what you want. 
 
 
"
C++,"In addition to the relational operators, C++ defines three logical operators that 
take Boolean operands and combine them to form other Boolean values: 
 
! 
"
C++,"Whenever a C++ program evaluates an expression of the form 
 
exp1 && exp2 
 
or 
 
exp1 || exp2 
 
the individual subexpressions are always evaluated from left to right, and evaluation 
ends as soon as the result can be determined.  "
C++,"36     Overview of C++ 
"
C++,"The C++ programming language includes another Boolean operator called ?: 
that can be extremely useful in certain situations.  "
C++,"Unlike the 
other operators in C++, ?: is written in two parts and requires three operands.  "
C++,"The parentheses are not technically required, but C++ programmers often include 
them to emphasize the boundaries of the conditional test. 
 
"
C++,"When a C++ program encounters the ?: operator, it first evaluates the condition.  
"
C++,"x : y; 
 
 1.7 Statements 
Programs in C++ are composed of functions, which are made up in turn of 
statements.  "
C++,"As in most languages, statements in C++ fall into one of two principal 
classifications: simple statements that perform some action and control statements 
that affect the way in which other statements are executed.  "
C++,"The sections that follow 
review the principal statement forms available in C++, giving you the tools you 
need to write your own programs. 
 
"
C++,"Simple statements 
The most common statement in C++ is the simple statement, which consists of an 
expression followed by a semicolon: 
 
expression; 
 
In most cases, the expression is a function call, an assignment, or a variable 
followed by the increment or decrement operator. 
 
"
C++,"Blocks 
As C++ is defined, control statements typically apply to a single statement.  "
C++,"statementn 
} 
 
When the C++ compiler encounters a block, it treats the entire block as a single 
statement.  "
C++,"In C++, the statements in any 
block may be preceded by declarations of variables. 
 
"
C++,"The easiest way to 
express conditional execution in C++ is by using the if statement, which comes in 
two forms: 
 
if (condition) statement 
 
if (condition) statement else statement 
 
You use the first form of the if statement when your solution strategy calls for a set 
of statements to be executed only if a particular Boolean condition is true.  "
C++,"38     Overview of C++ 
if (n % 2 == 0) { 
   cout <<"
C++,"In fact, C++ is defined so that if the break statement is missing, the program starts 
executing statements from the next clause after it finishes the selected one.  "
C++,"The C++ compiler treats this construction as two case 
clauses, the first of which is empty.  "
C++,"The constants in a switch statement must be a scalar type, which is defined in 
C++ as a type that uses an integer as its underlying representation.  "
C++,"In particular, 
characters are often used as case constants, as illustrated by the following function, 
which tests to see if its argument is a vowel: 
 
40     Overview of C++ 
bool isVowel(char ch) { 
   switch (ch) { 
    case 'A': case 'E': case 'I': case 'O': case 'U': 
    case 'a': case 'e': case 'i': case 'o': case 'u': 
      return true; 
    default: 
      return false; 
   } 
} 
 
Enumerated types also qualify as scalar types, as illustrated by the function 
 
string directionToString(Direction dir) { 
   switch (dir) { 
    case NORTH: return ""NORTH""; 
    case EAST: return ""EAST""; 
    case SOUTH: return ""SOUTH""; 
    case WEST: return ""WEST""; 
    default: return ""???"
C++,"The while statement 
In addition to the conditional statements if and switch, C++ includes several 
control statements that allow you to execute some part of the program multiple 
times to form a loop.  "
C++,"The 
simplest iterative statement in C++ is the while statement, which executes a 
statement repeatedly until a conditional expression becomes false.  "
C++,"The operation of the while loop is illustrated by the following function, which 
computes the sum of the digits in an integer: 
 
42     Overview of C++ 
int digitSum(int n) { 
   int sum = 0; 
   while (n > 0) { 
      sum += n % 10; 
      n /= 10; 
   } 
   return sum; 
} 
 
"
C++,"One strategy for solving the loop-and-a-half problem in C++ is to use the break 
statement, which, in addition to its use in the switch statement, has the effect of 
immediately terminating the innermost enclosing loop.  "
C++,"The for statement 
One of the most important control statements in C++ is the for statement, which is 
used in situations in which you want to repeat an operation a particular number of 
times.  "
C++,"""2 to the "" << i << "" = "" 
        << raiseToPower(2, i) << endl; 
} 
44     Overview of C++ 
 
"
C++,"46     Overview of C++ 
The for loop in C++, however, is considerably more general than the earlier 
examples suggest.  "
C++,"46     Overview of C++ 
The for loop in C++, however, is considerably more general than the earlier 
examples suggest.  "
C++,"Its purpose was to introduce you to the C++ programming language and 
give you a crash course in how to write simple programs in that language.  "
C++,"In the 30+ years of its existence, the C++ programming language has become 
one of the most widely used languages in the world. 
"
C++,"A typical C++ program consists of comments, library inclusions, program-level 
definitions, function prototypes, a function named main that is called when the 
program is started, and a set of auxiliary functions that work together with the 
main program to accomplish the required task. 
"
C++,• Variables in a C++ program must be declared before they are used.  
C++,"Most 
variables in C++ are local variables, which are declared within a function and 
can only be used inside the body of that function. 
"
C++,"48     Overview of C++ 
•"
C++,"C++ 
includes several primitive types that allow programs to store common data values 
including integers, floating-point numbers, Booleans, and characters.  "
C++,"As you 
will learn in later chapters, C++ also allows programmers to define new types 
from existing ones. 
"
C++,"• The easiest way to perform input and output operations in C++ is to use the 
iostream library.  "
C++,"• Expressions in C++ are written in a form similar to that in most programming 
languages, with individual terms connected by operators.  "
C++,"A list of the C++ 
operators appears in Table 1-4 along with their precedence and associativity. 
"
C++,"• Statements in C++ fall into two general categories: simple statements and control 
statements.  "
C++,C++ programs are typically subdivided into several functions.  
C++,"What characters are used to mark comments in a C++ program? 
 
"
C++,"What is the name of the function that must be defined in every C++ program?  
"
C++,"8. 
Indicate which of the following are legal variable names in C++: 
 
a. 
x 
g. 
total output 
b. 
formula1 
h. 
aVeryLongVariableName 
c. 
"
C++,"50     Overview of C++ 
18."
C++,"What is a type cast and how do you indicate one in C++? 
 
19."
C++,"The output therefore tells us 
52     Overview of C++ 
that the longest book (Harry Potter and the Order of the Phoenix) has 766 
pages and the second-longest book (Harry Potter and the Goblet of Fire) 
weighs in at a mere 636 pages. 
 
"
C++,"If you start with 1, subtract one-third, 
54     Overview of C++ 
add one-fifth, and so on, for each of the odd integers, you get a number that 
gets closer and closer to the value of !"
C++,"— Jorge Luis Borges, “Poem of the Gifts,” 1960 
56     Functions and Libraries 
 
As you know from the examples from Chapter 1, programs in C++ typically consist 
of a sequence of functions.  "
C++,"This chapter looks more expansively at the idea of a 
function and the realization of that concept in C++.  "
C++,"At the same time, 
functions in C++ are much more general than their counterparts in mathematics, 
which means that you’ll have to move beyond the mathematical conception and 
think more expansively about how you might use functions as a programmer.  "
C++,"For example, building on the examples of functions you saw in 
Chapter 1, you know that you can implement the function ƒ in C++ like this: 
 
double f(double x) { 
   return x * x + 1; 
} 
 
This definition includes various bits of syntax that are absent from the mathematical 
formulation, but the basic idea is the same.  "
C++,"Like their mathematical counterparts, functions in C++ can specify 
input values, but don’t need to do so.  "
C++,"Similarly, functions in C++ aren’t required to 
return results.  "
C++,"The essential characteristic of a C++ function is that it associates a 
computational operation—specified by a block of code that forms the body of the 
function—with a particular name.  "
C++,"This model of functions in the context of programming makes it possible to 
define several terms that are essential to understanding how functions work in C++.  
"
C++,"To specify a function call in C++, you write the name of the 
function, followed by a list of expressions enclosed in parentheses.  "
C++,"You can easily translate this algorithmic description into the following code in C++: 
 
int gcd(int x, int y) { 
   int r"
C++,"2.2 Libraries 
When you write a C++ program, most of the code the computer executes is not the 
code you have written yourself, but the library code that you have loaded along with 
your application.  "
C++,"If you want to become an effective C++ 
programmer, you need to spend at least as much time learning about the standard 
libraries as you do learning the language itself. 
 
"
C++,"Fortunately, C++ has an extensive mathematical library 
called <cmath> that includes all the functions you are ever likely to need.  "
C++,"The most 
common functions in the <cmath> library appear in Table 2-1.    Don’t worry if you 
 
2.3 Defining functions in C++     61 
have no idea what some of those functions mean.  "
C++,"2.3 Defining functions in C++ 
"
C++,"Although you saw several functions in Chapter 1 and even had a chance to write a 
few of your own in the exercises, it makes sense to review the rules for writing 
functions in C++ before going on to investigate how to use them most effectively.  
"
C++,"In C++, a function definition has the following syntactic form: 
 
type name(parameters) { 
   . ."
C++,"You can, however, signal early completion of a procedure 
by executing a return statement without a value expression, as follows: 
 
return; 
 
Function prototypes 
When the C++ compiler encounters a function call in your program, it needs to have 
some information about that function in order to generate the correct code.  "
C++,"2.3 Defining functions in C++     63 
You have already seen examples of prototypes in Chapter 1.  "
C++,"Overloading 
In C++, it is legal to give the same name to more than one function as long as the 
pattern of arguments is different.  "
C++,"In 
C++, all you need to remember is the single function name abs. 
 
"
C++,"In addition to overloading, C++ makes it possible to specify that certain parameters 
are optional.  "
C++,Default parameters tend to be overused in C++.  
C++,"It is almost certainly better to define an 
overloaded version of the function with the following implementation: 
 
void setInitialLocation() { 
   setInitialLocation(0, 0); 
} 
 
 2.4 The mechanics of function calls 
Although you can certainly get by with an intuitive understanding of how the 
function-calling process works, it sometimes helps—particularly when you start to 
work with recursive functions in Chapter 7—to understand precisely what happens 
when one function calls another in C++.  "
C++,"Whenever a function call occurs, the C++ compiler generates code to implement the 
following operations: 
 
1. 
"
C++,"The code to compute the combinations function in C++ appears in Figure 2-2, along 
with a main program that requests values of n and k from the user and then displays 
the value of the function C(n, k).  "
C++,"In C++, all 
programs begin by making a call to the function main.  "
C++,"In C++, those function calls can happen in any 
order, but it’s easiest to process them from left to right.  "
C++,"In C++, index variables declared in a 
for loop header are accessible only inside the loop body.  "
C++,"2.5 Reference parameters 
In C++, whenever you pass a simple variable from one function to another, the 
function gets a copy of the calling value.  "
C++,"If you want to change the value of the calling argument—and there are often 
compelling reasons for doing so—you can change the parameter from the usual kind 
of C++ parameter (which is called a value parameter) into a reference parameter 
by adding an ampersand between the type and the name in the function header.  
"
C++,"In C++, one of the most common uses of call by reference occurs when a 
function needs to return more than one value to the calling program.  "
C++,"The code for error 
looks like this: 
 
void error(string msg) { 
   cerr << msg << endl; 
   exit(EXIT_FAILURE); 
} 
 
The code for error uses two features of C++ that have not yet made their 
appearance in this book: the cerr output stream and the exit function.  "
C++,"When you define a library in C++, you need to supply two parts.  "
C++,"In C++, the interface and implementation are usually written as two separate 
files.  "
C++,"Here, the body of the 
80     Functions and Libraries 
error function is all of two lines long, and the purpose of each of those lines is 
instantly recognizable to any C++ programmer. 
 
"
C++,"Most of the interfaces you will use in C++ also export data types.  
"
C++,"Most of these types will be classes, which are the foundation of the object-oriented 
type system that C++ provides.  "
C++,"While C++ lets you freely convert an enumerated value 
to an integer, conversions in the opposite direction—from an integer to the 
corresponding value of an enumerated type—require a type cast.  "
C++,"If you declare PI as a 
constant in the fashion introduced in Chapter 1, you would write 
 
const double PI = 3.14159265358979323846; 
 
In C++, constants written in this form are private to the source file that contains 
them and cannot be exported through an interface.  "
C++,"Given that the C++ libraries include a function for generating pseudorandom 
numbers, it is reasonable to ask why one would bother to develop a new interface to 
support this process.  "
C++,"In fact, the RandTest program 
produces the same output every time because the designers of the C++ library (and 
the earlier C libraries on which these libraries are based) decided that rand should 
return the same random sequence each time a program is run. 
 
"
C++,"As you know from the multiple runs of the RandTest program, the C++ library 
sets the initial seed to a constant value every time a program is started, which is why 
rand always generates the same sequence of values.  "
C++,"In C++, you can retrieve the current value of the 
system clock by calling the function time and then converting the result to an 
integer.  "
C++,"Unfortunately, it doesn’t work to declare that flag 
as a global variable because C++ does not specify the order in which global 
variables are initialized.  "
C++,"In C++, the best strategy is to declare the initialization flag inside the context of 
the function that checks to see whether the necessary initialization has already been 
performed.  "
C++,"The rules of C++ ensure that static local variables 
are initialized exactly once and, moreover, that the initialization occurs before the 
function containing them is called.  "
C++,"2.8 Designing a random number library     105 
Figure 2-8 
106     Functions and Libraries 
Figure 2-8 
 
2.9 Introduction to the Stanford libraries     107 
 2.9 Introduction to the Stanford libraries 
Up to this point, the programs in this book use only standard features of C++.  "
C++,"For 
that reason, these programs should work with any C++ compiler on any type of 
hardware.  "
C++,"As part of the supporting material for this textbook, Stanford University provides 
a set of libraries that make learning to program in C++ both easier and more 
enjoyable.  "
C++,"2.9 Introduction to the Stanford libraries     109 
Graphical programs in the Stanford libraries 
One of the challenges of using C++ as a teaching language is that C++ doesn’t offer 
a standard graphics library.  "
C++,"2.9 Introduction to the Stanford libraries     109 
Graphical programs in the Stanford libraries 
One of the challenges of using C++ as a teaching language is that C++ doesn’t offer 
a standard graphics library.  "
C++,"In C++, functions must be declared before they are used.  "
C++,"Summary     113 
• C++ allows you to define several functions with the same name as long as the 
compiler can use the number and types of the arguments to determine which 
function is required.  "
C++,"C++ also 
makes it possible to specify default parameters, which are used if the client 
omits them from the call. 
"
C++,"• C++ makes it possible for a function and its caller to share the value of a 
parameter variable by marking it with the ampersand character (&).  "
C++,"In C++, interfaces are stored in header files, which typically end with a .h 
suffix.  "
C++,"3. 
True or false: Every function in a C++ program requires a prototype. 
 
"
C++,"How does the C++ compiler use 
signatures to implement overloading? 
 
"
C++,"How do you indicate call by reference in a C++ program? 
 
"
C++,"When a floating-point number is converted to an integer in C++, the value is 
truncated by throwing away any fraction.  "
C++,"In C++, the best way to check for this condition 
is to test whether the average is equal to either of the values used to 
generate it. 
 
"
C++,"Now that you have C++ implementations for each of these 
functions, it might be worth putting them in a library so that you can use them 
in many different applications. 
 
"
C++,"This chapter introduces the C++ <string> library, which provides a convenient 
abstraction for working with strings of characters.  "
C++,"Although C++ also defines a more primitive string type, most text-processing 
applications work instead with objects of a class called string.  "
C++,"In C++, the string class and its associated operations are defined in the 
<string> library, and you must therefore include this library in any source file that 
manipulates string data. 
 
"
C++,"Early versions of C++ followed the 
lead of the older C language and offered little support for manipulating strings.  "
C++,"The designers of C++ soon solved that problem by 
introducing a string class that enables clients to work at a more abstract level. 
 
"
C++,"int nChars = length(str);
   
 
 
As the bug icon emphasizes, this statement is incorrect in C++.  "
C++,"In C++, 
methods look and behave much like traditional functions, although it helps to give 
them a new name to emphasize that there are differences.  "
C++,"In C++, 
sending a message is specified using the following syntax: 
 
receiver.name(arguments) 
 
"
C++,"130     Strings 
 
<string> methods 
 
3.2 String operations     131 
 
 
Operator overloading 
As you can see from the first section of Table 3-1, the <string> library redefines 
several of the standard operators using an extremely powerful C++ feature called 
operator overloading, which redefines the behavior of operators depending on the 
types of their operands.  "
C++,"That feature is not available in C++, which treats any attempt to use 
the + operator with incompatible operands as an error. 
 
"
C++,"C++ also overloads the relational operators so that you can compare string 
values much more conveniently than you can in many other languages, including C 
and Java.  "
C++,"In C++, positions within a string are numbered starting from 0.  "
C++,"Although C++ programmers 
tend to use the square-bracket syntax for its expressiveness, it is arguably better to 
call the at method instead.  "
C++,"The expressions str[i] and str.at(i) have almost 
the same meaning in C++; the only difference is that at checks to make sure the 
index is in range. 
 
"
C++,"String assignment 
C++ does take some steps to mitigate the conceptual problems that follow from 
allowing the client to change individual characters in an existing string.  "
C++,"In 
particular, C++ redefines assignment for strings so that assigning one string to 
another copies the underlying characters.  "
C++,"Similarly, C++ copies 
the characters in any string passed as a value parameter.  "
C++,"Because indices in C++ begin at 0, the 
character at index position 1 is the character 'e'. 
 
"
C++,"The startsWith function and the similar endsWith function you will have a 
chance to write in exercise 1 turn out to be very useful, even though they are not 
part of the standard <string> library in C++.  "
C++,"3.4 Modifying the contents of a string 
Unlike other languages such as Java, C++ allows you to change the characters in a 
string by assigning new values to a particular index position.  "
C++,"Having the first version, 
however, makes it possible to code the second in a more efficient way: 
 
string toUpperCase(string str) { 
   toUpperCaseInPlace(str); 
   return str; 
} 
 
In this implementation, C++ automatically copies the argument string because it is 
passed by value.  "
C++,"The legacy of C-style strings 
In its early years, C++ succeeded in part because it includes all of C as a subset, 
thereby making it possible to evolve gradually from one language to the other.  "
C++,"That 
design decision, however, means that C++ includes some aspects of C that no 
longer make sense in a modern object-oriented language, but nonetheless need to be 
maintained for compatibility."
C++,"Unfortunately, the 
decision to keep C++ compatible with C means that C++ must support both styles.  
"
C++,"Unfortunately, the 
decision to keep C++ compatible with C means that C++ must support both styles.  
"
C++,"For the 
most part, you can ignore this historical detail because C++ automatically converts a 
string literal to a C++ string whenever the compiler can determine that what you 
want is a C++ string.  "
C++,"For the 
most part, you can ignore this historical detail because C++ automatically converts a 
string literal to a C++ string whenever the compiler can determine that what you 
want is a C++ string.  "
C++,"For the 
most part, you can ignore this historical detail because C++ automatically converts a 
string literal to a C++ string whenever the compiler can determine that what you 
want is a C++ string.  "
C++,"If you initialize a string using the line 
 
string str = ""hello, world""; 
 
C++ automatically converts the C-style string literal ""hello, world"" to a C++ 
string object, because you’ve told the compiler that str is a string variable.  "
C++,"If you initialize a string using the line 
 
string str = ""hello, world""; 
 
C++ automatically converts the C-style string literal ""hello, world"" to a C++ 
string object, because you’ve told the compiler that str is a string variable.  "
C++,"By 
contrast, C++ does not allow you to write the declaration 
 
string str = ""hello"" + "", "" + ""world"";
   
 
 
even though it seems as if this statement would have the same ultimate effect.  "
C++,"The 
problem here is that this version of the code tries to apply the + operator to string 
literals, which are not C++ string objects. 
 
"
C++,"The following line, for example, 
correctly converts ""hello"" to a C++ string object and then uses concatenation to 
complete the calculation of the initial value: 
 
string str = string(""hello"") + "", "" + ""world""; 
 
Another problem that arises from having two different representations for strings 
is that some C++ libraries require the use of C-style strings instead of the more 
modern C++ string class.  "
C++,"The following line, for example, 
correctly converts ""hello"" to a C++ string object and then uses concatenation to 
complete the calculation of the initial value: 
 
string str = string(""hello"") + "", "" + ""world""; 
 
Another problem that arises from having two different representations for strings 
is that some C++ libraries require the use of C-style strings instead of the more 
modern C++ string class.  "
C++,"The following line, for example, 
correctly converts ""hello"" to a C++ string object and then uses concatenation to 
complete the calculation of the initial value: 
 
string str = string(""hello"") + "", "" + ""world""; 
 
Another problem that arises from having two different representations for strings 
is that some C++ libraries require the use of C-style strings instead of the more 
modern C++ string class.  "
C++,"If you use these library abstractions in the context of an 
application that uses C++ strings, you must at some point convert the C++ string 
objects into their older, C-style counterparts.  "
C++,"If you use these library abstractions in the context of an 
application that uses C++ strings, you must at some point convert the C++ string 
objects into their older, C-style counterparts.  "
C++,"Specifying that conversion is simple 
enough: all you have to do is apply the c_str method to the C++ version of a string 
to obtain its C-style equivalent.  "
C++,"The more important problem, however, is that 
having to master two different representations for strings increases the conceptual 
complexity of C++, thereby making it harder to learn. 
 
 "
C++,"Translating English to Pig Latin 
To give you more of a sense of how to implement string-processing applications, 
this section describes a C++ program that reads a line of text from the user and then 
translates each word in that line from English to Pig Latin, a made-up language 
familiar to most children in the English-speaking world.  "
C++,"The first four functions in Table 3-3, all of which are concerned with 
converting numeric values to string form, require techniques that are beyond the 
limits of your knowledge of C++, but only for the moment.  "
C++,"Although C++ also includes a more primitive string type to 
maintain compatibility with the C programming language, it is best to use the 
string class in any programs that you write. 
"
C++,"If you want to read an entire line of text from the 
user, it is usually better to use the getline function from the standard C++ 
libraries. 
"
C++,"5. 
True or false: In C++, you can determine the length of the string stored in the 
variable str by calling length(str). 
 
"
C++,"When C++ evaluates the expression s1 < s2, what rule does the string class 
use to compare the string values? 
 
"
C++,"When you select an individual character from a C++ string, you can use either 
the at method or the standard subscript notation using square brackets.  "
C++,"Why does C++ support both a string class and a more primitive string type? 
 
"
C++,How can you convert a primitive string value to a C++ string?  
C++,"As an example, suppose that you have the 
following DNA strand, in which the position of each base has been numbered 
as it would be in a C++ string: 
 
 
 
Your mission in this exercise is to determine where a shorter DNA strand can 
attach itself to the longer one.  "
C++,"— Reverend Martin Luther King, Jr. 
“I Have a Dream,” August 28, 1963 
(paraphrasing Amos 5:24) 
160     Streams 
 
Ever since HelloWorld back in Chapter 1, the programs in this book have made 
use of an important data structure called a stream, which C++ uses to manage the 
flow of information to or from some data source.  "
C++,"To write C++ programs that move beyond the simple examples 
you have seen up to now, you will have to learn more about streams and how to use 
them to create more sophisticated applications.  "
C++,"The chapter then concludes by exploring the structure 
of the C++ stream classes as a representative example of inheritance hierarchies in 
an object-oriented language. 
 
 "
C++,"4.1 Formatted output 
The easiest way to generate formatted output in C++ is to use the << operator.  "
C++,"This feature makes it easy to display the values of variables, because C++ 
handles the output conversion automatically. 
 
"
C++,"C++ makes generating output even more convenient by having the << operator 
return the value of the stream.  "
C++,"In C++, you would start with the expression 
 
cout <<"
C++,"""The total is "" << total << endl; 
 
If total contains the value 42, the resulting output would look like this on the 
console: 
 
 
 
Even though you have been using statements like this one since the very 
beginning, knowing that the << operator propagates the value of cout through the 
expression as it moves along the chain of insertion operators may help you to 
appreciate how output works in C++. 
 
"
C++,"Although it seems as if it might be a simple string constant, the endl value used 
to signal the end of an output line is actually an example of something that C++ 
calls a manipulator, which is just a fancy name for a special type of value used to 
control formatting.  "
C++,"The C++ libraries export a variety of manipulators that you can 
use to specify the format for output values, the most common of which appear in 
Table 4-1.  "
C++,"In the absence of any specifications to the contrary, C++ represents 
floating-point numbers using either decimal or scientific notation, choosing the 
representation that is more compact.  "
C++,"The fact that C++ can choose either of these 
representations makes sense if all you care about is seeing the value.  "
C++,"If, however, 
you want to control the output more precisely, you need to indicate which of these 
formats you would like C++ to use.  "
C++,"4.2 Formatted input 
Formatted input in C++ is enabled by the operator >>, which you have already used 
in a variety of programs.  "
C++,"Using file streams 
As you will discover in section 4.4, the C++ stream library exports several classes 
that form a hierarchical structure.  "
C++,"C++ is no exception to this rule. 
 
"
C++,"Reading or writing a file in C++ requires the following steps: 
 
"
C++,"Input streams in the C++ library 
support reading a single character using a method called get, which exists in two 
forms.  "
C++,"C++ 
makes this operation very easy by allowing streams to be used in conditional 
contexts.  "
C++,"Although this strategy is extremely simple, many C++ programmers will use the 
version of get that returns a character, mostly because that strategy was available 
even back in the days of C programming.  "
C++,"Many C++ programmers, however, implement this loop in the following slightly 
shorter but decidedly more cryptic form: 
 
int ch; 
while ((ch = infile.get()) !"
C++,"When C++ evaluates this test, it begins by evaluating the 
subexpression 
 
ch = infile.get() 
 
which reads a character and assigns it to ch.  "
C++,"Because 
this idiom occurs frequently in existing C++ code, you need to recognize it and 
understand it when it appears.  "
C++,"The open 
call, for example, needs to use c_str to convert the C++ string stored in filename 
to the old-style C string that the stream library requires.  "
C++,"Consider, for example, what happens 
when the C++ extraction operator tries to read an integer, which is represented as a 
string of decimal digits.  "
C++,"C++ solves this problem for input streams by exporting a method called unget 
that has the following form: 
 
infile.unget(); 
 
The effect of this call is to “push” the most recent character back into the input 
stream so that it is returned on the next call to get.  "
C++,"The specifications for the C++ 
library guarantees that it will always be possible to push one character back into the 
input file, but you should not rely on being able to read several characters ahead and 
then push them all back.  "
C++,"Since >> returns the stream, it will 
indicate the end-of-file condition by setting the fail flag, which C++ then 
interprets as false. 
 
"
C++,"Although the C++ libraries include a function called atoi that converts a string 
to an integer, that function predates the <string> library and therefore requires the 
use of C strings, which are much less convenient to use.  "
C++,"It would be great if you 
could find a way to implement that conversion while remaining entirely in the C++ 
domain.  "
C++,"You know that the C++ libraries must contain the necessary code, because 
the >> operator has to perform that conversion when it reads an integer from a file.  
"
C++,"As 
you will learn in the following section, the C++ stream libraries provide precisely 
that capability, which will turn out to be useful in a wide variety of applications. 
 
"
C++,"C++ provides that capability through the <sstream> library, which exports several 
178     Streams 
classes that allow you to associate a stream with a string value in much the same 
way that the <fstream> library allows you to associate a stream with a file.  "
C++,"If you are declaring an object, C++ allows you to supply 
arguments after the variable name that control how that object is initialized.  "
C++,"Unfortunately, if you use the extraction 
operator in C++, that error will go undetected.  "
C++,"4.4 Class hierarchies 
When the designers of C++ undertook the task of modernizing the input/output 
libraries, they chose to adopt an object-oriented approach.  "
C++,"Although C++ 
tends to use inheritance somewhat less frequently than many object-oriented 
languages do, it is nonetheless one of the features that sets the object-oriented 
paradigm apart from earlier programming models. 
 
"
C++,"In C++, these classes form the hierarchy shown in 
Figure 4-6.  "
C++,"The C++ file and string stream classes then 
fall naturally into the appropriate position in this hierarchy, as shown. 
 
"
C++,"In C++, these characteristics correspond to the methods and other 
definitions associated with the class.  "
C++,"In any event, reading .h files is a programming skill that you will need to 
cultivate if you want to become proficient in C++. 
 
"
C++,• The <fstream> library in C++ supports reading and writing data files.  
C++,"The C++ stream libraries allow you to choose any of several different strategies 
when reading a file.  "
C++,"To make sure that these 
functions are easily available without having to copy the code, those functions 
are exported through several interfaces that constitute the Stanford C++ libraries. 
 
 "
C++,"Write a function 
 
void removeComments(istream & is, ostream & os); 
 
 
Exercises      193 
that copies characters from the input stream is to the output stream os, except 
for characters that appear inside C++ comments.  "
C++,"The real C++ compiler needs to check to make sure that these characters are 
not contained inside quoted strings, but you should feel free to ignore that 
detail.  "
C++,"The collection classes used in this book are inspired by and draw much of their 
structure from a more advanced set of classes available for C++ called the 
Standard Template Library, or STL for short.  "
C++,"Like most languages, C++ supports arrays, and you will have the 
chance to learn how C++ arrays work in Chapter 11.  "
C++,"Like most languages, C++ supports arrays, and you will have the 
chance to learn how C++ arrays work in Chapter 11.  "
C++,"Arrays in C++, however, have 
a number of weaknesses, including the following: 
 
• Arrays are allocated with a fixed size that you can’t subsequently change. 
"
C++,"• Even though arrays have a fixed size, C++ does not make that size available to 
the programmer.  "
C++,"• C++ makes no effort to ensure that the elements you select are actually present 
in the array.  "
C++,"For example, if you create an array with 25 elements and then try to 
select the value at index position 50, C++ will simply look at the memory 
addresses at which element 50 would appear if it existed. 
 
"
C++,"Specifying the base type of a Vector 
In C++, collection classes specify the type of object they contain by including the 
type name in angle brackets following the class name.  "
C++,"In C++, parameterized classes are more often 
called templates, which reflects the fact that C++ compilers treat Vector<int>, 
Vector<char>, and Vector<string> as independent classes that share a 
common structure.  "
C++,"In C++, parameterized classes are more often 
called templates, which reflects the fact that C++ compilers treat Vector<int>, 
Vector<char>, and Vector<string> as independent classes that share a 
common structure.  "
C++,"In C++, that is precisely what you do.  "
C++,"As 
with the characters in a string, C++ numbers the elements of a vector starting with 
0, which means that you could diagram the contents of vec like this: 
 
 
 
Unlike the more primitive array type that will be introduced in Chapter 11, the 
size of a vector is not fixed, which means that you can add additional elements at 
any time.  "
C++,"One of the characteristics of C++ that sets it apart from most other 
languages is that classes can override the definition of the standard operators.  "
C++,"Call-by-reference is more efficient than C++’s default model of call-by-value, 
which would require copying every element in the vector.  "
C++,"The ReverseFile program in Figure 5-1 shows a complete C++ program that 
uses Vector to display the lines from a file in reverse order.  "
C++,"When you declare a variable of a primitive type, as in 
 
double total; 
 
C++ does not make any attempt to initialize that variable.  "
C++,"For this reason, 
declarations of primitive variables usually include an explicit initializer that sets the 
variable to the desired starting value, as in 
 
double total = 0.0; 
 
The situation is different when you declare a variable to be an instance of a C++ 
class.  "
C++,"In that case, C++ automatically initializes that variable by invoking a special 
method called a constructor.  "
C++,"For example, in the declaration 
 
Vector<string> lines; 
 
C++ calls the Vector constructor, which initializes the variable lines to be an 
empty vector that belongs to the parameterized class Vector<string>.  "
C++,"The C++ compiler determines which version of the constructor to call by looking 
at the arguments appearing in the declaration, just as it does for overloaded 
functions.  "
C++,"For example, you can declare and 
initialize the vector v1 like this: 
 
Vector<char> v1; 
v1 += 'A', 'B', 'C'; 
 
If you are using C++11, which is the new C++ standard released in 2011, you can 
simplify this initialization, as follows: 
 
Vector<char> v1 = { 'A', 'B', 'C' }; 
 
Representing two-dimensional structures 
"
C++,"The type parameter used in the Vector class can be any C++ type and may itself be 
a parameterized type.  "
C++,"The type of the whole assemblage is 
therefore 
 
Vector< Vector<int> > 
 
210     Collections 
Although some C++ compilers have been extended so that the spaces are optional, 
this declaration adheres to the C++ standard by including spaces around the inner 
type parameter.  "
C++,"The type of the whole assemblage is 
therefore 
 
Vector< Vector<int> > 
 
210     Collections 
Although some C++ compilers have been extended so that the spaces are optional, 
this declaration adheres to the C++ standard by including spaces around the inner 
type parameter.  "
C++,"If you instead write this declaration as 
 
Vector<Vector<int>> sudoku(9, Vector<int>(9));   
 
 
many C++ compilers will interpret the >> as a single operator and be unable to 
compile this line. 
 
"
C++,"Thus, at each point in the operation, the calculator 
display and stack contain the values shown in Figure 5-3. 
 
214     Collections 
Implementing the RPN calculator in C++ requires making some changes in the 
user-interface design.  "
C++,"Its 
operation is analogous to assigning a value to a variable in C++: if there is a value 
already associated with the key, the old value is replaced by the new one.  "
C++,"Suppose that you have been asked to write a simple C++ program that reads a 
three-letter airport code from the user and responds with the location of that airport.  
"
C++,"232     Collections 
Using array syntax to perform map operations is becoming increasingly common 
in programming languages even beyond the C++ domain.  "
C++,"Unfortunately, understanding these standard iterators 
depends on a high level of familiarity with the low-level details of C++, most 
notably the concept of pointers.  "
C++,"Unfortunately, the syntax of C++ does not yet include such a facility, 
although one has been proposed for a future release.  "
C++,"The good news, however, is 
that it is possible to use the macro-definition capabilities of the C++ preprocessor to 
238     Collections 
achieve exactly what you would like to see in the language.  "
C++,"The range-based for loop is a new feature of C++11, which is the new C++ 
standard released in 2011.  "
C++,"Because this standard is so recent, the C++11 extensions 
have not yet been incorporated into all C++ programming, including several of the 
leading ones.  "
C++,"The Stanford 
C++ libraries include an interface called foreach.h that uses the C++ preprocessor 
to define a foreach macro with a very similar form: 
 
foreach (type variable in collection) { 
   body of the loop 
} 
 
The only differences are the name of the keyword and the use of the keyword in 
rather than a colon.  "
C++,"The Stanford 
C++ libraries include an interface called foreach.h that uses the C++ preprocessor 
to define a foreach macro with a very similar form: 
 
foreach (type variable in collection) { 
   body of the loop 
} 
 
The only differences are the name of the keyword and the use of the keyword in 
rather than a colon.  "
C++,"Thus, given the file Macbeth.txt, you would like 
your program to produce something like the following output: 
 
 
 
 Summary 
This chapter introduced the C++ classes Vector, Stack, Queue, Map, and Set that 
together represent a powerful framework for storing collections.  "
C++,"In C++, collection classes are defined using a template or 
parameterized type, in which the type name of the element appears in angle 
244     Collections 
brackets after the name of the collection class.  "
C++,"5. 
List at least three advantages of the Vector class over the more primitive 
array mechanism available in C++. 
 
6. 
"
C++,"In the game of Minesweeper, a player searches for hidden mines on a 
rectangular grid that might—for a very small board—look like this: 
 
 
 
One way to represent that grid in C++ is to use a grid of Boolean values 
marking mine locations, where true indicates the location of a mine.  "
C++,"C++ offers several 
strategies for defining a Point type, ranging in sophistication from the simple 
structure types that have always been available in the C family of languages to 
definitions that use a much more modern object-oriented style.  "
C++,"Such 
types are called records or structures, where the first term is used more broadly in 
the computer science community and the second is more common among C++ 
programmers.  "
C++,"Given that C++ supports the facilities available in C, you can define 
the Point type as a structure type using the following C-style structure definition: 
 
struct Point { 
   int x; 
   int y; 
}; 
 
This code defines the type Point as a traditional structure with two components.  "
C++,"When you work with structures or classes in C++, it is important to keep in mind 
that the definition introduces a new type and does not in itself declare any variables.  
"
C++,"264     Designing Classes 
C++ makes it easier to maintain a high-level perspective by defining several 
important operations that work with the structure as a whole.  "
C++,"Defining Point as a class 
Although structure types are part of the history of C++ and the languages that came 
before it, they have largely been supplanted by classes, which offer greater power 
and flexibility.  "
C++,"In C++ today, 
structures are implemented as classes and behave in exactly the same way except 
for the fact that entries are public by default. 
 
"
C++,"The Point class is immutable, as that concept tends to be defined in 
practice in C++.  "
C++,"In C++, when you separate the interface for a class from its implementation, the 
class definition itself exists only in the .h file.  "
C++,"In C++, this 
identification is accomplished by adding the class name as a qualifier before the 
method name, separating the two with a double colon.  "
C++,"6.2 Operator overloading 
As you know from your experience with the library classes in several of the earlier 
chapters, C++ makes it possible to extend the standard operators so that they apply 
to new types.  "
C++,"When the C++ compiler sees the + operator, it decides how to evaluate it by 
looking at the types of the operand, just as it uses the argument signature to choose 
among various overloaded versions of a function.  "
C++,"The ability to overload operators is a powerful feature of C++ that can make 
programs much easier to read, but only if the interpretation of each operator remains 
consistent across the types to which it is applied.  "
C++,"C++ already overloads the stream insertion operator << so that it can display strings 
along with the primitive types.  "
C++,"Each of the operators in C++ is associated with a function name used to define 
its overloaded behavior.  "
C++,"C++ offers two strategies for overloading a built-in operator so that it works with 
objects of a newly defined class: 
 
1. 
"
C++,"These references are legal in C++ 
because the definitions in the private section of a class are private to the class and 
not to the object.  "
C++,"What saves the day is that C++ 
makes it possible to solve the access problem in another way.  "
C++,"6.2 Operator overloading      275 
To make this design work, the Point class must let the C++ compiler know that 
it is okay for a particular function—in this case the overloaded version of the == 
operator—to see its private instance variables.  "
C++,"In C++, the syntax for declaring a free function as a friend is 
 
friend prototype; 
 
where prototype is the complete function prototype.  "
C++,"In C++, a class can declare that everything in some other class should gain the 
benefits of friendship by including the line 
 
friend class name; 
 
where name is the name of the class.  "
C++,"In C++, such declarations of friendship are 
not automatically reciprocal.  "
C++,C++ does not assume that == and !
C++,"Although operator overloading is most commonly associated with classes, C++ also 
allows you to extend the definition of operators so that they work with enumerated 
types.  "
C++,"The ++ and -- operators are special in C++ because they occur in two 
forms.  "
C++,"When they are written in the suffix position, as in the expression x++, 
the value of the variable changes in exactly the same way, but the value of the 
expression is the value of the variable before the operation takes place. 
 
280     Designing Classes 
When you overload the ++ or -- operators in C++, you have to tell the compiler 
whether you want to redefine the prefix or suffix form of the operator.  "
C++,"The 
designers of C++ chose to indicate the suffix form by passing an integer argument 
that has no purpose other than to differentiate it from its prefix counterpart.  "
C++,"This example also illustrates the fact that C++ doesn’t require a 
parameter name if you aren’t going to use that value. 
 
"
C++,"The 
problem is that C++ does not include rational numbers among its predefined types.  
"
C++,"To use rational numbers in C++, you have to define a new class to represent them. 
 
"
C++,"The primary purpose of the example, moreover, 
284     Designing Classes 
is to illustrate the structure of class definitions in C++.  "
C++,"The code for the default constructor therefore looks like this: 
 
Rational() { 
   num = 0; 
   den = 1; 
} 
 
Finally, it turns out to be useful to define a third version of the constructor that 
takes a single argument representing an integer: 
 
Rational(int n) { 
   num = n; 
   den = 1; 
} 
 
Defining methods for the Rational class 
In light of the earlier decision to limit the functionality of the Rational class to the 
arithmetic operators, figuring out what methods to export is a relatively easy task, 
particularly in C++.  "
C++,The situation is much better in C++.  
C++,"In C++, you implement rational arithmetic 
by overloading the operators +, -, *, and / to work with Rational objects.  "
C++,"If you are using a class only as a client, it makes sense to ignore the 
contents of the private section of a class, even though C++ requires that the private 
section be included in the interface. 
"
C++,"Your 
C++ compiler, for example, uses a token scanner to break programs into tokens that 
make sense in the programming context, including identifiers, constants, operators, 
and other symbols that define the syntactic structure of the language.  "
C++,"If 
you instead want the TokenScanner to identify the units in a C++ program, you 
enable options that tell the scanner, for example, to ignore whitespace, to treat 
quoted strings as single units, and that certain combinations of punctuation marks 
represent multicharacter operators. 
 
"
C++,"The tokenscanner.h interface 
The Stanford C++ library includes a TokenScanner class that offers considerable 
flexibility without sacrificing simplicity.  "
C++,"For example, you can 
ignore all whitespace in the input stream by initializing a token scanner like this: 
 
TokenScanner scanner; 
scanner.ignoreWhitespace(); 
 
If you instead want to initialize a TokenScanner so that it adheres to the rules for 
tokens in C++, you could use the code 
 
TokenScanner scanner; 
scanCPlusPlusTokens(scanner); 
 
where the scanCPlusPlusToken method is defined as shown in Figure 6-9 on 
page 296. 
 
"
C++,"The implementation of scanCPlusPlusTokens in Figure 6-9 tells the scanner to 
ignore whitespace and comments, that numbers and strings should be scanned as 
single tokens, that the underscore is a legal character in an identifier, and that C++ 
recognizes the multicharacter operators (many of which are likely to be unfamiliar 
but are nonetheless defined in C++) shown in the various calls to addOperator. 
 
"
C++,"The implementation of scanCPlusPlusTokens in Figure 6-9 tells the scanner to 
ignore whitespace and comments, that numbers and strings should be scanned as 
single tokens, that the underscore is a legal character in an identifier, and that C++ 
recognizes the multicharacter operators (many of which are likely to be unfamiliar 
but are nonetheless defined in C++) shown in the various calls to addOperator. 
 
"
C++,"Once you have defined the 
Rational class, for example, you can then use Rational objects in much the 
same ways that you use the primitive types in C++.  "
C++,"C++ offers several strategies for encapsulating data 
in this way.  "
C++,"At the lowest level, C++ continues to support the definition of 
C-style structure types.  "
C++,"In C++, a class is divided into sections that control the access clients have to the 
fields and methods in that section.  "
C++,"In C++, the implementation file must specify the class to which each 
method belongs by adding a :: tag before the method name. 
"
C++,"2. 
In a C++ class definition, what do the keywords public and private mean? 
 
"
C++,"3. 
True or false: In C++, the only difference between the keyword struct and 
the keyword class is that struct makes fields public by default. 
 
"
C++,"What operator does C++ use to select an instance variable from an object? 
 
"
C++,"What is the syntax for a C++ constructor? 
 
6. 
"
C++,"In C++, what method name would you use to overload the % operator. 
 
"
C++,"How does C++ differentiate between the prefix and suffix versions of the ++ 
and -- operators? 
 
"
C++,"True or false: Return by reference is used as frequently in C++ programs as 
call by reference. 
 
"
C++,"Implement the scanNumbers method for the TokenScanner class, which 
causes the token scanner to read any valid C++ number as a single token.  "
C++,"7.2 The factorial function 
Although the collectContributions example illustrates the idea of recursion, it 
gives little insight into how recursion is used in practice, mostly because the steps 
that make up the solution, such as finding 10 volunteers and collecting money, are 
not easily represented in a C++ program.  "
C++,"In C++, the equivalent problem is to 
write an implementation of a function with the prototype 
 
 
7.2 The factorial function      319 
int fact(int n); 
 
that takes an integer n and returns its factorial. 
 
"
C++,"In C++, you can implement a function fact that computes the 
factorial of its argument as follows: 
 
int fact(int n) { 
   if (n == 0) { 
      return 1; 
   } else { 
      return n * fact(n - 1); 
   } 
} 
 
If n is 0, the result of fact is 1.  "
C++,"Such a 
function requires three arguments and might be expressed in C++ as a function with 
the following prototype: 
 
int additiveSequence(int n, int t0, int t1); 
 
If you had such a function, it would be easy to implement fib using it.  "
C++,"In the C++ implementation, the values of these terms 
are passed as arguments.  "
C++,"Even though these rules seem simplistic, they form the basis of an effective strategy 
for distinguishing odd and even numbers, as long as those numbers are nonnegative.  
338     Introduction to Recursion 
The code in Figure 7-6 ensures that condition by having isEven and isOdd take 
arguments of type unsigned, which C++ uses to represent an integer that can never 
be less than zero. 
 
 "
C++,"In C++, recursive functions typically have the following paradigmatic form: 
 
if (test for simple case) { 
   Compute a simple solution without using recursion. 
"
C++,"2. 
Unlike many programming languages, C++ does not include a predefined 
operator that raises a number to a power.  "
C++,"If the target 
value had been 5, however, the answer would be no, because there is no way to 
choose a subset of the integers in { –2, 1, 3, 8 } that adds up to 5. 
 
362     Recursive Strategies 
It is easy to translate the idea of the subset-sum problem into C++.  "
C++,"When you are looking for a recursive decomposition, you need to be on the 
lookout for some value in the inputs—which are conveyed as arguments in the C++ 
formulation of the problem—that you can make smaller.  "
C++,"10. Write a simple C++ expression based on the value of nCoins that has the 
value true if the position is good for the current player and false otherwise. 
 
"
C++,"When you write programs in an object-oriented language like C++, you 
should take as much advantage as you can of the abstract types provided by the 
libraries and stay as far away as possible from the complexity of the low-level 
details.  "
C++,"At the same time, it is useful to know a bit more about how C++ represents 
data.  "
C++,"Having that knowledge gives you a better sense of how those abstract types 
work and helps you understand why C++ behaves as it does. 
 
"
C++,"At this point in the text, there is another compelling reason to learn how memory 
works in C++.  "
C++,"In Chapter 5, you learned about the wonderful collection classes in 
C++ that make programming so much easier.  "
C++,"Without a detailed understanding of the 
low-level structures that C++ uses to implement those algorithms—most notably 
pointers and arrays—those costs are impossible to evaluate. 
 
 "
C++,"The structure of memory 
Before you can understand C++’s memory model in any detail, you need to know 
how information is stored inside a computer.  "
C++,"For historical 
478     Pointers and Arrays 
reasons dating back to its predecessor languages, C++ defines the data type char to 
be exactly one byte in size.  "
C++,"This design decision makes it more difficult for C++ 
programs to work with expanded character sets needed to encode languages that 
don’t fit easily into the ASCII model.  "
C++,"The C++ standard libraries define a type 
called wchar_t to represent “wide characters” that extend outside the ASCII range.  
"
C++,"For example, the two’s complement representation of –1 in a 
32-bit word is calculated by performing the following binary subtraction: 
 
1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
– 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 
 
Floating-point numbers are also represented as fixed-length bit sequences in 
C++.  "
C++,"In C++, different data types require different amounts of memory.  "
C++,"For the 
primitive types, the following values are typical, although the C++ standard gives 
compiler-writers some flexibility to choose different sizes that are more convenient 
for a particular type of hardware: 
 
char 
1 byte (by definition) 
bool 
1 byte 
short 
2 bytes 
int 
4 bytes 
float 
4 bytes 
long 
8 bytes 
double 
8 bytes 
long double 16 bytes 
 
In C++, the size of an object is usually just the sum of the sizes of the instance 
variables it contains.    "
C++,"For the 
primitive types, the following values are typical, although the C++ standard gives 
compiler-writers some flexibility to choose different sizes that are more convenient 
for a particular type of hardware: 
 
char 
1 byte (by definition) 
bool 
1 byte 
short 
2 bytes 
int 
4 bytes 
float 
4 bytes 
long 
8 bytes 
double 
8 bytes 
long double 16 bytes 
 
In C++, the size of an object is usually just the sum of the sizes of the instance 
variables it contains.    "
C++,"In a C++ program, you can determine how much memory will be assigned to a 
variable using the sizeof operator.  "
C++,"Although it is possible to work with decimal addresses, this book uses 
hexadecimal notation for the following reasons: 
 
• Address numbers are conventionally written in hexadecimal, and C++ debuggers 
and runtime environments tend to display addresses in this form. 
"
C++,"The structure of memory     481 
The right side of Figure 11-1 provides a rough sketch as to how memory is 
organized in a typical C++ program.  "
C++,"Assigning memory to variables 
When you declare a variable in a C++ program, the compiler must make sure that 
the variable is assigned enough memory to hold a value of that type.  "
C++,"11.2 Pointers 
One of the principles behind the design of C++ is that programmers should have as 
much access as possible to the facilities provided by the underlying hardware.  "
C++,"For 
this reason, C++ makes the fact that memory locations have addresses visible to the 
programmer.  "
C++,"In C++, pointers are pervasive, and it is impossible to 
understand most professional C++ programs without knowing how pointers work. 
 
"
C++,"In C++, pointers are pervasive, and it is impossible to 
understand most professional C++ programs without knowing how pointers work. 
 
"
C++,"In C++, pointers serve several purposes, of which the following are the most 
important: 
 
• Pointers allow you to refer to a large data structure in a compact way.  "
C++,"11.2 Pointers     485 
Using addresses as data values 
In C++, any expression that refers to an internal memory location capable of storing 
data is called an lvalue (pronounced “ell-value”).  "
C++,"The l at the beginning of lvalue 
comes from the observation that lvalues can appear on the left side of an assignment 
statement in C++.  "
C++,"For example, simple variables are lvalues because you can write 
a statement like 
 
x = 1.0; 
 
Many values in C++, however, are not lvalues.  "
C++,"The following properties apply to lvalues in C++: 
 
•"
C++,"Declaring pointer variables 
As with all other variables in C++, you must declare pointer variables before you 
use them.  "
C++,"These two types—pointer-to-int and 
pointer-to-char—are distinct in C++, even though each of them is represented 
internally as an address.  "
C++,"The fundamental pointer operations 
C++ defines two operators that allow you to move back and forth between a pointer 
and its target value: 
 
& 
Address-of  
* 
Value-pointed-to  
 
The & operator takes an lvalue as its operand and returns the memory address in 
which that lvalue is stored.  "
C++,"In C++, the operator that produces 
addresses is the & operator.  "
C++,"In C++, it is much more common to use pointers in conjunction with structures or 
objects.  "
C++,"In C++, the dot operator has higher precedence than 
the star operator, which means that the compiler tries to interpret this expression as 
 
*(pp.getX()) 
 
which is meaningless.  "
C++,"To eliminate some of this inconvenience, C++ defines the operator -> (usually read 
aloud as arrow), which combines the operations of dereference and selection into a 
single operator.  "
C++,"When you are writing the implementation of a class, C++ defines the keyword this 
as a pointer to the current object.  "
C++,"This text follows the common 
C++ convention of using this only when doing so helps to resolve an ambiguity. 
 
"
C++,"In C++, the best way to indicate the null pointer is to use 
the constant NULL, which is defined in the <cstddef> interface.  
 
"
C++,"Pointers and call by reference 
As an illustration of their use in practice, pointers are used internally by C++ to 
implement call by reference.  "
C++,"The program in Figure 11-3 offers a simple illustration of how C++ implements 
call by reference.  "
C++,"Although call by reference is extremely convenient, it is not an essential feature 
of the C++ language.  "
C++,"C++ offers a built-in 
array type, which is based on the language model that C++ inherits from C.  Given 
that the Vector collection class is uniformly more flexible and convenient, there 
are few reasons to use arrays in new code, although you will certainly encounter 
arrays in existing applications. 
 
"
C++,"C++ offers a built-in 
array type, which is based on the language model that C++ inherits from C.  Given 
that the Vector collection class is uniformly more flexible and convenient, there 
are few reasons to use arrays in new code, although you will certainly encounter 
arrays in existing applications. 
 
"
C++,"In C++, an array is a low-level collection of individual data values with two 
distinguishing characteristics: 
 
1. 
"
C++,"• Even though arrays have a fixed size, C++ does not make that size available to 
the programmer.  "
C++,"• C++ performs no bounds-checking to ensure that the elements you select are 
actually present in the array. 
 
"
C++,"Array declaration 
Like any other variable in C++, an array must be declared before it is used.  "
C++,"The 
process of identifying a particular element within an array is called selection, and is 
indicated in C++ by writing the name of the array and following it with the index 
written in square brackets, just as if you are selecting an element from a vector. 
 
"
C++,"i; 
} 
 
the variable intArray will be initialized as follows: 
 
 
 
When you select an element from an array, C++ performs no bounds checking.  
"
C++,"If the index is out of range, C++ simply figures out where that element would be in 
memory and uses that value, leading to unpredictable results.  "
C++,"Fortunately, C++ offers a standard idiom for determining the allocated size of an 
array that uses static initialization to set the number of elements.  "
C++,"The relationship between pointers and arrays 
In C++, the name of an array is synonymous with a pointer to its initial element.  
"
C++,"One of the most important implications of the way that C++ treats arrays as 
pointers is that array parameters appear to be shared with the calling argument even 
though no explicit call by reference is involved.  "
C++,"The crucial difference between arrays and pointers in C++ comes into play when 
variables are originally declared, not when those values are passed as parameters.  
"
C++,"In C++, you can apply the operators + and - to pointers.  "
C++,"The C++ compiler interprets subtraction of an integer from a pointer in a similar 
way.  "
C++,"11.4 Pointer arithmetic     503 
Incrementing and decrementing pointers 
Knowing the rules for pointer arithmetic makes it possible to understand one of the 
most common idiomatic constructions in C++, which is the expression 
 
*p++ 
 
In this expression, the * operator and the ++ operator compete for the operand p.  
"
C++,"Because unary operators in C++ are evaluated in right-to-left order, the ++ takes 
precedence over the *, so the compiler interprets this expression as if it had been 
written like this: 
 
"
C++,"As you know from Chapter 3, C++ uses two different string types.  "
C++,"For historical reasons, however, C++ supports a more primitive string model that it 
inherits from the earlier language C.  "
C++,"If, for example, you use the string constant ""hello, world"" in a C++ 
program, the compiler generates an array of characters in memory containing the 
characters in the string plus an extra null character at the end, as follows: 
 
 
 
504     Pointers and Arrays 
"
C++,"In the standard C libraries (which 
remain available in C++), this operation is accomplished by the strlen function, 
which can be implemented in many different ways.  "
C++,"In both C and C++, an integral value is taken to be true if it has a 
nonzero value.  "
C++,"The 
strcpy function, which C++ inherits from the older C language, is dangerous to 
use because it makes no attempt to check whether the destination has enough room 
to hold a copy of the source string.  "
C++,"506     Pointers and Arrays 
Pointer arithmetic and programming style 
For reasons of history and habit, many C++ programmers use pointer arithmetic in 
places where array notation makes the intent much clearer.  "
C++,"In that context, it is useful to 
remember that *p++ is a C++ shorthand for retrieving the current element of an 
array and then advancing to the next one. 
 
 "
C++,"At the same time, using C++ effectively requires 
you to have a mental model of how data structures are represented in memory.  "
C++,The primitive types in C++ require different amounts of memory.  
C++,"Pointer variables are declared in C++ by writing an 
asterisk in front of the variable name in its declaration line. 
"
C++,"• Data values that you create in a C++ program are allocated in different regions 
of memory.  "
C++,"• C++ uses the -> operator to select a member of a structure or an object given a 
pointer to that value. 
"
C++,"• Reference parameters are implemented in C++ by storing a pointer to the calling 
argument in the stack frame. 
"
C++,"• Like most languages, C++ includes a built-in array type for storing an ordered, 
homogeneous collection of elements.  "
C++,Arrays in C++ are interpreted internally as a pointer to their first element.  
C++,"C++ defines arithmetic on pointers so that adding an integer to a pointer 
generates the address of an array element that number of index positions further 
down in the array.  "
C++,"508     The C++ Memory Model 
 Review questions 
1. 
"
C++,How many bytes does C++ assign to a value of type char?  
C++,"7. 
True or false: In C++, values of type char always require one byte of memory."
C++,"True or false: In C++, values of type int always require four bytes of memory."
C++,"What are the three areas of memory in which values can be stored in a C++ 
program? 
 
11."
C++,"Assuming that intArray is declared as 
 
int intArray[10]; 
 
510     The C++ Memory Model 
and that j is an integer variable, describe the steps the computer would take to 
determine the value of the following expression: 
 
&intArray[j + 3]; 
 
26."
C++,"Describe the effect of the idiomatic C++ expression 
 
*p++ 
 
30."
C++,"If instead of using binary representation in the traditional 
way, you can assign three-bit values to each of the numbers 0 through 7 with 
the highly useful property that only one bit changes in the representation 
512     The C++ Memory Model 
between every pair of adjacent integers.  "
C++,"A sample 
run of this program might look like this: 
 
 
 
514     The C++ Memory Model 
"
C++,"Even though it is illegal to copy stream objects in C++, you can store a pointer 
to a stream in a data structure.  "
C++,"Dynamic allocation is one of the most important techniques that you need to 
learn before you can consider yourself fluent in C++.  "
C++,"In C++, dynamic allocation takes on special importance because the language 
assigns much more responsibility to the programmer than most modern languages 
do.  "
C++,"In C++, it is not enough to know how to allocate memory.  "
C++,"Like most programming languages, C++ allows you to allocate 
some of the unused storage to the program whenever your application needs more 
memory.  "
C++,"The new operator 
C++ uses the new operator to allocate memory from the heap.  "
C++,"If you 
supply only the class name, as in 
 
Rational *rp = new Rational; 
 
C++ allocates space for a Rational object on the heap and invokes the default 
constructor, creating the following state in memory: 
 
 
 
If you supply arguments after the type name, C++ will call the matching version of 
the constructor.  "
C++,"If you 
supply only the class name, as in 
 
Rational *rp = new Rational; 
 
C++ allocates space for a Rational object on the heap and invokes the default 
constructor, creating the following state in memory: 
 
 
 
If you supply arguments after the type name, C++ will call the matching version of 
the constructor.  "
C++,"The Beacons of Gondor 
Before looking at the details of how linked lists are represented in C++, it makes 
sense to describe my favorite example of a linked list, which takes its inspiration 
from the following passage in The Return of the King by J. R. R. Tolkien: 
 
"
C++,"The 
message of Gondor’s danger thus passes quickly over the many leagues that 
separate it from Rohan, as illustrated in Figure 12-1. 
 
520     Dynamic Memory Management 
To simulate the Beacons of Gondor in C++, you need to define a structure type 
to represent each of the towers in the chain.  "
C++,"The simple case is that of the empty list, which is 
represented in C++ using the pointer value NULL.  "
C++,"To make this strategy possible, C++ 
includes the operator delete, which takes a pointer previously allocated by new 
and frees the memory associated with that pointer. 
 
"
C++,"C++, however, dates from an earlier 
era.  "
C++,"For better or worse, the designers of C++ decided to leave the responsibility for 
freeing heap memory in the hands of the programmers instead of delegating that 
task to an automatic process. 
 
"
C++,"In C++, each class is allowed to specify what happens 
when an object of that class disappears.  "
C++,"In well-designed C++ applications, each 
class takes responsibility for its own heap storage, thereby freeing clients from the 
nearly impossible task of remembering exactly what heap storage is currently 
active.  "
C++,"Learning to use this strategy effectively is one of the most important 
techniques you need to master as a C++ programmer, so it is worth paying 
particular attention to the following section, which describes this approach in detail. 
 
"
C++,"526     Dynamic Memory Management 
Destructors 
As you know from the examples you have already seen, C++ classes typically 
define one or more constructors that initialize an object.  "
C++,"In C++, the destructor has the same name as the class preceded by the tilde 
character ~.  "
C++,"In C++, objects disappear in several different ways.  "
C++,"In most C++ documentation, local variables that disappear when a 
function returns are said to go out of scope. 
 
"
C++,"Unfortunately, the syntactic rules of 
C++ require that the private section be defined within the body of the class.  "
C++,"The use of destructors in C++ is not a magical solution to the problem of 
memory allocation.  "
C++,"As with any C++ program, the first thing that happens is that the operating 
system issues a call to the main function.  "
C++,"Arguments in 
C++ are passed by value unless the declaration of the parameter variable includes an & to indicate call by 
reference.  "
C++,"Moreover, because C++ 
treats array names as being synonymous with a pointer to their initial element, assigning an array name to a 
variable copies only the pointer and not the underlying elements.  "
C++,"The only time that a C++ program creates 
new memory in the heap is when the new operator appears explicitly in an expression.  "
C++,"12.5 Heap-stack diagrams     539 
 
 
Declaring an object in C++ automatically invokes its constructor, so the first 
thing that happens is a call to the CharStack constructor.  "
C++,"In C++, the type 
char takes up one byte, so the array requires 10 bytes of heap memory, although 
that number is typically rounded up so that it fills an integral number of words.  "
C++,"The call to assert (which is 
implemented using the C++ macro facility that is beyond the scope of this text) has 
the following form: 
 
assert(test); 
 
As long as the test expression evaluates to true, the assert macro has no effect.  
"
C++,"Shallow versus deep copying 
The crux of the problem in the current implementation of the CharStack class is 
that C++ interprets assignment of one object to another in a way that often makes 
sense, but which fails miserably if that object contains any dynamically allocated 
memory.  "
C++,"By default, C++ assigns one object to another by copying the value of 
each of its instance variables.  "
C++,"C++’s default behavior is called shallow copying because it 
doesn’t extend beneath the surface.  "
C++,That is exactly what would happen if C++ used deep copying to initialize s2.  
C++,"If you 
allow C++ to use its default technique of shallow copying, however, executing these 
statements will almost certainly cause problems at some point in the program. 
 
"
C++,"Freeing the 
same memory twice is illegal, but there is no guarantee that C++ will detect and 
report the error.  "
C++,"The challenge is getting C++ 
to invoke that code when you assign one CharStack to another.  "
C++,"In C++, you can change the default shallow-copying behavior by redefining two 
methods.  "
C++,"In C++, the assignment operator is called only 
when you assign a value to an object that already exists.  "
C++,"Whenever an object is 
being initialized for the first time—including when a declaration includes an 
initializer—C++ invokes the copy constructor. 
 
"
C++,"In C++, the definitions required to override the copy constructor and the 
assignment operator are full of details that are easy to get wrong if you try to write 
these definitions from scratch.  "
C++,"In C++, the 
assignment operator is defined so that it returns the value on its left hand side.  "
C++,These definitions override the defaults that C++ provides.  
C++,"The standard C++ libraries, for example, use 
this approach to make it illegal to copy streams. 
 
"
C++,"Professional C++ programmers, however, use const in 
several other contexts as well.  "
C++,"If you intend to become a serious C++ programmer, you 
 
12.8 The uses of const     551 
have to master the many subtleties of the const keyword.  "
C++,"That 
simplification, however, is no longer possible because C++ requires the use of 
constant call by reference for the overloaded copy constructor and assignment 
operator, as illustrated in section 12.6.  "
C++,"The C++ interpretation, however, is slightly 
different.  "
C++,"The only problem with using constant call by reference as a general replacement 
for call by value is that adding the const keyword to a parameter forces the C++ 
compiler to ensure that the value is not modified by the function that receives that 
argument.  "
C++,"In C++, the responsibility for providing that 
information rests squarely on the programmer.  "
C++,"C++ allows the programmer to specify that a method does not change the state of 
the associated object by adding the keyword const after the parameter list.  "
C++,"At the same time, using C++ effectively requires 
that you have a mental model of how data structures are represented in memory.  "
C++,"C++ allocates memory from the heap using the new operator, which takes a type 
name and returns a pointer to a block of memory large enough to hold a value of 
that type. 
"
C++,"cp = new char[10]; 
 
• Unlike many modern languages, C++ makes the programmer responsible for 
memory management.  "
C++,"At the lowest level, C++ 
uses the delete operator to free individual heap values and the delete[] 
operator to free dynamically allocated arrays. 
 
"
C++,"The task of memory management in C++ is simplified considerably by the 
existence of destructors, which are called automatically when the stack frame 
containing that object disappears at the end of a method call.  "
C++,"• Heap-stack diagrams are useful in understanding how C++ allocates memory.  
"
C++,"• When you assign one object to another or pass an object by value, the default 
rule in C++ is to make a shallow copy in which the instance variables are copied 
but not any structures to which those instance variables point.  "
C++,"• You can change the way that C++ copies objects of a specific class by overriding 
the assignment operator and the copy constructor.  "
C++,The const keyword has many different applications in C++ programs.  
C++,"A dynamic array called names capable of holding 100 C++ strings? 
 
"
C++,True or false: C++ uses garbage collection to manage memory.
C++,"Which of 
these two strategies does C++ use by default? 
 
"
C++,"What methods must you override to change how C++ copies an object? 
 
"
C++,"In this exercise, your mission is to define a class called 
MyString that approximates the behavior of the string class from the 
Standard C++ libraries.  "
C++,"A constructor MyString(str) that creates a MyString object from a 
C++ string. 
"
C++,"• A toString() method that converts a MyString to a C++ string. 
"
C++,"As an improvement over the string class in the C++ libraries, your 
implementation of the bracket operator should call error if the index is 
outside the bounds of the string. 
"
C++,"Your code should work directly with your underlying representation and 
should make no calls to any of the methods in the C++ string class.  "
C++,"Your 
interface and implementation should also be const correct so that both clients 
and the C++ compiler know exactly what methods can change the value of the 
string. 
 
"
C++,"When 
you enter information on a web-based form or compose a C++ program in your 
development environment, you are using an editor.  "
C++,"In an object-oriented language like C++, it makes sense to define a class to 
represent an editor buffer.  "
C++,"To make these operations possible, the EditorBuffer class 
exports the methods 
 
string toString() const; 
 
which returns the contents of the entire buffer as a C++ string, and 
 
int getCursor() const; 
 
which returns the position of the cursor as an integer between 0 and the length of the 
buffer.  "
C++,"A list-based implementation     597 
The final step consists of changing the cursor field in the buffer structure so 
that it also points to the new cell, which results in the following configuration: 
 
 
 
When the program returns from the insertCharacter method, the temporary 
variable cp is released, which results in the following final buffer state: 
 
 
 
which represents the buffer contents 
 
 
 
The following implementation of the insertCharacter method is a simple 
translation into C++ code of the informal steps illustrated in the last several 
diagrams: 
 
void EditorBuffer::insertCharacter(char ch) { 
   Cell *cp = new Cell; 
   "
C++,"What is the standard idiomatic pattern used in C++ to traverse a linked list? 
 
17."
C++,"C++ uses an approach called templates, in which the programmer 
defines a common code pattern that can then be used for many different types.  "
C++,"The 
collection classes from Chapter 5 depend on the C++ template facility, which means 
that you need to understand how templates work before you can appreciate the 
underlying implementation of the collection classes. 
 
"
C++,"In C++, you can combine 
the earlier definitions of the max function into a single template definition, as 
follows: 
 
template <typename ValueType> 
ValueType max(ValueType x, ValueType y) { 
   return (x > y) ?"
C++,"The typename keyword tells the C++ compiler that this 
placeholder represents the name of a type, which enables the compiler to interpret 
that identifier correctly. 
 
"
C++,"The problem here is that 
the literals ""cat"" and ""dog"" are C strings rather than C++ strings, which means 
that they are pointers to characters.  "
C++,"The C++ compiler therefore generates the 
more-or-less useless function 
 
char *max(char *x, char *y) { 
   return (x > y) ?"
C++,"To use the string 
comparison operators defined for C++ strings, you would need to write this call as 
 
max(string(""cat""), string(""dog"")) 
 
which correctly returns the C++ string ""dog"". 
 
"
C++,"To use the string 
comparison operators defined for C++ strings, you would need to write this call as 
 
max(string(""cat""), string(""dog"")) 
 
which correctly returns the C++ string ""dog"". 
 
"
C++,"In 
C++, you are not defining a single function that works with more than one type, but 
are instead providing a pattern from which the compiler can generate specially 
tailored versions whenever it needs them. 
 
"
C++,"In C++, the compiler must 
 
14.2"
C++,"To gain the 
flexibility of the library version of the Stack class, it is necessary to reimplement 
Stack as a template class, which is a class that uses the C++ template facility so 
that is works with any data type. 
 
"
syntax,"The syntax of variable declarations is 
discussed in more detail in the section on “Variables” later in this chapter.  "
syntax,"The usual syntax for declaring a variable is 
 
type namelist; 
 
where type indicates the data type and namelist is a list of variable names separated 
by commas.  "
syntax,"The syntax for defining an enumerated type is 
 
enum typename { namelist }; 
 
where typename is the name of the new type and namelist is a list of the constants in 
the domain, separated by commas.  "
syntax,"The code pattern I’ve used to illustrate the syntax of the switch statement 
deliberately suggests that break statements are required at the end of each clause.  
"
syntax,"For example, building on the examples of functions you saw in 
Chapter 1, you know that you can implement the function ƒ in C++ like this: 
 
double f(double x) { 
   return x * x + 1; 
} 
 
This definition includes various bits of syntax that are absent from the mathematical 
formulation, but the basic idea is the same.  "
syntax,"One of the major differences is in the syntax used to 
invoke function calls.  "
syntax,"In C++, 
sending a message is specified using the following syntax: 
 
receiver.name(arguments) 
 
"
syntax,"The object-oriented version of the statement that sets nChars to the length of the 
string object str is therefore 
 
int nChars = str.length(); 
 
Table 3-1 lists the most common methods exported by the <string> library, all of 
which use the receiver syntax. 
 
"
syntax,"Although C++ programmers 
tend to use the square-bracket syntax for its expressiveness, it is arguably better to 
call the at method instead.  "
syntax,"No matter which syntax you use, selecting an individual character in a string 
returns a direct reference to the character in the string, which allows you to assign a 
new value to that character.  "
syntax,"Assuming that you understand the syntax and semantics of the for statement, 
you could work out the patterns for each iteration direction from first principles 
each time this pattern comes up in an application.  "
syntax,"Because string is a class, the methods use the receiver syntax 
instead of the traditional functional form.  "
syntax,"This 
feature makes it possible for the Vector class to support the more traditional syntax 
of using square brackets to specify the desired index.  "
syntax,"For example, you can set element 3 in vec to 70 by writing 
 
vec[3] = 70; 
 
The resulting syntax is marginally shorter than calling set, but is more evocative of 
the array operations that the Vector class is designed to emulate. 
 
"
syntax,"You have already seen the use of 
square brackets, which make it possible to select objects from a vector using the 
traditional selection syntax for arrays.  "
syntax,"Conversely, you can think of a map as an array that uses the key type as its indices, 
which is precisely what the overloaded selection syntax for the Map class suggests. 
 
"
syntax,"232     Collections 
Using array syntax to perform map operations is becoming increasingly common 
in programming languages even beyond the C++ domain.  "
syntax,"Unfortunately, the syntax of C++ does not yet include such a facility, 
although one has been proposed for a future release.  "
syntax,"int x; 
   int y; 
}; 
 
As you can see from this example, the fields of a class—which are also called 
instance variables when they occur in the context of a class—are declared using the 
same syntax used for fields in a structure.  "
syntax,"For those applications where it comes up, it is enough to know 
that you can specify return by reference using pretty much the same syntax you use 
to indicate call by reference: you simply add an ampersand after the result type. 
 
  "
syntax,"In C++, the syntax for declaring a free function as a friend is 
 
friend prototype; 
 
where prototype is the complete function prototype.  "
syntax,"What’s worse is that you have to use the receiver syntax to apply those 
operators.  "
syntax,"What is the syntax for a C++ constructor? 
 
6. 
"
syntax,"There are a few small differences in syntax, but those are easily 
mastered.  "
syntax,"Although the syntax for specifying constant call by reference seems simple 
enough in the examples you have already seen, it does get tricky if you try to apply 
it to a pointer-valued parameter.  "
variables,"The syntax of variable declarations is 
discussed in more detail in the section on “Variables” later in this chapter.  "
variables,"The last statement in raiseToPower is 
 
return result; 
 
which indicates that the function should return result as the value of the function. 
 
 1.4 Variables 
Data values in a program are usually stored in variables, which are named locations 
in memory capable of holding a particular data type.  "
variables,"For example, executing the assignment statements 
 
x = 42; 
y = 163; 
 
 
11.2 Pointers     487 
results in the following memory state: 
 
 
 
To initialize the pointer variables p1 and p2, you need to assign values that 
represent the addresses of some integer objects.  "
functions,"A parameter is a placeholder for one of the 
62     Functions and Libraries 
arguments supplied in the function call and acts in most respects like a local 
variable.  "
functions,"76     Functions and Libraries 
page 1 of figure. 
 
"
functions,"% 4); 
} 
 
 
2.6 Interfaces and implementations     81 
direction.h 
82     Functions and Libraries 
The arithmetic operators in the expression 
 
(dir + 1) % 4 
 
automatically convert the Direction value to its underlying representation as an 
 
2.6 Interfaces and implementations     83 
integer: 0 for NORTH, 1 for EAST, 2 for SOUTH, and 3 for WEST.  "
functions,"Thus, 
90     Functions and Libraries 
interface changes should be undertaken very rarely and then only with the active 
participation of clients. 
 
"
functions,"RAND_MAX;
 
 
 
100     Functions and Libraries 
"
functions,"The output of the 
program appears in Figure 2-16 at the top of page 111. 
110     Functions and Libraries 
GraphicsExample.cpp 
 
2.9 Introduction to the Stanford libraries     111 
"
functions,"Having the location of the origin in the upper left corner, however, means 
that the y value increases as you move downward, which is precisely opposite to the 
112     Functions and Libraries 
usual Cartesian plane.  "
functions,"114     Functions and Libraries 
 Review questions 
1. 
"
functions,"120     Functions and Libraries 
10."
recursion,"Chapter 7 
Introduction to Recursion 
 
 
 
 
 
 
 
 
And often enough, our faith beforehand in a certain result is the 
only thing that makes the result come true. 
"
recursion,"— William James, The Will To Believe, 1897 
316     Introduction to Recursion 
 
Most algorithmic strategies used to solve programming problems have counterparts 
outside the domain of computing.  "
recursion,"That strategy, called recursion, is defined as any 
solution technique in which large problems are solved by reducing them to smaller 
problems of the same form.  "
recursion,"What makes recursion special is that the subproblems in a 
recursive solution have the same form as the original problem. 
 
"
recursion,"Unlike repetition or conditional testing, recursion is not a concept that 
comes up in day-to-day life.  "
recursion,"Because it is unfamiliar, learning how to use recursion 
can be difficult.  "
recursion,"To do so, you must develop the intuition necessary to make 
recursion seem as natural as all the other control structures.  "
recursion,"Even so, learning to use recursion is definitely worth the effort.  "
recursion,"As a 
problem-solving tool, recursion is so powerful that it at times seems almost magical.  
"
recursion,"In addition, using recursion often makes it possible to write complex programs in 
simple and profoundly elegant ways. 
 
 "
recursion,"7.1 A simple example of recursion 
To gain a better sense of what recursion is, let’s imagine that you have been 
appointed as the funding coordinator for a large charitable organization that is long 
on volunteers and short on cash.  "
recursion,"7.1 A simple example of recursion 
To gain a better sense of what recursion is, let’s imagine that you have been 
appointed as the funding coordinator for a large charitable organization that is long 
on volunteers and short on cash.  "
recursion,"Your organization 
 
7.1 A simple example of recursion      317 
has a reasonable supply of volunteers.  "
recursion,"In the context of programming, 
having a function call itself is the defining characteristic of recursion. 
 
"
recursion,"In general, the body of a recursive function has the following form: 
 
318     Introduction to Recursion 
if (test for simple case) { 
   Compute a simple solution without using recursion. 
"
recursion,"In general, the body of a recursive function has the following form: 
 
318     Introduction to Recursion 
if (test for simple case) { 
   Compute a simple solution without using recursion. 
"
recursion,The collectContributions example illustrates the power of recursion.  
recursion,"7.2 The factorial function 
Although the collectContributions example illustrates the idea of recursion, it 
gives little insight into how recursion is used in practice, mostly because the steps 
that make up the solution, such as finding 10 volunteers and collecting money, are 
not easily represented in a C++ program.  "
recursion,"7.2 The factorial function 
Although the collectContributions example illustrates the idea of recursion, it 
gives little insight into how recursion is used in practice, mostly because the steps 
that make up the solution, such as finding 10 volunteers and collecting money, are 
not easily represented in a C++ program.  "
recursion,"To get a practical sense of the nature of 
recursion, you need to consider problems that fit more easily into the programming 
domain. 
 
"
recursion,"For most people, the best way to understand recursion is to start with simple 
mathematical functions in which the recursive structure follows directly from the 
statement of the problem and is therefore easy to see.  "
recursion,"The new problem—finding the factorial of n – 1—has the same 
form as the original problem, which is the fundamental characteristic of recursion.  
320     Introduction to Recursion 
You can then use the same process to define (n – 1)!"
recursion,"The new problem—finding the factorial of n – 1—has the same 
form as the original problem, which is the fundamental characteristic of recursion.  
320     Introduction to Recursion 
You can then use the same process to define (n – 1)!"
recursion,"When you are learning 
about recursion for the first time, the recursive implementation of fact seems to 
leave something out.  "
recursion,"Thus, the next 
frame looks like this: 
322     Introduction to Recursion 
 
 
 
There are now two frames labeled fact.  "
recursion,"This result gets propagated back to its caller, which is 
represented by the top frame in the following diagram: 
 
 
 
Because n is now 2, evaluating the return statement causes the value 2 to be 
passed back to the previous level, as follows: 
 
324     Introduction to Recursion 
 
 
At this stage, the program returns 3 × 2 to the previous level, so that the frame for 
the initial call to fact looks like this: 
 
 
 
The final step in the calculation process consists of calculating 4 × 6 and returning 
the value 24 to the main program. 
 
"
recursion,"Learning to 
apply this strategy is essential to using recursion in practical applications. 
 
 
"
recursion,"In March, however, the original pair is now of reproductive age, which 
326     Introduction to Recursion 
means that a new pair of rabbits is born.  "
recursion,"The essence of 
recursion is to break problems down into simpler ones that can be solved by calls to 
exactly the same function.  "
recursion,"Because the argument values are smaller, each of these calls 
        
328     Introduction to Recursion 
 
The Fibonacci function 
 
7.3 The Fibonacci function      329 
represents a simpler case.  "
recursion,"330     Introduction to Recursion 
Recursion is not to blame 
On discovering that the implementation of fib(n) given in Figure 7-1 is highly 
inefficient, many people are tempted to point their finger at recursion as the culprit.  
"
recursion,"330     Introduction to Recursion 
Recursion is not to blame 
On discovering that the implementation of fib(n) given in Figure 7-1 is highly 
inefficient, many people are tempted to point their finger at recursion as the culprit.  
"
recursion,"330     Introduction to Recursion 
Recursion is not to blame 
On discovering that the implementation of fib(n) given in Figure 7-1 is highly 
inefficient, many people are tempted to point their finger at recursion as the culprit.  
"
recursion,"The problem in the Fibonacci example, however, has nothing to do with recursion 
per se but rather the way in which recursion is used.  "
recursion,"The problem in the Fibonacci example, however, has nothing to do with recursion 
per se but rather the way in which recursion is used.  "
recursion,"As is often the case when using recursion, the key to finding a more efficient 
solution lies in adopting a more general approach.  "
recursion,"The simple 
case for the recursion consists of the terms t0 and t1, whose values are part of the 
definition of the sequence.  "
recursion,"The interesting question, however, is how 
you can use recursion to determine this result. 
 
"
recursion,"This insight makes it possible to implement the function additiveSequence as 
follows: 
 
332     Introduction to Recursion 
int additiveSequence(int n, int t0, int t1) { 
   if (n == 0) return t0; 
   if (n == 1) return t1; 
   return additiveSequence(n - 1, t1, t0 + t1); 
} 
 
If you trace through the steps in the calculation of fib(5) using this technique, 
you will discover that the calculation involves none of the redundant computation 
that plagued the earlier recursive formulation.  "
recursion,"7.4 Checking palindromes 
Although the factorial and Fibonacci functions provide excellent examples of how 
recursive functions work, they are mathematical in nature and may therefore convey 
the incorrect impression that recursion is applicable only to mathematical functions.  
"
recursion,"In fact, you can apply recursion to any problem that can be decomposed into 
simpler problems of the same form.  "
recursion,"It is therefore useful to consider a few more 
examples of recursion, focusing on those that are less mathematical in nature.  "
recursion,"This 
section, for example, illustrates the use of recursion in a simple string application. 
 
"
recursion,"You can improve the performance of 
isPalindrome by making the following changes: 
 
334     Introduction to Recursion 
• Calculate the length of the argument only once.  "
recursion,"336     Introduction to Recursion 
If neither of these cases applies, the implementation can simplify the problem by 
choosing the appropriate half of the array and calling itself recursively with an 
updated set of search limits. 
 
 "
recursion,"7.6 Mutual recursion 
In each of the examples considered so far, the recursive functions have called 
themselves directly, in the sense that the body of the function contains a call to 
itself.  "
recursion,"Although most of the recursive functions you encounter are likely to adhere 
to this style, the definition of recursion is actually somewhat broader.  "
recursion,"To be 
 
7.6 Mutual recursion      337 
recursive, a function must call itself at some point during its evaluation.  "
recursion,"Because the 
functions ƒ and g call each other, this type of recursion is called mutual recursion. 
 
"
recursion,"Because the 
functions ƒ and g call each other, this type of recursion is called mutual recursion. 
 
"
recursion,"As a simple example, it turns out to be easy—although wildly inefficient—to use 
recursion to test whether a number is even or odd.  "
recursion,"Even though these rules seem simplistic, they form the basis of an effective strategy 
for distinguishing odd and even numbers, as long as those numbers are nonnegative.  
338     Introduction to Recursion 
The code in Figure 7-6 ensures that condition by having isEven and isOdd take 
arguments of type unsigned, which C++ uses to represent an integer that can never 
be less than zero. 
 
 "
recursion,"7.7 Thinking recursively 
For most people, recursion is not an easy concept to grasp.  "
recursion,"When you try to learn about recursion, however, this balance seems to change.  
"
recursion,"Avoiding the common pitfalls 
As you gain experience with recursion, the process of writing and debugging 
recursive programs will become more natural.  "
recursion,"For recursion to 
work, the problems have to get simpler as you go along.  "
recursion,"If the 
problem instances do not get simpler, the decomposition process will just keep 
making more and more calls, giving rise to the recursive analogue of the infinite 
loop, which is called nonterminating recursion. 
"
recursion,"A common source of error is failing to include 
simple case tests for all the cases that can arise as the result of the recursive 
340     Introduction to Recursion 
decomposition.  "
recursion,"When you use recursion to break down a 
problem, it is essential that the subproblems be of the same form.  "
recursion,"Summary 
This chapter has introduced the idea of recursion, a powerful programming strategy 
in which complex problems are broken down into simpler problems of the same 
form.  "
recursion,"Recursion is similar to stepwise refinement in that both strategies consist of 
breaking a problem down into simpler problems that are easier to solve.  "
recursion,"The 
distinguishing characteristic of recursion is that the simpler subproblems must 
have the same form as the original. 
"
recursion,"• To use recursion, you must be able to identify simple cases for which the answer 
is easily determined and a recursive decomposition that allows you to break any 
complex instance of the problem into simpler problems of the same type. 
 
"
recursion,"In C++, recursive functions typically have the following paradigmatic form: 
 
if (test for simple case) { 
   Compute a simple solution without using recursion. 
"
recursion,"• Before you can use recursion effectively, you must learn to limit your analysis to 
a single level of the recursive decomposition and to rely on the correctness of all 
simpler recursive calls without tracing through the entire computation.  "
recursion,"Although some recursive functions may be less efficient than their iterative 
counterparts, recursion itself is not the problem.  "
recursion,"• Recursion need not consist of a single function that calls itself but may instead 
involve several functions that call each other in a cyclical pattern.  "
recursion,"Recursion 
that involves more than one function is called mutual recursion. 
"
recursion,"Recursion 
that involves more than one function is called mutual recursion. 
"
recursion,Learning to use recursion effectively requires practice and more practice.  
recursion,"But because recursion will turn out to 
be one of the most powerful techniques in your programming repertoire, that time 
will be well spent. 
 
"
recursion,"342     Introduction to Recursion 
 Review questions 
1. 
Define the terms recursive and iterative.  "
recursion,"What is the fundamental difference between recursion and traditional stepwise 
refinement? 
 
"
recursion,"What two properties must a problem have for recursion to make sense as a 
solution strategy? 
 
"
recursion,"What is mutual recursion? 
 
17."
recursion,"The following definitions of isEven and isOdd are also incorrect: 
 
bool isEven(unsigned int n) { 
   if (n == 0) { 
      return true; 
   } else { 
      return isOdd(n - 1); 
   } 
} 
 
344     Introduction to Recursion 
bool isOdd(unsigned int n) { 
   if (n == 1) { 
      return true; 
   } else { 
      return isEven(n - 1); 
   } 
} 
 
Give an example that shows how this implementation can fail.  "
recursion,"For each of the two recursive implementations of the function fib(n) 
presented in this chapter, write a recursive function (you can call these 
countFib1 and countFib2 for the two algorithms) that counts the number of 
346     Introduction to Recursion 
function calls made during the evaluation of the corresponding Fibonacci 
calculation.  "
recursion,"Use this relationship between entries in 
348     Introduction to Recursion 
Pascal’s Triangle to write a recursive implementation of the c(n, k) function 
that uses no loops, no multiplication, and no calls to fact. 
 
"
recursion,"— Sun Tzu, ~5th Century BCE 
350     Recursive Strategies 
 
When a recursive decomposition follows directly from a mathematical definition, as 
it does in the case of the fact and fib functions in Chapter 7, applying recursion is 
not particularly hard.  "
recursion,"In fact, if you try to solve 
these problems without using recursion, relying instead on more familiar iterative 
techniques, you will find them quite difficult to solve.  "
recursion,"If you exploit the power 
of recursion, a few lines of code are sufficient for each task. 
 
"
recursion,"The Towers of Hanoi      351 
As far as I know, the Towers of Hanoi puzzle has no practical use except one: 
teaching recursion to computer science students.  "
recursion,"In that domain, it has tremendous 
value because the solution involves nothing besides recursion.  "
recursion,"Because it works so well as an example, the Towers of Hanoi is included in most 
textbooks that treat recursion and has become—much like the “hello, world” 
program in Chapter 1—part of the cultural heritage that computer scientists share. 
 
"
recursion,"Framing the problem 
In order to apply recursion to the Towers of Hanoi problem, you must first frame 
the problem in more general terms.  "
recursion,"To apply recursion, you 
must first make sure that the problem meets the following conditions: 
 
1. 
"
recursion,"Whenever you use recursion to decompose a problem, 
you must make sure that the new problems are identical in form to the original.  "
recursion,"If you’re like most students learning about recursion for the first time, the 
solution seems so short that you feel sure there must be something missing.  "
recursion,"If you think about the process in this holistic form, you can immediately see that 
completion of this step will move the tower of two disks back from C to B, leaving 
the desired final configuration: 
 
 
 
 8.2 The subset-sum problem 
Although the Towers of Hanoi problem offers a wonderful illustration of the power 
of recursion, its effectiveness as an example is compromised by its lack of any 
practical application.  "
recursion,"If the only examples of recursion are like the 
Towers of Hanoi, it’s easy to conclude that recursion is useful only for solving 
abstract puzzles.  "
recursion,"If the only examples of recursion are like the 
Towers of Hanoi, it’s easy to conclude that recursion is useful only for solving 
abstract puzzles.  "
recursion,"When you are first learning about recursion, it is easy to 
look at a recursive solution and believe that you could have generated it on your 
own.  "
recursion,"If you enter the string ""aeinrst"", you get the 
following output—a list that serious Scrabble players will recognize instantly: 
 
 
368     Recursive Strategies 
 8.4 Graphical recursion 
Some of the most exciting applications of recursion use graphics to create intricate 
pictures in which a particular motif is repeated at many different scales.  "
recursion,"If you enter the string ""aeinrst"", you get the 
following output—a list that serious Scrabble players will recognize instantly: 
 
 
368     Recursive Strategies 
 8.4 Graphical recursion 
Some of the most exciting applications of recursion use graphics to create intricate 
pictures in which a particular motif is repeated at many different scales.  "
recursion,"The 
remainder of this chapter offers a few examples of graphical recursion that make 
use of the GWindow class introduced briefly at the end of Chapter 2.  "
recursion,"This material 
is not essential to learning about recursion, and you can skip it if you don’t have 
ready access to the graphics library.  "
recursion,"On the other hand, working through these 
examples will make recursion seem a lot more powerful, not to mention more fun. 
 
"
recursion,"Suppose that you want to generate compositions such as the following, which—
like much of Mondrian’s work—consists only of horizontal and vertical lines: 
 
 
8.4 Graphical recursion      369 
 
 
"
recursion,"The Koch snowflake begins with an 
equilateral triangle like this: 
 
 
 
 
8.4 Graphical recursion      371 
Mondrian.cpp 
372     Recursive Strategies 
This triangle, in which the sides are straight lines, is called the Koch snowflake of 
order 0.  "
recursion,"Thus, the first step is to replace each line segment in the triangle 
with a line that looks like this: 
 
 
 
Applying this transformation to each of the three sides of the original triangle 
generates the Koch snowflake of order 1, as follows: 
 
 
 
If you then replace each line segment in this figure with a new line that again 
includes a triangular wedge, you create the following order-2 Koch snowflake: 
 
 
 
Replacing each of these line segments gives the order-3 fractal shown in the 
following diagram, which now looks even more like a snowflake: 
 
 
 
 
8.4 Graphical recursion      373 
"
recursion,"The complete implementation of the Snowflake program, which includes the 
finished code for drawFractalLine, appears in Figure 8-5. 
374     Recursive Strategies 
Snowflake.cpp 
 
Summary      375 
Summary 
This chapter in fact introduces relatively few new concepts because the fundamental 
precepts of recursion were introduced in Chapter 7.  "
recursion,"They are indeed harder, but recursion is a tool for solving 
hard problems.  "
recursion,"Whenever you want to apply recursion to a programming problem, you have to 
devise a strategy that transforms the problem into simpler instances of the same 
problem.  "
recursion,• Recursion is not magical.  
recursion,"What simple case is used to terminate the recursion in Mondrian.cpp? 
 
"
recursion,"3. 
Rewrite the Towers of Hanoi program so that it uses an explicit stack of 
pending tasks instead of recursion.  "
recursion,"That solution requires no recursion and 
very little thinking.  "
recursion,"The simplest possible strategy would be to draw a straight line between 
the two points: 
 
 
 
This is the order-0 coastline and represents the base case of the recursion. 
 
"
recursion,"The 
examples in this chapter are designed to illustrate this process and demonstrate the 
power of recursion in this domain. 
 
 "
recursion,"All 
you need to do is rely on the power of recursion to solve the individual 
subproblems, and you’re home free.  "
recursion,"You still have to identify a set of simple cases 
so that the recursion can terminate, but the hard work has been done. 
 
"
recursion,"If you check at the beginning of the procedure 
to see whether the current square is marked, you can terminate the recursion at that 
point.  "
recursion,"To ensure that the recursion can terminate when a solution is found, the solveMaze 
function returns true if a solution has been found, and false otherwise. 
 
"
recursion,"In order to use recursion effectively, at some point you must be able to look at a 
recursive function like the solveMaze example in Figure 9-3 and say to yourself 
something like this: “I understand how this works.  "
recursion,"For most of you, however, that confidence in the power 
of recursion will not come easily.  "
recursion,"At this level of the recursion, moving north is no longer possible, so the for loop 
cycles through the other directions.  "
recursion,"It turns out that all the paths have also been explored in this position, so the program 
once again unmarks the square and returns to the next higher level in the recursion.  
"
recursion,"The recursion systematically explores 
every corridor along this path, backing up through the stack of recursive calls 
whenever it reaches a dead end.  "
recursion,"This value is then propagated back through all 27 levels of the 
recursion, eventually returning back to the main program. 
 
 "
recursion,"You 
just have to rely on the power of recursion.  "
recursion,"The usual strategy for limiting the search is to set some maximum value for the 
depth of the recursion.  "
recursion,"You could, for example, allow the recursion to continue 
until each player has made five moves, for a total of ten ply.  "
recursion,"But what happens if you hit the recursion limit before the outcome of the game is 
decided?  "
recursion,"Although any simple calculation is sure to overlook some important factor, it is 
important to remember that static analysis applies only after the recursion limit is 
reached.  "
recursion,"The evaluatePosition 
method uses findBestMove to determine the best move and then return the rating 
of that move, unless the recursion limit or state of the game require static analysis. 
 
"
recursion,"The first is the depth of the 
recursion, which allows the algorithm to cut off computation after a certain number 
of moves as described in the preceding section.  "
recursion,"By 
exploiting the power of recursion, however, you can avoid coding the details of the 
backtracking process explicitly and develop general solution strategies that apply to 
a wide variety of problem domains. 
 
"
recursion,"Use recursion to solve the problem from the new position. 
   "
recursion,"One such tour is shown in the following diagram, in which the numbers in the 
squares indicate the order in which they were visited: 
 
 
 
Write a program that uses backtracking recursion to find a knight’s tour. 
 
"
recursion,"The second implementation, which uses the 
notion of additive sequences to produce a version of fib(n) that is comparable in 
efficiency to traditional iterative approaches, demonstrates that recursion itself is 
not the cause of the problem.  "
recursion,"Even so, examples like the first version of the 
Fibonacci function have such high execution costs that recursion sometimes gets a 
bad name as a result. 
 
"
recursion,"10.3 Recursion to the rescue      443 
 
If all this mathematics scares you, try not to worry.  "
recursion,"10.3 Recursion to the rescue 
At this point, you know considerably more about complexity analysis than you did 
when you started the chapter.  "
recursion,"You compare the 25 from v1 against the 30 in v2 and choose the 
former: 
 
 
10.3 Recursion to the rescue      445 
 
 
 
"
recursion,"This condition defines the simple case for the recursion. 
"
recursion,"446     Algorithmic Analysis 
 
 
 
10.3 Recursion to the rescue      447 
 
 
"
recursion,"In a way, the process of mathematical induction is like the process of recursion 
viewed from the opposite direction.  "
recursion,Both induction and recursion require you to make a leap of faith.  
recursion,"In your own words, describe the relationship between recursion and 
mathematical induction. 
 
"
recursion,"Moreover, this condition rules out recursive solutions, because the 
space required to store the stack frames would grow with the depth of the 
recursion. 
"
recursion,"Moreover, this condition rules out recursive solutions, because the 
space required to store the stack frames would grow with the depth of the 
recursion. 
"
recursion,"Recursion and lists 
Although most code used to process linked lists proceeds iteratively in the manner 
described in the preceding section, linked lists have a recursive character that often 
turns out to be useful in practice.  "
pointers,"Chapter 11 
Pointers and Arrays 
 
 
 
 
 
 
 
 
Orlando ran her eyes through it and then, using the first finger of 
her right hand as pointer, read out the following facts as being 
most germane to the matter. 
— Virginia Woolf, Orlando, 1928 
474     Pointers and Arrays 
 
For the most part, the programs in this book have relied on abstract data types to 
represent compound objects.  "
pointers,"Chapter 11 
Pointers and Arrays 
 
 
 
 
 
 
 
 
Orlando ran her eyes through it and then, using the first finger of 
her right hand as pointer, read out the following facts as being 
most germane to the matter. 
— Virginia Woolf, Orlando, 1928 
474     Pointers and Arrays 
 
For the most part, the programs in this book have relied on abstract data types to 
represent compound objects.  "
pointers,"The rightmost digit represents the 
units field, and each of the other positions counts for twice as much as the digit to 
its right. 
 
Consider, for example, the eight-bit byte containing the following binary digits: 
 
 
 
476     Pointers and Arrays 
"
pointers,"For historical 
478     Pointers and Arrays 
reasons dating back to its predecessor languages, C++ defines the data type char to 
be exactly one byte in size.  "
pointers,"480     Pointers and Arrays 
• Writing address numbers in their hexadecimal form using a sans-serif font makes 
it easier to recognize that a particular number represents an address rather than 
some unidentified integer.  "
pointers,"Internally, these variables are 
482     Pointers and Arrays 
assigned space in a block that is pushed onto the top of the stack at the time of each 
function call. 
 
"
pointers,"This example does, however, give you 
484     Pointers and Arrays 
enough of a sense of how variables are assigned to memory to cover the topic of 
pointers, which are introduced in the following section.  "
pointers,"If 
486     Pointers and Arrays 
you use the same declaration to declare two pointers of the same type, you need to 
mark each of the variables with an asterisk, as in 
 
int *p1, *p2; 
 
The declaration 
 
int *p1, p2; 
 
declares p1 as a pointer to an integer, but declares p2 as an integer variable. 
 
"
pointers,"488     Pointers and Arrays 
To move from a pointer to the value it points to, you use the * operator.  "
pointers,"Using the pointer-based format, the memory diagram that results from these 
declarations looks like this: 
 
490     Pointers and Arrays 
 
 
From the pointer pp, you can move to the object using the * operator, so that *pp 
and pt are effectively synonyms. 
 
"
pointers,"492     Pointers and Arrays 
"
pointers,"Exchanging those values means that the effect 
of this function persists after the call to swap returns, when the stack looks like this: 
 
 
 
The program continues with the updated values, leading to the following output: 
 
494     Pointers and Arrays 
 
 
"
pointers,"Thus, a more 
conventional declaration would look like this: 
 
const int N_ELEMENTS = 10; 
 
int intArray[N_ELEMENTS]; 
 
You can represent this declaration pictorially as follows: 
 
496     Pointers and Arrays 
 
 
"
pointers,"Thus 
498     Pointers and Arrays 
you could initialize a variable N_BIG_CITIES to hold the number of cities in the 
bigCities array by writing 
 
const int N_BIG_CITIES = sizeof BIG_CITIES / 
                         sizeof BIG_CITIES[0]; 
 
Effective and allocated sizes 
Although the sizeof technique allows you to determine the size of a statically 
allocated array, there are many applications in which you have no way of knowing 
how large an array should be when you write the code because the actual number of 
elements depends on the user’s data.  "
pointers,"500     Pointers and Arrays 
As a general rule, you should declare parameters in the way that reflects their 
use.  "
pointers,"For example, if a program contains the expression 
 
502     Pointers and Arrays 
p + 2 
 
the result of evaluating this expression would be a new pointer value that contains 
the address of list[2].  "
pointers,"If, for example, you use the string constant ""hello, world"" in a C++ 
program, the compiler generates an array of characters in memory containing the 
characters in the string plus an extra null character at the end, as follows: 
 
 
 
504     Pointers and Arrays 
"
pointers,"506     Pointers and Arrays 
Pointer arithmetic and programming style 
For reasons of history and habit, many C++ programmers use pointer arithmetic in 
places where array notation makes the intent much clearer.  "
arrays,"Arrays in C++, however, have 
a number of weaknesses, including the following: 
 
• Arrays are allocated with a fixed size that you can’t subsequently change. 
"
arrays,"Chapter 11 
Pointers and Arrays 
 
 
 
 
 
 
 
 
Orlando ran her eyes through it and then, using the first finger of 
her right hand as pointer, read out the following facts as being 
most germane to the matter. 
— Virginia Woolf, Orlando, 1928 
474     Pointers and Arrays 
 
For the most part, the programs in this book have relied on abstract data types to 
represent compound objects.  "
arrays,"Chapter 11 
Pointers and Arrays 
 
 
 
 
 
 
 
 
Orlando ran her eyes through it and then, using the first finger of 
her right hand as pointer, read out the following facts as being 
most germane to the matter. 
— Virginia Woolf, Orlando, 1928 
474     Pointers and Arrays 
 
For the most part, the programs in this book have relied on abstract data types to 
represent compound objects.  "
arrays,"The rightmost digit represents the 
units field, and each of the other positions counts for twice as much as the digit to 
its right. 
 
Consider, for example, the eight-bit byte containing the following binary digits: 
 
 
 
476     Pointers and Arrays 
"
arrays,"For historical 
478     Pointers and Arrays 
reasons dating back to its predecessor languages, C++ defines the data type char to 
be exactly one byte in size.  "
arrays,"480     Pointers and Arrays 
• Writing address numbers in their hexadecimal form using a sans-serif font makes 
it easier to recognize that a particular number represents an address rather than 
some unidentified integer.  "
arrays,"Internally, these variables are 
482     Pointers and Arrays 
assigned space in a block that is pushed onto the top of the stack at the time of each 
function call. 
 
"
arrays,"This example does, however, give you 
484     Pointers and Arrays 
enough of a sense of how variables are assigned to memory to cover the topic of 
pointers, which are introduced in the following section.  "
arrays,"If 
486     Pointers and Arrays 
you use the same declaration to declare two pointers of the same type, you need to 
mark each of the variables with an asterisk, as in 
 
int *p1, *p2; 
 
The declaration 
 
int *p1, p2; 
 
declares p1 as a pointer to an integer, but declares p2 as an integer variable. 
 
"
arrays,"488     Pointers and Arrays 
To move from a pointer to the value it points to, you use the * operator.  "
arrays,"Using the pointer-based format, the memory diagram that results from these 
declarations looks like this: 
 
490     Pointers and Arrays 
 
 
From the pointer pp, you can move to the object using the * operator, so that *pp 
and pt are effectively synonyms. 
 
"
arrays,"492     Pointers and Arrays 
"
arrays,"Exchanging those values means that the effect 
of this function persists after the call to swap returns, when the stack looks like this: 
 
 
 
The program continues with the updated values, leading to the following output: 
 
494     Pointers and Arrays 
 
 
"
arrays,"As with 
 
11.3 Arrays     495 
vectors, arrays are composed of individual elements of some base type selected by 
an integer index.  "
arrays,"Thus, a more 
conventional declaration would look like this: 
 
const int N_ELEMENTS = 10; 
 
int intArray[N_ELEMENTS]; 
 
You can represent this declaration pictorially as follows: 
 
496     Pointers and Arrays 
 
 
"
arrays,"As you can see from this example, specifying 
 
11.3 Arrays     497 
explicit initializers allow you to omit the array size from the declaration, which is 
then taken from the number of values. 
 
"
arrays,"Thus 
498     Pointers and Arrays 
you could initialize a variable N_BIG_CITIES to hold the number of cities in the 
bigCities array by writing 
 
const int N_BIG_CITIES = sizeof BIG_CITIES / 
                         sizeof BIG_CITIES[0]; 
 
Effective and allocated sizes 
Although the sizeof technique allows you to determine the size of a statically 
allocated array, there are many applications in which you have no way of knowing 
how large an array should be when you write the code because the actual number of 
elements depends on the user’s data.  "
arrays,"500     Pointers and Arrays 
As a general rule, you should declare parameters in the way that reflects their 
use.  "
arrays,"For example, if a program contains the expression 
 
502     Pointers and Arrays 
p + 2 
 
the result of evaluating this expression would be a new pointer value that contains 
the address of list[2].  "
arrays,"If, for example, you use the string constant ""hello, world"" in a C++ 
program, the compiler generates an array of characters in memory containing the 
characters in the string plus an extra null character at the end, as follows: 
 
 
 
504     Pointers and Arrays 
"
arrays,"506     Pointers and Arrays 
Pointer arithmetic and programming style 
For reasons of history and habit, many C++ programmers use pointer arithmetic in 
places where array notation makes the intent much clearer.  "
arrays,"582     Efficiency and Representation 
buffer.cpp (arrays), p1 
 
13.3 An array-based implementation     583 
buffer.cpp (arrays), p2 
584     Efficiency and Representation 
The insertCharacter and deleteCharacter methods are interesting 
because each of them requires shifting characters in the array, either to make room 
for a character you want to insert or to close up space left by a deleted character.  
"
arrays,"582     Efficiency and Representation 
buffer.cpp (arrays), p1 
 
13.3 An array-based implementation     583 
buffer.cpp (arrays), p2 
584     Efficiency and Representation 
The insertCharacter and deleteCharacter methods are interesting 
because each of them requires shifting characters in the array, either to make room 
for a character you want to insert or to close up space left by a deleted character.  
"
strings,"The most important of these functions appear in Table 3-2. 
 
148     Strings 
 
 Review questions 
1. 
"
inheritance,"The chapter then concludes by exploring the structure 
of the C++ stream classes as a representative example of inheritance hierarchies in 
an object-oriented language. 
 
 "
inheritance,This property is called inheritance.  
inheritance,"Although C++ 
tends to use inheritance somewhat less frequently than many object-oriented 
languages do, it is nonetheless one of the features that sets the object-oriented 
paradigm apart from earlier programming models. 
 
"
inheritance,"What is meant by the following terms: subclass, superclass, and inheritance? 
 
"
inheritance,"In later chapters, you 
will have a chance to learn other important aspects of class design, including 
memory management and inheritance. 
 
 "
inheritance,"The examples in this chapter focus on classes that 
encapsulate data and operations into a coherent whole, deferring the more complex 
issue of inheritance to Chapter 19. 
 
"
polymorphism,"In this 
chapter, you will learn how to implement them. 
 
 14.1 Templates 
In computer science, being able to use the same code for more than one data type is 
called polymorphism.  "
polymorphism,"Programming languages implement polymorphism in a 
variety of ways.  "
templates,"In this 
chapter, you will learn how to implement them. 
 
 14.1 Templates 
In computer science, being able to use the same code for more than one data type is 
called polymorphism.  "
templates,"As an example, you can use the following code to define two versions of a 
function named max—one for integers and one for floating-point values—that 
returns the larger of two arguments: 
 
 
14.1 Templates      617 
int max(int x, int y) { 
   return (x > y) ?"
algorithms,"Chapter 9 
Backtracking Algorithms 
 
 
 
 
 
 
 
 
Truth is not discovered by proofs but by exploration.  "
algorithms,"— Simone Weil, The New York Notebook, 1942 
390     Backtracking Algorithms 
For many real-world problems, the solution process consists of working your way 
through a sequence of decision points in which each choice leads you further along 
some path.  "
algorithms,"Instead, 
your goal is to find a recursive insight that simplifies the problem, one step at a 
392     Backtracking Algorithms 
time.  "
algorithms,"394     Backtracking Algorithms 
Coding the maze solution algorithm 
"
algorithms,"<< endl; 
   } 
   return 0; 
} 
 
 
9.1 Recursive backtracking in a maze      395 
 
maze.h, p1
396     Backtracking Algorithms 
maze.h, p2 
 
9.1 Recursive backtracking in a maze      397 
 
The code for the solveMaze function appears in Figure 9-3, along with the 
function adjacentPoint(start, dir), which returns the point you reach if you 
move in the specified direction from the starting point. 
 
"
algorithms,"398     Backtracking Algorithms 
Convincing yourself that the solution works 
"
algorithms,"The only difference along this route is that 
eventually—after descending through an additional recursive level for every step on 
the path—the program makes a recursive call in the following position: 
 
400     Backtracking Algorithms 
 
 
At this point, Theseus is outside the maze, so the simple case kicks in and returns 
true to its caller.  "
algorithms,"402     Backtracking Algorithms 
"
algorithms,"9.2 Backtracking and games      403 
 
Nim.cpp 
404     Backtracking Algorithms 
nim.cpp, p2 
 
9.2 Backtracking and games      405 
 
nim.cpp, p3 
406     Backtracking Algorithms 
nim.cpp, p4 
 
9.2 Backtracking and games      407 
 
A generalized program for two-player games 
The code in Figure 9-5 is highly specific to Nim.  "
algorithms,"9.2 Backtracking and games      403 
 
Nim.cpp 
404     Backtracking Algorithms 
nim.cpp, p2 
 
9.2 Backtracking and games      405 
 
nim.cpp, p3 
406     Backtracking Algorithms 
nim.cpp, p4 
 
9.2 Backtracking and games      407 
 
A generalized program for two-player games 
The code in Figure 9-5 is highly specific to Nim.  "
algorithms,"The extra 
408     Backtracking Algorithms 
complexity is unwarranted for a class whose only client is likely to be the class that 
implements the game.  "
algorithms,"If there are, for 
example, three possible moves from this position, there will be three lines 
emanating downward from the current state to three new states that represent the 
results of these moves, as shown in the following diagram: 
 
410     Backtracking Algorithms 
 
 
From each of these new positions, your opponent also has options.  "
algorithms,"The 
412     Backtracking Algorithms 
rating of the last move in the highlighted line of the game tree is +2 because it leads 
to a position with a –2 rating.  "
algorithms,"414     Backtracking Algorithms 
minimax strategy 
 
Summary      415 
 
"
algorithms,"416     Backtracking Algorithms 
• You can often find a winning strategy for two-player games by adopting a 
recursive-backtracking approach.  "
algorithms,"The shortest path through the maze has a path length of 11: 
 
 
 
418     Backtracking Algorithms 
Write a function 
 
int shortestPathLength(Maze & maze, Point start); 
 
that returns the length of the shortest path in the maze from the specified 
position to any exit.  "
algorithms,"In order to understand how this process works, it is important to understand 
that the screen of the computer is broken down into an array of tiny dots called 
420     Backtracking Algorithms 
pixels.  "
algorithms,"an o. 
 
422     Backtracking Algorithms 
It turns out that a knight can visit all 64 squares on a chessboard without 
ever moving to the same square twice.  "
algorithms,"For example, each of the following four rectangles represents a domino: 
 
 
 
424     Backtracking Algorithms 
Dominos can be connected end-to-end to form chains, subject to the condition 
that two dominos can be linked together only if the numbers match.  "
algorithms,"426     Backtracking Algorithms 
14."
algorithms,"Exercises      427 
 
tic-tac-toe sample run 
428     Backtracking Algorithms 
16."
debugging,"The designers of the 
original C libraries therefore concluded that it had to be possible to use rand in a 
deterministic way in order to support debugging. 
 
"
debugging,"That behavior, however, 
makes sense only during the debugging phase.  "
debugging,"It is still necessary to allow clients to generate 
a repeatable sequence of values, because doing so simplifies the debugging process.  
"
debugging,"During the debugging phase, you can add the line 
 
setRandomSeed(1); 
 
at the beginning of the main program.  "
debugging,"Being able to display the values of your objects in a human-readable 
form is tremendously important for both testing and debugging, which are essential 
phases of the development process. 
 
"
compilation,"The compilation process 
When you write a program in C++, your first step is to create a file that contains the 
text of the program, which is called a source file.  "
compilation,"The steps in the compilation process are illustrated in Figure 1-2. 
 
"
compilation,"As noted in the discussion of the HelloWorld program earlier in this chapter, 
the specific details of the compilation process vary from one machine to another.  
"
encapsulation,"Of 
these, the most important is that classes provide a framework for encapsulation, 
which is the process of combining the data representation and the associated 
operations into a coherent whole that reveals as few details as possible about the 
underlying structure.  "
encapsulation,"The classes you have already seen in this chapter illustrate 
encapsulation well.  "
encapsulation,"Object-oriented programming, however, offers other important advantages 
besides encapsulation.  Classes in an object-oriented language form a hierarchy in 
which each class automatically acquires the characteristics of the classes that 
precede it in the hierarchy.  "
encapsulation,"The primary 
advantage of doing so is that classes provide better encapsulation.  "
encapsulation,"In modern programming practice, however, this kind of 
encapsulation is more commonly accomplished using classes. 
"
vector,"This chapter introduces five classes—Vector, Stack, Queue, Map, and Set—
each of which represents an important abstract data type.  "
vector,"5.1 The Vector class      197 
To use any of the collection classes introduced in this chapter, you must include 
the appropriate interface, just as you would for any of the libraries from the earlier 
chapters.  "
vector,"For example, in order to use the Vector class in a program, you must include 
the line 
 
#include ""vector.h"" 
 
"
vector,"5.1 The Vector class 
One of the most valuable collection classes is the Vector class, which provides a 
facility similar to the arrays you have almost certainly encountered in your earlier 
experience with programming.  "
vector,"5.1 The Vector class 
One of the most valuable collection classes is the Vector class, which provides a 
facility similar to the arrays you have almost certainly encountered in your earlier 
experience with programming.  "
vector,"The Vector class solves each of these problems by reimplementing the array 
concept in the form of an abstract data type.  "
vector,"You can use the Vector class in place 
of arrays in any application, usually with surprisingly few changes in the source 
code and at most a minor reduction in efficiency.  "
vector,"In fact, once you have the 
Vector class, it’s unlikely that you will have much occasion to use arrays at all, 
unless you actually have to implement classes like Vector, which, not surprisingly, 
198     Collections 
uses arrays in its underlying structure.  "
vector,"In fact, once you have the 
Vector class, it’s unlikely that you will have much occasion to use arrays at all, 
unless you actually have to implement classes like Vector, which, not surprisingly, 
198     Collections 
uses arrays in its underlying structure.  "
vector,"As a client of the Vector class, however, 
you are not interested in that underlying structure and can leave the array mechanics 
to the programmers who implement the abstract data type. 
 
"
vector,"As a client of the Vector class, you are concerned with a different set of issues 
and need to answer the following questions: 
 
1. 
"
vector,"How is it possible to specify the type of object contained in a Vector? 
2. 
"
vector,"How does one create an object that is an instance of the Vector class? 
"
vector,"What methods exist in the Vector class to implement its abstract behavior? 
 
"
vector,"Specifying the base type of a Vector 
In C++, collection classes specify the type of object they contain by including the 
type name in angle brackets following the class name.  "
vector,"For example, the class 
Vector<int> represents a vector whose elements are integers, Vector<char> 
specifies a vector whose elements are single characters, and Vector<string> 
specifies one in which the elements are strings.  "
vector,"For example, the class 
Vector<int> represents a vector whose elements are integers, Vector<char> 
specifies a vector whose elements are single characters, and Vector<string> 
specifies one in which the elements are strings.  "
vector,"For example, the class 
Vector<int> represents a vector whose elements are integers, Vector<char> 
specifies a vector whose elements are single characters, and Vector<string> 
specifies one in which the elements are strings.  "
vector,"For example, the class 
Vector<int> represents a vector whose elements are integers, Vector<char> 
specifies a vector whose elements are single characters, and Vector<string> 
specifies one in which the elements are strings.  "
vector,"For example, the class 
Vector<int> represents a vector whose elements are integers, Vector<char> 
specifies a vector whose elements are single characters, and Vector<string> 
specifies one in which the elements are strings.  "
vector,"In C++, parameterized classes are more often 
called templates, which reflects the fact that C++ compilers treat Vector<int>, 
Vector<char>, and Vector<string> as independent classes that share a 
common structure.  "
vector,"In C++, parameterized classes are more often 
called templates, which reflects the fact that C++ compilers treat Vector<int>, 
Vector<char>, and Vector<string> as independent classes that share a 
common structure.  "
vector,"In C++, parameterized classes are more often 
called templates, which reflects the fact that C++ compilers treat Vector<int>, 
Vector<char>, and Vector<string> as independent classes that share a 
common structure.  "
vector,"The name Vector acts as a template for stamping out a whole 
family of classes, in which the only difference is what type of value the vector 
contains.  "
vector,"The name Vector acts as a template for stamping out a whole 
family of classes, in which the only difference is what type of value the vector 
contains.  "
vector,"Declaring a Vector object 
One of the philosophical principles behind abstract data types is that clients should 
be able to think of them as if they were built-in primitive types.  "
vector,"Thus, just as you 
would declare an integer variable by writing a declaration such as 
 
int n; 
 
it ought to be possible to declare a new vector by writing 
 
Vector<int> vec; 
 
 
5.1 The Vector class      199 
"
vector,"Thus, just as you 
would declare an integer variable by writing a declaration such as 
 
int n; 
 
it ought to be possible to declare a new vector by writing 
 
Vector<int> vec; 
 
 
5.1 The Vector class      199 
"
vector,"Thus, just as you 
would declare an integer variable by writing a declaration such as 
 
int n; 
 
it ought to be possible to declare a new vector by writing 
 
Vector<int> vec; 
 
 
5.1 The Vector class      199 
"
vector,"That declaration introduces a new variable 
named vec, which is—as the template marker in angle brackets indicates—a vector 
of integers. 
 
"
vector,"Vector operations 
When you declare a Vector variable, it starts out as an empty vector, which means 
that it contains no elements.   "
vector,"Vector operations 
When you declare a Vector variable, it starts out as an empty vector, which means 
that it contains no elements.   "
vector,"Vector operations 
When you declare a Vector variable, it starts out as an empty vector, which means 
that it contains no elements.   "
vector,"Since an empty vector is not particularly useful, one 
of the first things you need to learn is how to add new elements to a Vector object.  
"
vector,"Since an empty vector is not particularly useful, one 
of the first things you need to learn is how to add new elements to a Vector object.  
"
vector,"The usual approach is to invoke the add method, which adds a new element at the 
end of the Vector.  "
vector,"For example, if vec is an empty vector of integers as declared 
in the preceding section, executing the code 
 
vec.add(10); 
vec.add(20); 
vec.add(40); 
 
changes vec into a three-element vector containing the values 10, 20, and 40.  "
vector,"For example, if vec is an empty vector of integers as declared 
in the preceding section, executing the code 
 
vec.add(10); 
vec.add(20); 
vec.add(40); 
 
changes vec into a three-element vector containing the values 10, 20, and 40.  "
vector,"As 
with the characters in a string, C++ numbers the elements of a vector starting with 
0, which means that you could diagram the contents of vec like this: 
 
 
 
Unlike the more primitive array type that will be introduced in Chapter 11, the 
size of a vector is not fixed, which means that you can add additional elements at 
any time.  "
vector,"As 
with the characters in a string, C++ numbers the elements of a vector starting with 
0, which means that you could diagram the contents of vec like this: 
 
 
 
Unlike the more primitive array type that will be introduced in Chapter 11, the 
size of a vector is not fixed, which means that you can add additional elements at 
any time.  "
vector,"Later in the program, for example, you could call 
 
vec.add(50); 
 
which would add the value 50 to the end of the vector, like this: 
 
 
 
The insertAt method allows you to add new elements in the middle of a 
vector.  "
vector,"Later in the program, for example, you could call 
 
vec.add(50); 
 
which would add the value 50 to the end of the vector, like this: 
 
 
 
The insertAt method allows you to add new elements in the middle of a 
vector.  "
vector,"For example, calling 
 
vec.insertAt(2, 30); 
 
inserts the value 30 before index position 2, as follows: 
 
200     Collections 
 
 
Internally, the implementation of the Vector class has to expand the array storage 
and move the values 40 and 50 over one position to make room for the 30.  From 
your perspective as a client, the implementation simply takes care of such details, 
and you don’t need to understand how it does so. 
 
"
vector,The Vector class also lets you remove elements.  
vector,"The Vector class includes two methods for selecting and modifying individual 
elements.  "
vector,"For example, calling 
 
vec.set(3, 70); 
 
changes the value in index position 3 from 50 to 70, like this: 
 
 
 
The get, set, insertAt, and removeAt methods all check to make sure that 
the index value you supply is valid for the vector.  "
vector,"For example, if you were to call 
vec.get(4) in this vector, the get method would call error to report that the 
index value 4 is too large for a vector in which the index values run from 0 to 3.  
"
vector,"For example, if you were to call 
vec.get(4) in this vector, the get method would call error to report that the 
index value 4 is too large for a vector in which the index values run from 0 to 3.  
"
vector,"For get, set, and removeAt, the Vector implementation checks that the index is 
greater than or equal to 0 and less than the number of elements.  "
vector,"5.1 The Vector class      201 
The operation of testing whether an index is valid is called bounds-checking.  
"
vector,"Selecting elements in a vector 
"
vector,"This 
feature makes it possible for the Vector class to support the more traditional syntax 
of using square brackets to specify the desired index.  "
vector,"For example, you can set element 3 in vec to 70 by writing 
 
vec[3] = 70; 
 
The resulting syntax is marginally shorter than calling set, but is more evocative of 
the array operations that the Vector class is designed to emulate. 
 
"
vector,"The general 
pattern for cycling through the index positions in a vector looks like this: 
 
for (int i = 0; i < vec.size(); i++) { 
   loop body 
} 
 
Inside the loop body, you can refer to the current element as vec[i]. 
 
"
vector,"As an example, the following code writes out the contents of the vector vec as a 
comma-separated list enclosed in square brackets: 
 
cout <<"
vector,"""]"" << endl; 
 
If you were to execute this code given the most recent contents of vec, you would 
see the following output on the screen: 
 
202     Collections 
 
 
Passing a Vector object as a parameter 
The code at the end of the preceding section is so useful (particularly when you’re 
debugging and need to see what values a vector contains), that it is worth defining a 
function for this purpose.  "
vector,"""]"" << endl; 
 
If you were to execute this code given the most recent contents of vec, you would 
see the following output on the screen: 
 
202     Collections 
 
 
Passing a Vector object as a parameter 
The code at the end of the preceding section is so useful (particularly when you’re 
debugging and need to see what values a vector contains), that it is worth defining a 
function for this purpose.  "
vector,"Call-by-reference is more efficient than C++’s default model of call-by-value, 
which would require copying every element in the vector.  "
vector,"Perhaps more importantly, using call-by-reference makes it possible to write 
functions that change the contents of a vector.  "
vector,"As an example, the following 
function deletes any zero-valued elements from a vector of integers: 
 
void removeZeroElements(Vector<int> & vec) { 
   for (int i = vec.size() - 1; i >= 0; i--) { 
      if (vec[i] == 0) vec.removeAt(i); 
   } 
} 
 
The for loop cycles through each element and checks whether its value is 0.  "
vector,"If so, 
the function calls removeAt to delete that element from the vector.  "
vector,"To ensure that 
 
5.1 The Vector class      203 
removing an element doesn’t change the positions of elements that have not yet 
been checked, the for loop starts at the end of the vector and runs backwards. 
 
"
vector,"To ensure that 
 
5.1 The Vector class      203 
removing an element doesn’t change the positions of elements that have not yet 
been checked, the for loop starts at the end of the vector and runs backwards. 
 
"
vector,"The code would remove the zero elements from the local copy of vec, but not from 
the vector the caller supplied.  "
vector,"When removeZeroElements returns, that copy 
goes away, leaving the original vector unchanged.  "
vector,"The ReverseFile program in Figure 5-1 shows a complete C++ program that 
uses Vector to display the lines from a file in reverse order.  "
vector,"For this reason, both of these functions—along with many other 
useful functions for working with files—are included in the filelib.h library 
listed in Appendix A. 
 
Creating a Vector of a predefined size 
The examples you have seen up to this point start out with an empty vector and then 
add elements to it, one at a time.  "
vector,"For this reason, both of these functions—along with many other 
useful functions for working with files—are included in the filelib.h library 
listed in Appendix A. 
 
Creating a Vector of a predefined size 
The examples you have seen up to this point start out with an empty vector and then 
add elements to it, one at a time.  "
vector,"In many applications, building up a vector one 
element at a time is tedious, particularly if you know the size of the vector in 
advance.  "
vector,"In many applications, building up a vector one 
element at a time is tedious, particularly if you know the size of the vector in 
advance.  "
vector,"As an example, suppose that you wanted to create a vector to hold the scores for 
each hole on an 18-hole golf course.  "
vector,"The strategy you already know is to create an 
empty Vector<int> and then add 18 elements to it using a for loop, as follows: 
 
const int N_HOLES"
vector,"= 18; 
 
Vector<int> golfScores; 
for (int i = 0; i < N_HOLES; i++) { 
   golfScores.add(0); 
} 
 
A better approach is to include the size as a parameter to the declaration like this: 
 
Vector<int> golfScores(N_HOLES); 
 
This declaration creates a Vector<int> with N_HOLES elements, each of which is 
initialized to 0 for a Vector of type int.  "
vector,"= 18; 
 
Vector<int> golfScores; 
for (int i = 0; i < N_HOLES; i++) { 
   golfScores.add(0); 
} 
 
A better approach is to include the size as a parameter to the declaration like this: 
 
Vector<int> golfScores(N_HOLES); 
 
This declaration creates a Vector<int> with N_HOLES elements, each of which is 
initialized to 0 for a Vector of type int.  "
vector,"= 18; 
 
Vector<int> golfScores; 
for (int i = 0; i < N_HOLES; i++) { 
   golfScores.add(0); 
} 
 
A better approach is to include the size as a parameter to the declaration like this: 
 
Vector<int> golfScores(N_HOLES); 
 
This declaration creates a Vector<int> with N_HOLES elements, each of which is 
initialized to 0 for a Vector of type int.  "
vector,"= 18; 
 
Vector<int> golfScores; 
for (int i = 0; i < N_HOLES; i++) { 
   golfScores.add(0); 
} 
 
A better approach is to include the size as a parameter to the declaration like this: 
 
Vector<int> golfScores(N_HOLES); 
 
This declaration creates a Vector<int> with N_HOLES elements, each of which is 
initialized to 0 for a Vector of type int.  "
vector,Each of them creates a Vector<int> filled with 18 zero values.  
vector,"The 
first form requires the client to initialize the elements; the second hands that 
responsibility off to the Vector class itself. 
 
204     Collections 
 
Figure 4-1 
 
5.1 The Vector class      205 
As a more significant example of when you might want to declare a vector of a 
constant size, consider the LetterFrequency program in Figure 5-2, which counts 
how often each of the 26 letters appears in a data file.  "
vector,"The 
first form requires the client to initialize the elements; the second hands that 
responsibility off to the Vector class itself. 
 
204     Collections 
 
Figure 4-1 
 
5.1 The Vector class      205 
As a more significant example of when you might want to declare a vector of a 
constant size, consider the LetterFrequency program in Figure 5-2, which counts 
how often each of the 26 letters appears in a data file.  "
vector,"The 
first form requires the client to initialize the elements; the second hands that 
responsibility off to the Vector class itself. 
 
204     Collections 
 
Figure 4-1 
 
5.1 The Vector class      205 
As a more significant example of when you might want to declare a vector of a 
constant size, consider the LetterFrequency program in Figure 5-2, which counts 
how often each of the 26 letters appears in a data file.  "
vector,"Those counts are maintained 
in the variable letterCounts, which is declared as follows: 
 
Vector<int> letterCounts(26); 
 
Each element in this vector contains the count of the letter at the corresponding 
index in the alphabet, with the number of As in letterCounts[0], the number of 
Bs in letterCounts[1], and so on.  "
vector,"Those counts are maintained 
in the variable letterCounts, which is declared as follows: 
 
Vector<int> letterCounts(26); 
 
Each element in this vector contains the count of the letter at the corresponding 
index in the alphabet, with the number of As in letterCounts[0], the number of 
Bs in letterCounts[1], and so on.  "
vector,"For each letter in the file, all the program has 
to do is increment the value at the appropriate index position in the vector, which 
206     Collections 
can be calculated arithmetically based on the ASCII code of the character.  "
vector,"This statement then updates the count by 
incrementing that element of the vector. 
 
"
vector,"As an example, here is what 
the LetterCounts program produces if you run it on a file containing the text of 
George Eliot’s Middlemarch: 
 
 
 
Constructors for the Vector class 
"
vector,"The sample programs you’ve seen so far in this chapter declare vectors in two 
different ways.  "
vector,"The ReverseFile program in Figure 5-1 defines an empty vector 
of strings using the declaration 
 
Vector<string> lines; 
 
The LetterFrequency program declares a vector containing 26 zeroes like this: 
 
 
5.1 The Vector class      207 
Vector<int> letterCounts(26); 
 
As it happens, there is more going on in these declarations than meets the eye.  
"
vector,"The ReverseFile program in Figure 5-1 defines an empty vector 
of strings using the declaration 
 
Vector<string> lines; 
 
The LetterFrequency program declares a vector containing 26 zeroes like this: 
 
 
5.1 The Vector class      207 
Vector<int> letterCounts(26); 
 
As it happens, there is more going on in these declarations than meets the eye.  
"
vector,"The ReverseFile program in Figure 5-1 defines an empty vector 
of strings using the declaration 
 
Vector<string> lines; 
 
The LetterFrequency program declares a vector containing 26 zeroes like this: 
 
 
5.1 The Vector class      207 
Vector<int> letterCounts(26); 
 
As it happens, there is more going on in these declarations than meets the eye.  
"
vector,"The ReverseFile program in Figure 5-1 defines an empty vector 
of strings using the declaration 
 
Vector<string> lines; 
 
The LetterFrequency program declares a vector containing 26 zeroes like this: 
 
 
5.1 The Vector class      207 
Vector<int> letterCounts(26); 
 
As it happens, there is more going on in these declarations than meets the eye.  
"
vector,"The ReverseFile program in Figure 5-1 defines an empty vector 
of strings using the declaration 
 
Vector<string> lines; 
 
The LetterFrequency program declares a vector containing 26 zeroes like this: 
 
 
5.1 The Vector class      207 
Vector<int> letterCounts(26); 
 
As it happens, there is more going on in these declarations than meets the eye.  
"
vector,"For example, in the declaration 
 
Vector<string> lines; 
 
C++ calls the Vector constructor, which initializes the variable lines to be an 
empty vector that belongs to the parameterized class Vector<string>.  "
vector,"For example, in the declaration 
 
Vector<string> lines; 
 
C++ calls the Vector constructor, which initializes the variable lines to be an 
empty vector that belongs to the parameterized class Vector<string>.  "
vector,"For example, in the declaration 
 
Vector<string> lines; 
 
C++ calls the Vector constructor, which initializes the variable lines to be an 
empty vector that belongs to the parameterized class Vector<string>.  "
vector,"For example, in the declaration 
 
Vector<string> lines; 
 
C++ calls the Vector constructor, which initializes the variable lines to be an 
empty vector that belongs to the parameterized class Vector<string>.  "
vector,"The 
declaration 
 
Vector<int> letterCounts(26); 
 
calls a different version of the constructor to initialize a Vector<int> with 26 
elements. 
 
"
vector,"The 
declaration 
 
Vector<int> letterCounts(26); 
 
calls a different version of the constructor to initialize a Vector<int> with 26 
elements. 
 
"
vector,"The declaration of letterCounts provides an integer 
argument, which tells the compiler to invoke the version of the constructor that 
takes an integer indicating the vector size.  "
vector,"The two versions of the Vector 
constructor appear—along with a complete list of the Vector methods—in 
Table 5-1. 
 
"
vector,"The two versions of the Vector 
constructor appear—along with a complete list of the Vector methods—in 
Table 5-1. 
 
"
vector,"Vector operators 
Partly to illustrate the power of operator overloading and partly because these 
operators turn out to be so useful, the Vector class in the Stanford library defines 
several operators that apply to vector objects.  "
vector,"Vector operators 
Partly to illustrate the power of operator overloading and partly because these 
operators turn out to be so useful, the Vector class in the Stanford library defines 
several operators that apply to vector objects.  "
vector,"Vector operators 
Partly to illustrate the power of operator overloading and partly because these 
operators turn out to be so useful, the Vector class in the Stanford library defines 
several operators that apply to vector objects.  "
vector,"You have already seen the use of 
square brackets, which make it possible to select objects from a vector using the 
traditional selection syntax for arrays.  "
vector,"The Vector class also defines the operators 
+ and += as shorthands for concatenating two vectors and for adding elements to an 
existing vector. 
 
 
"
vector,"The Vector class also defines the operators 
+ and += as shorthands for concatenating two vectors and for adding elements to an 
existing vector. 
 
 
"
vector,"The Vector class also defines the operators 
+ and += as shorthands for concatenating two vectors and for adding elements to an 
existing vector. 
 
 
"
vector,"5.1 The Vector class      209 
The + operator on vectors is defined so that it works in exactly the way it does 
for strings.  "
vector,"5.1 The Vector class      209 
The + operator on vectors is defined so that it works in exactly the way it does 
for strings.  "
vector,"If the character vectors v1 and v2 contain the values 
 
 
 
and 
 
 
 
evaluating the expression v1 + v2 creates a new five-element vector, as follows: 
 
 
 
The += operator adds elements to the end of an existing vector, but is also useful 
if you need to initialize the contents of a vector.  "
vector,"If the character vectors v1 and v2 contain the values 
 
 
 
and 
 
 
 
evaluating the expression v1 + v2 creates a new five-element vector, as follows: 
 
 
 
The += operator adds elements to the end of an existing vector, but is also useful 
if you need to initialize the contents of a vector.  "
vector,"If the character vectors v1 and v2 contain the values 
 
 
 
and 
 
 
 
evaluating the expression v1 + v2 creates a new five-element vector, as follows: 
 
 
 
The += operator adds elements to the end of an existing vector, but is also useful 
if you need to initialize the contents of a vector.  "
vector,"If the character vectors v1 and v2 contain the values 
 
 
 
and 
 
 
 
evaluating the expression v1 + v2 creates a new five-element vector, as follows: 
 
 
 
The += operator adds elements to the end of an existing vector, but is also useful 
if you need to initialize the contents of a vector.  "
vector,"For example, you can declare and 
initialize the vector v1 like this: 
 
Vector<char> v1; 
v1 += 'A', 'B', 'C'; 
 
If you are using C++11, which is the new C++ standard released in 2011, you can 
simplify this initialization, as follows: 
 
Vector<char> v1 = { 'A', 'B', 'C' }; 
 
Representing two-dimensional structures 
"
vector,"For example, you can declare and 
initialize the vector v1 like this: 
 
Vector<char> v1; 
v1 += 'A', 'B', 'C'; 
 
If you are using C++11, which is the new C++ standard released in 2011, you can 
simplify this initialization, as follows: 
 
Vector<char> v1 = { 'A', 'B', 'C' }; 
 
Representing two-dimensional structures 
"
vector,"For example, you can declare and 
initialize the vector v1 like this: 
 
Vector<char> v1; 
v1 += 'A', 'B', 'C'; 
 
If you are using C++11, which is the new C++ standard released in 2011, you can 
simplify this initialization, as follows: 
 
Vector<char> v1 = { 'A', 'B', 'C' }; 
 
Representing two-dimensional structures 
"
vector,"The type parameter used in the Vector class can be any C++ type and may itself be 
a parameterized type.  "
vector,"In particular, you can create a two-dimensional structure by 
declaring a Vector whose base type is itself a Vector.  "
vector,"In particular, you can create a two-dimensional structure by 
declaring a Vector whose base type is itself a Vector.  "
vector,"The declaration 
 
Vector< Vector<int> > sudoku(9, Vector<int>(9)); 
 
initializes the variable sudoku to a Vector of nine elements, each of which is itself 
a Vector of nine elements.  "
vector,"The declaration 
 
Vector< Vector<int> > sudoku(9, Vector<int>(9)); 
 
initializes the variable sudoku to a Vector of nine elements, each of which is itself 
a Vector of nine elements.  "
vector,"The declaration 
 
Vector< Vector<int> > sudoku(9, Vector<int>(9)); 
 
initializes the variable sudoku to a Vector of nine elements, each of which is itself 
a Vector of nine elements.  "
vector,"The declaration 
 
Vector< Vector<int> > sudoku(9, Vector<int>(9)); 
 
initializes the variable sudoku to a Vector of nine elements, each of which is itself 
a Vector of nine elements.  "
vector,"The declaration 
 
Vector< Vector<int> > sudoku(9, Vector<int>(9)); 
 
initializes the variable sudoku to a Vector of nine elements, each of which is itself 
a Vector of nine elements.  "
vector,"The base type of the inner vector is int, and the base 
type of the outer vector is Vector<int>.  "
vector,"The base type of the inner vector is int, and the base 
type of the outer vector is Vector<int>.  "
vector,"The base type of the inner vector is int, and the base 
type of the outer vector is Vector<int>.  "
vector,"The type of the whole assemblage is 
therefore 
 
Vector< Vector<int> > 
 
210     Collections 
Although some C++ compilers have been extended so that the spaces are optional, 
this declaration adheres to the C++ standard by including spaces around the inner 
type parameter.  "
vector,"The type of the whole assemblage is 
therefore 
 
Vector< Vector<int> > 
 
210     Collections 
Although some C++ compilers have been extended so that the spaces are optional, 
this declaration adheres to the C++ standard by including spaces around the inner 
type parameter.  "
vector,"If you instead write this declaration as 
 
Vector<Vector<int>> sudoku(9, Vector<int>(9));   
 
 
many C++ compilers will interpret the >> as a single operator and be unable to 
compile this line. 
 
"
vector,"If you instead write this declaration as 
 
Vector<Vector<int>> sudoku(9, Vector<int>(9));   
 
 
many C++ compilers will interpret the >> as a single operator and be unable to 
compile this line. 
 
"
vector,"If you instead write this declaration as 
 
Vector<Vector<int>> sudoku(9, Vector<int>(9));   
 
 
many C++ compilers will interpret the >> as a single operator and be unable to 
compile this line. 
 
"
vector,"The Grid class in the Stanford libraries 
Although using nested vectors makes it possible to represent two-dimensional 
structures, that strategy is by no means convenient.  "
vector,"The structure of the Stack class 
Like Vector and Grid, Stack is a collection class that requires you to specify the 
element type.  "
vector,"Suppose, 
for example, that you have an array—or equivalently a vector—containing a set of 
scores such as those you might assign for a gymnastics match: 
 
 
 
"
vector,"Moreover, if the package of collection classes is well designed, clients should 
be able to use the same strategy to perform that operation, no matter whether they 
are cycling through all elements in a vector or a grid, all keys in a map, or all words 
in a lexicon.  "
vector,"The classes you’ve already seen make the following 
guarantees about the order of values: 
 
• When you iterate through the elements of the Vector class, the range-based for 
loop delivers the elements in order by index position, so that the element in 
position 0 comes first, followed by the element in position 1, and so on, up to the 
 
Summary      239 
end of the vector.  "
vector,"The classes you’ve already seen make the following 
guarantees about the order of values: 
 
• When you iterate through the elements of the Vector class, the range-based for 
loop delivers the elements in order by index position, so that the element in 
position 0 comes first, followed by the element in position 1, and so on, up to the 
 
Summary      239 
end of the vector.  "
vector,"Thus, given the file Macbeth.txt, you would like 
your program to produce something like the following output: 
 
 
 
 Summary 
This chapter introduced the C++ classes Vector, Stack, Queue, Map, and Set that 
together represent a powerful framework for storing collections.  "
vector,"Given that you will 
be implementing them as you complete the text, the classes presented here have 
been simplified to some extent from the vector, stack, queue, map, and set 
classes in the Standard Template Library, although they export a very similar 
collection of methods.  "
vector,"For example, the class 
Vector<int> signifies a vector containing values of type int. 
"
vector,"For example, the class 
Vector<int> signifies a vector containing values of type int. 
"
vector,"The Vector class is an abstract data type that behaves in much the same fashion 
as a one-dimensional array but is much more powerful.  "
vector,"Unlike arrays, a Vector 
can grow dynamically as elements are added and removed.  "
vector,"They are also more 
secure, because the Vector class checks to make sure that selected elements 
exist.  "
vector,"Although you can use vectors of vectors to create two-dimensional 
structures, it is often easier to use the Grid class in the Stanford libraries. 
"
vector,"Although you can use vectors of vectors to create two-dimensional 
structures, it is often easier to use the Grid class in the Stanford libraries. 
"
vector,"If you want to use the Vector class in a program, what #include line do you 
need to add to the beginning of your code? 
 
"
vector,"5. 
List at least three advantages of the Vector class over the more primitive 
array mechanism available in C++. 
 
6. 
"
vector,"What type name would you use to store a vector of Boolean values? 
 
"
vector,"True or false: The default constructor for the Vector class creates a vector 
with ten elements, although you can make it longer later. 
 
"
vector,"True or false: The default constructor for the Vector class creates a vector 
with ten elements, although you can make it longer later. 
 
"
vector,"How would you initialize a Vector<int> with 20 elements, all equal to 0? 
 
11."
vector,"What method do you call to determine the number of elements in a Vector? 
 
"
vector,"If a Vector object has N elements, what is the legal range of values for the 
first argument to insertAt?  "
vector,"What feature of the Vector class makes it possible to avoid explicit use of the 
get and set methods? 
 
"
vector,"Why is it important to pass vectors and other collection object by reference? 
 
15."
vector,"Exercises 
1. 
Write the overloaded functions 
 
void readVector(istream & is, Vector<int> & vec); 
void readVector(istream & is, Vector<double> & vec); 
void readVector(istream & is, Vector<string> & vec); 
 
each of which reads lines from the input stream specified by is into the vector 
vec.  "
vector,"Exercises 
1. 
Write the overloaded functions 
 
void readVector(istream & is, Vector<int> & vec); 
void readVector(istream & is, Vector<double> & vec); 
void readVector(istream & is, Vector<string> & vec); 
 
each of which reads lines from the input stream specified by is into the vector 
vec.  "
vector,"Exercises 
1. 
Write the overloaded functions 
 
void readVector(istream & is, Vector<int> & vec); 
void readVector(istream & is, Vector<double> & vec); 
void readVector(istream & is, Vector<string> & vec); 
 
each of which reads lines from the input stream specified by is into the vector 
vec.  "
vector,"Exercises 
1. 
Write the overloaded functions 
 
void readVector(istream & is, Vector<int> & vec); 
void readVector(istream & is, Vector<double> & vec); 
void readVector(istream & is, Vector<string> & vec); 
 
each of which reads lines from the input stream specified by is into the vector 
vec.  "
vector,"In the input stream, each element of the vector appears on a line of its 
own.  "
vector,"In addition, 
suppose that you have declared the variable roots as follows: 
 
Vector<double> roots; 
 
The first call to readVector(infile, roots) should initialize roots so 
that it contains the four elements shown at the beginning of the file.  "
vector,"Calling readVector a third time 
should set roots to an empty vector. 
 
"
vector,"Write a function 
 
double mean(Vector<double> & data); 
 
that returns the mean of the data in the vector. 
 
"
vector,"When you generate histograms using a computer, however, it is much 
easier to display them sideways on the page, as in this sample run: 
 
 
 
Write a program that reads in a vector of integers from a data file and then 
displays a histogram of those numbers, divided into the ranges 0–9, 10–19, 
20–29, and so forth, up to the range containing only the value 100.  "
vector,"One of the problems in using the Grid class is that it isn’t as easy to set up a 
particular set of initial values as it is with a vector, where you can add the 
250     Collections 
elements you want with the += operator.  "
vector,"One way to streamline the process of 
initializing a grid is to define a function 
 
void fillGrid(Grid<int> & grid, Vector<int> & values); 
 
that fills the elements of the grid from the values in the vector.  "
vector,"One way to streamline the process of 
initializing a grid is to define a function 
 
void fillGrid(Grid<int> & grid, Vector<int> & values); 
 
that fills the elements of the grid from the values in the vector.  "
vector,"For example, 
the code 
 
Grid<int> matrix(3, 3); 
Vector<int> values; 
values += 1, 2, 3; 
values += 4, 5, 6; 
values += 7, 8, 9; 
fillGrid(matrix, values); 
 
initializes the variable matrix to be a 3!3 grid containing the values 
 
 
 
8. 
"
vector,"What you need to do instead is to make the inverted 
map a Map< string,Vector<int> > that maps each state name to a vector 
260     Collections 
of the area codes that serve that state.  "
vector,"What you need to do instead is to make the inverted 
map a Map< string,Vector<int> > that maps each state name to a vector 
260     Collections 
of the area codes that serve that state.  "
vector,"You could, for example, have the token scanner return a 
vector containing the entire list of tokens.  "
vector,"That strategy, however, isn’t appropriate 
for applications that work with large input file, because the scanner has to create a 
single vector containing the entire list of tokens.  "
vector,"In this exercise, for example, you get to have some 
fun with a vector of GPoint objects.  "
vector,"To model this process using the 
graphics window, what you want to do is create a Vector<GPoint> that 
holds the coordinates of each of these pegs, which are inserted into the vector 
starting at the upper right and then proceeding clockwise around the edges of 
the rectangle, as follows: 
 
 
 
From here, you create a figure by drawing lines between the pegs, starting 
at peg 0 and then moving ahead a fixed number of spaces on each cycle, as 
specified by the constant DELTA.  "
vector,"To model this process using the 
graphics window, what you want to do is create a Vector<GPoint> that 
holds the coordinates of each of these pegs, which are inserted into the vector 
starting at the upper right and then proceeding clockwise around the edges of 
the rectangle, as follows: 
 
 
 
From here, you create a figure by drawing lines between the pegs, starting 
at peg 0 and then moving ahead a fixed number of spaces on each cycle, as 
specified by the constant DELTA.  "
vector,"The binary search algorithm 
When you work with sequences of values stored in a vector, one of the common 
operations consists of searching that vector for a particular element.  "
vector,"The binary search algorithm 
When you work with sequences of values stored in a vector, one of the common 
operations consists of searching that vector for a particular element.  "
vector,"For example, if 
you work frequently with string vectors, it is useful to have a function 
 
int findInVector(string key, Vector<string> & vec); 
 
that searches through each of the elements of vec, looking for an element whose 
value is equal to key.  "
vector,"For example, if 
you work frequently with string vectors, it is useful to have a function 
 
int findInVector(string key, Vector<string> & vec); 
 
that searches through each of the elements of vec, looking for an element whose 
value is equal to key.  "
vector,"Although the pattern is easiest 
to recognize when you are working with sets, it also comes up in applications 
involving vectors and strings, and you should be on the lookout for it in those 
situations as well. 
 
 "
vector,"With these you can easily 
measure out 4 ounces, as shown: 
 
 
 
It is somewhat more interesting to discover that you can also measure out 2 
ounces by shifting the 1-ounce weight to the other side, as follows: 
 
 
 
Write a recursive function 
 
bool isMeasurable(int target, Vector<int> & weights) 
 
that determines whether it is possible to measure out the desired target amount 
with a given set of weights, which is stored in the vector weights. 
 
"
vector,"With these you can easily 
measure out 4 ounces, as shown: 
 
 
 
It is somewhat more interesting to discover that you can also measure out 2 
ounces by shifting the 1-ounce weight to the other side, as follows: 
 
 
 
Write a recursive function 
 
bool isMeasurable(int target, Vector<int> & weights) 
 
that determines whether it is possible to measure out the desired target amount 
with a given set of weights, which is stored in the vector weights. 
 
"
vector,"For example, suppose that sampleWeights has been initialized like this: 
 
Vector<int> sampleWeights; 
sampleWeights += 1, 3; 
 
Given these values, the function call 
 
isMeasurable(2, sampleWeights) 
 
should return true because it is possible to measure out 2 ounces using the 
sample weight set as illustrated in the preceding diagram.  "
vector,"As a second example, the cards 
 
 
 
contain the following eight different combinations that add up to 15: 
 
5C + JC 
5D + JC 
5H + JC 
5S + JC 
5C + 5D + 5H 
5C + 5D + 5S 
5C + 5H + 5S 
5D + 5H + 5S 
 
Write a function 
 
int countFifteens(Vector<Card> & cards); 
 
that takes a vector of Card values (as defined in Chapter 6, exercise 2) and 
returns the number of ways you can make 15 from that set of cards.  "
vector,"The generateMoveList method fills the moveList vector with the legal 
moves available in the current state. 
"
vector,"Following the logic of solveMaze, write a function 
 
bool findSolutionPath(Maze & maze, Point start, 
                      Vector<Point> & path); 
 
 
Exercises      419 
 
that takes, in addition to the coordinates of the starting position, a vector of 
Point values called path.  "
vector,"Following the logic of solveMaze, write a function 
 
bool findSolutionPath(Maze & maze, Point start, 
                      Vector<Point> & path); 
 
 
Exercises      419 
 
that takes, in addition to the coordinates of the starting position, a vector of 
Point values called path.  "
vector,"In addition, the 
findSolutionPath function initializes the elements of the path vector to a 
sequence of coordinates beginning with the starting position and ending with 
the coordinates of the first square that lies outside the maze.  "
vector,"Given this 
class, write a recursive function 
 
bool formsDominoChain(Vector<Domino> & dominos); 
 
that returns true if it possible to build a chain consisting of every domino in 
the vector. 
 
"
vector,"Your job is to write a recursive function 
 
int cutStock(Vector<int> & requests, int stockLength); 
 
that takes two arguments—a vector of the lengths needed and the length of 
stock pipe that the distributor sells—and returns the minimum number of stock 
pipes needed to service all requests in the vector.  "
vector,"Your job is to write a recursive function 
 
int cutStock(Vector<int> & requests, int stockLength); 
 
that takes two arguments—a vector of the lengths needed and the length of 
stock pipe that the distributor sells—and returns the minimum number of stock 
pipes needed to service all requests in the vector.  "
vector,"For example, if the vector 
contains [ 4, 3, 4, 1, 7, 8 ] and the stock pipe length is 10, you can purchase 
three stock pipes and divide them as follows: 
 
"
vector,"As an example, you can 
form the word programming using the following sequence of cubes: 
 
 
 
Write a function 
 
void findBoggleWords(const Grid<char> & board, 
                     const Lexicon & english, 
                     Vector<string> & wordsFound); 
 
that finds all the legal words on the board that appear in the english lexicon 
and adds those words to the vector wordsFound. 
 
 
 
 
 
 
 
"
vector,"As an example, you can 
form the word programming using the following sequence of cubes: 
 
 
 
Write a function 
 
void findBoggleWords(const Grid<char> & board, 
                     const Lexicon & english, 
                     Vector<string> & wordsFound); 
 
that finds all the legal words on the board that appear in the english lexicon 
and adds those words to the vector wordsFound. 
 
 
 
 
 
 
 
"
vector,"Of these, 
one of the most interesting is the problem of sorting, which consists of reordering 
the elements in an array or vector so that they fall in some defined sequence.  "
vector,"For 
example, suppose you have stored the following integers in the variable vec, which 
is a Vector<int>: 
 
 
 
 
"
vector,"The selection sort algorithm 
There are many algorithms you could choose to sort a vector of integers into 
ascending order.  "
vector,"Given a vector of size 
N, the selection sort algorithm goes through each element position and finds the 
value that should occupy that position in the sorted vector.  "
vector,"Given a vector of size 
N, the selection sort algorithm goes through each element position and finds the 
value that should occupy that position in the sorted vector.  "
vector,"Thus, on the first 
cycle, the algorithm finds the smallest element and swaps it with the first vector 
position.  "
vector,"Thereafter, the algorithm continues this strategy until all 
positions in the vector are correctly ordered.  "
vector,"432     Algorithmic Analysis 
 
 
For example, if the initial contents of the vector are 
 
 
 
the first cycle through the outer for loop identifies the 19 in index position 5 as the 
smallest value in the entire vector and then swaps it with the 56 in index position 0 
to leave the following configuration: 
 
 
 
On the second cycle, the algorithm finds the smallest element between positions 1 
and 7, which turns out to be the 25 in position 1.  "
vector,"432     Algorithmic Analysis 
 
 
For example, if the initial contents of the vector are 
 
 
 
the first cycle through the outer for loop identifies the 19 in index position 5 as the 
smallest value in the entire vector and then swaps it with the 56 in index position 0 
to leave the following configuration: 
 
 
 
On the second cycle, the algorithm finds the smallest element between positions 1 
and 7, which turns out to be the 25 in position 1.  "
vector,"The program goes ahead and 
performs the exchange operation, leaving the vector unchanged from the preceding 
diagram.  "
vector,"When the for loop 
is complete, the entire vector is sorted. 
 
"
vector,"To answer 
this question, it helps to collect empirical data about how long it takes the computer 
to sort a vector of various sizes.  "
vector,"When I did this experiment on my MacBook Pro 
laptop, I observed the following timing data for selection sort, where N represents 
the number of elements in the vector: 
 
N 
Running time 
 
10 
0.0000024 sec 
 
50 
0.0000448 sec 
 
100 
0.000169 sec 
 
500 
0.00402 sec 
 
1000 
0.0159 sec 
 
5000 
0.395 sec 
 
10,000 
1.58 sec 
 
50,000 
39.6 sec 
 100,000 
158.7 sec 
 
For a vector of 10 integers, the selection sort algorithm completes its work in a 
couple of microseconds.  "
vector,"When I did this experiment on my MacBook Pro 
laptop, I observed the following timing data for selection sort, where N represents 
the number of elements in the vector: 
 
N 
Running time 
 
10 
0.0000024 sec 
 
50 
0.0000448 sec 
 
100 
0.000169 sec 
 
500 
0.00402 sec 
 
1000 
0.0159 sec 
 
5000 
0.395 sec 
 
10,000 
1.58 sec 
 
50,000 
39.6 sec 
 100,000 
158.7 sec 
 
For a vector of 10 integers, the selection sort algorithm completes its work in a 
couple of microseconds.  "
vector,"As the vector sizes get larger, however, the performance of selection sort 
begins to go downhill.  "
vector,"For a vector of 100,000 integers, the algorithm requires 
 
10.1"
vector,"Even more disturbing is the fact that the performance of selection sort rapidly 
gets worse as the vector size increases.  "
vector,"As you can see from the timing data, every 
time you multiply the number of values by 10, the time required to sort the vector 
goes up a hundredfold.  "
vector,"If your business requires sorting vectors on 
this scale, you would have no choice but to find a more efficient approach. 
 
"
vector,"To correctly determine the first value in 
the vector, the selection sort algorithm must consider all N elements as it searches 
for the smallest value.  "
vector,"Thus, the time required on the first cycle of the loop is 
presumably proportional to N.  For each of the other elements in the vector, the 
algorithm performs the same basic steps but looks at one less element each time.  "
vector,"At its essence, the 
problem with selection sort is that doubling the size of the input vector increases the 
running time of the selection sort algorithm by a factor of four, which means that 
the running time grows more quickly than the number of elements in the vector. 
 
"
vector,"At its essence, the 
problem with selection sort is that doubling the size of the input vector increases the 
running time of the selection sort algorithm by a factor of four, which means that 
the running time grows more quickly than the number of elements in the vector. 
 
"
vector,"For most algorithms that 
operate on arrays or vectors, you can use the number of elements.  "
vector,"From the analysis in 
the section “Analyzing the performance of selection sort” earlier in the chapter, you 
know that the running time of the selection sort algorithm for a vector of N elements 
is proportional to 
 
 
10.2 Computational complexity      437 
 
 
 
Although it would be mathematically correct to use this formula directly in the 
big-O expression 
 
O(
) 
 
 
you would never do so in practice because the formula inside the parentheses is not 
expressed in the simplest form. 
 
"
vector,"Thus, if you double the size of the vector, the running time goes up by a 
438     Algorithmic Analysis 
 
factor of four.  "
vector,"Deducing computational complexity from code 
The following function computes the average of the elements in a vector: 
 
double average(Vector<double> & vec) { 
   int n = vec.size(); 
   double total = 0; 
   for (int i = 0;"
vector,"These 
computations take a certain amount of time, but that time is constant in the sense 
that it doesn’t depend on the size of the vector.  "
vector,"Although any single execution of this part of the 
computation takes a fixed amount of time, the fact that these statements are 
executed n times means their total execution time is directly proportional to the 
vector size.  "
vector,"For example, consider 
the function 
 
int linearSearch(int key, Vector<int> & vec) { 
   int n = vec.size(); 
   for (int i = 0; i < n; i++) { 
      if (key == vec[i]) return i; 
   } 
   return -1; 
} 
 
which returns the first index position in vec at which the value key appears, or –1 if 
the value key does not appear anywhere in the vector.  "
vector,"For example, consider 
the function 
 
int linearSearch(int key, Vector<int> & vec) { 
   int n = vec.size(); 
   for (int i = 0; i < n; i++) { 
      if (key == vec[i]) return i; 
   } 
   return -1; 
} 
 
which returns the first index position in vec at which the value key appears, or –1 if 
the value key does not appear anywhere in the vector.  "
vector,"Suppose, for example, that the key element you are searching for happens to be in 
the first position in the vector.  "
vector,"If you’re lucky enough to search for a value that always occurs at the 
beginning of the vector, linearSearch will run in constant time. 
 
"
vector,"The worst case for the linearSearch function occurs when the key is not in 
the vector at all.  "
vector,"If the key is known to 
be in the vector, the for loop will be executed about half as many times on average, 
which implies that average-case performance is also O(N).  "
vector,"However, you are no closer to solving the practical 
problem of how to write a sorting algorithm that is more efficient for large vectors.  
"
vector,"The same is true for most 
sorting algorithms that process the elements of the vector in a linear order.  "
vector,"This fact suggests that dividing a vector in half and then 
applying a recursive divide-and-conquer approach might reduce the required sorting 
time. 
 
"
vector,"To make this idea more concrete, suppose you have a large vector that you need 
to sort.  "
vector,"What happens if you divide the vector into two halves and then use the 
selection sort algorithm to sort each of those pieces?  "
vector,"Because selection sort is 
quadratic, each of the smaller vectors requires one quarter of the original time.  "
vector,"You 
need to sort both halves, of course, but the total time required to sort the two smaller 
vectors is still only half the time that would have been required to sort the original 
vector.  "
vector,"You 
need to sort both halves, of course, but the total time required to sort the two smaller 
vectors is still only half the time that would have been required to sort the original 
vector.  "
vector,"If it turns out that sorting two halves of a vector simplifies the problem of 
sorting the complete vector, you will be able to reduce the total time substantially.  
More importantly, once you discover how to improve performance at one level, you 
can use the same algorithm recursively to sort each half. 
 
"
vector,"If it turns out that sorting two halves of a vector simplifies the problem of 
sorting the complete vector, you will be able to reduce the total time substantially.  
More importantly, once you discover how to improve performance at one level, you 
can use the same algorithm recursively to sort each half. 
 
"
vector,"To determine whether a divide-and-conquer strategy is applicable to the sorting 
problem, you need to answer the question of whether dividing a vector into two 
smaller vectors and then sorting each one helps to solve the general problem.  "
vector,"To determine whether a divide-and-conquer strategy is applicable to the sorting 
problem, you need to answer the question of whether dividing a vector into two 
smaller vectors and then sorting each one helps to solve the general problem.  "
vector,"As a 
way to gain some insight into this question, suppose that you start with a vector 
containing the following eight elements: 
 
444     Algorithmic Analysis 
 
 
 
If you divide the vector of eight elements into two vectors of length four and then 
sort each of those smaller vectors—remember that the recursive leap of faith means 
you can assume that the recursive calls work correctly—you get the following 
situation in which each of the smaller vectors is sorted: 
 
 
 
How useful is this decomposition?  "
vector,"As a 
way to gain some insight into this question, suppose that you start with a vector 
containing the following eight elements: 
 
444     Algorithmic Analysis 
 
 
 
If you divide the vector of eight elements into two vectors of length four and then 
sort each of those smaller vectors—remember that the recursive leap of faith means 
you can assume that the recursive calls work correctly—you get the following 
situation in which each of the smaller vectors is sorted: 
 
 
 
How useful is this decomposition?  "
vector,"As a 
way to gain some insight into this question, suppose that you start with a vector 
containing the following eight elements: 
 
444     Algorithmic Analysis 
 
 
 
If you divide the vector of eight elements into two vectors of length four and then 
sort each of those smaller vectors—remember that the recursive leap of faith means 
you can assume that the recursive calls work correctly—you get the following 
situation in which each of the smaller vectors is sorted: 
 
 
 
How useful is this decomposition?  "
vector,"As a 
way to gain some insight into this question, suppose that you start with a vector 
containing the following eight elements: 
 
444     Algorithmic Analysis 
 
 
 
If you divide the vector of eight elements into two vectors of length four and then 
sort each of those smaller vectors—remember that the recursive leap of faith means 
you can assume that the recursive calls work correctly—you get the following 
situation in which each of the smaller vectors is sorted: 
 
 
 
How useful is this decomposition?  "
vector,"As a 
way to gain some insight into this question, suppose that you start with a vector 
containing the following eight elements: 
 
444     Algorithmic Analysis 
 
 
 
If you divide the vector of eight elements into two vectors of length four and then 
sort each of those smaller vectors—remember that the recursive leap of faith means 
you can assume that the recursive calls work correctly—you get the following 
situation in which each of the smaller vectors is sorted: 
 
 
 
How useful is this decomposition?  "
vector,"Remember that your goal is to take the values 
out of these smaller vectors and put them back into the original vector in the correct 
order.  "
vector,"Remember that your goal is to take the values 
out of these smaller vectors and put them back into the original vector in the correct 
order.  "
vector,"How does having these smaller sorted vectors help you in accomplishing that 
goal? 
 
"
vector,"Merging two vectors 
As it happens, reconstructing the complete vector from the smaller sorted vectors is 
a much simpler problem than sorting itself.  "
vector,"Merging two vectors 
As it happens, reconstructing the complete vector from the smaller sorted vectors is 
a much simpler problem than sorting itself.  "
vector,"Merging two vectors 
As it happens, reconstructing the complete vector from the smaller sorted vectors is 
a much simpler problem than sorting itself.  "
vector,"In this 
example, the first element you want in the new vector is the 19 in v2.  "
vector,"If you add 
that element to an empty vector vec and, in effect, cross it out of v2, you get the 
following configuration: 
 
 
 
Once again, the next element can only be the first unused element in one of the two 
smaller vectors.  "
vector,"If you add 
that element to an empty vector vec and, in effect, cross it out of v2, you get the 
following configuration: 
 
 
 
Once again, the next element can only be the first unused element in one of the two 
smaller vectors.  "
vector,"You can easily continue this process of choosing the smaller value from v1 or v2 
until you have reconstructed the entire vector. 
 
"
vector,Check to see if the vector is empty or has only one element.  
vector,"2. 
Divide the vector into two smaller vectors, each of which is half the size. 
"
vector,"2. 
Divide the vector into two smaller vectors, each of which is half the size. 
"
vector,"Sort each of the smaller vectors recursively. 
"
vector,"4. 
Clear the original vector so that it is again empty. 
"
vector,"5. 
Merge the two sorted vectors back into the original one. 
 
"
vector,"After checking for the special case, the algorithm divides 
the original vector into two smaller ones, v1 and v2.  "
vector,"As soon as the code for sort 
has copied all of the elements into either v1 or v2, the rest of the function sorts 
these vectors recursively, clears the original vector, and then calls merge to 
reassemble the complete solution. 
 
"
vector,"As soon as the code for sort 
has copied all of the elements into either v1 or v2, the rest of the function sorts 
these vectors recursively, clears the original vector, and then calls merge to 
reassemble the complete solution. 
 
"
vector,"Most of the work is done by the merge function, which takes the destination 
vector, along with the smaller vectors v1 and v2.  "
vector,"Most of the work is done by the merge function, which takes the destination 
vector, along with the smaller vectors v1 and v2.  "
vector,"The indices p1 and p2 mark the 
progress through each of the subsidiary vectors.  "
vector,"As soon as the elements in either of the two smaller 
vectors are exhausted, the function can simply copy the elements from the other 
vector without bothering to test them.  "
vector,"As soon as the elements in either of the two smaller 
vectors are exhausted, the function can simply copy the elements from the other 
vector without bothering to test them.  "
vector,"In fact, because one of these vectors is 
already exhausted when the first while loop exits, the function can simply copy the 
rest of each vector to the destination.  "
vector,"In fact, because one of these vectors is 
already exhausted when the first while loop exits, the function can simply copy the 
rest of each vector to the destination.  "
vector,"One of these vectors will be empty, and the 
corresponding while loop will therefore not be executed at all. 
"
vector,"You can measure its efficiency by sorting 
vectors of numbers and timing the result, but it is helpful to start by thinking about 
the algorithm in terms of its computational complexity. 
 
"
vector,"The time required to execute the recursive calls 
 
At the top level of the recursive decomposition, the cost of performing the 
nonrecursive operations is proportional to N.  The loop to fill the subsidiary vectors 
accounts for N cycles, and the call to merge has the effect of refilling the original N 
positions in the vector.  "
vector,"The time required to execute the recursive calls 
 
At the top level of the recursive decomposition, the cost of performing the 
nonrecursive operations is proportional to N.  The loop to fill the subsidiary vectors 
accounts for N cycles, and the call to merge has the effect of refilling the original N 
positions in the vector.  "
vector,"To sort a vector of size N, 
you must recursively sort two vectors of size N / 2.  "
vector,"To sort a vector of size N, 
you must recursively sort two vectors of size N / 2.  "
vector,"If you apply the same logic, you quickly determine 
that sorting each of these smaller vectors requires time proportional to N / 2 at that 
level, plus whatever time is required by its own recursive calls.  "
vector,"The same process 
then continues until you reach the simple case in which the vectors consist of a 
single element or no elements at all. 
 
"
vector,"In general, the decomposition has the 
structure shown in Figure 10-4.  As you move down through the recursive 
hierarchy, the vectors get smaller, but more numerous.  "
vector,"For large vectors, merge sort clearly represents a significant 
improvement. 
 
"
vector,"Sorting algorithms based on an N log N 
algorithm will therefore be useful over a much larger range of vector sizes. 
 
 "
vector,"In the 
merge sort algorithm, the original vector is divided into two halves, each of which is 
sorted independently.  "
vector,"The resulting sorted vectors are then merged together to 
complete the sort operation for the entire vector.  "
vector,"The resulting sorted vectors are then merged together to 
complete the sort operation for the entire vector.  "
vector,"Suppose, however, that you took a 
different approach to dividing up the vector.  "
vector,"What would happen if you started the 
process by making an initial pass through the vector, changing the positions of the 
elements so that “small” values come at the beginning of the vector and “large” 
values come at the end, for some definition of the words large and small? 
 
 
"
vector,"What would happen if you started the 
process by making an initial pass through the vector, changing the positions of the 
elements so that “small” values come at the beginning of the vector and “large” 
values come at the end, for some definition of the words large and small? 
 
 
"
vector,"The Quicksort algorithm      453 
 
For example, suppose that the original vector you wanted to sort was the 
following one, presented earlier in the discussion of merge sort: 
 
 
 
Half of these elements are larger than 50 and half are smaller, so it might make 
sense to define small in this case as being less than 50 and large as being 50 or 
more.  "
vector,"If you could then find a way to rearrange the elements so that all the small 
elements came at the beginning and all the large ones at the end, you would wind up 
with a vector that looks something like the following diagram, which shows one of 
many possible orderings that fit the definition: 
 
 
When the elements are divided into parts in this fashion, all that remains to be 
done is to sort each of the parts, using a recursive call to the function that does the 
sorting.  "
vector,"Since all the elements on the left side of the boundary line are smaller than 
all those on the right, the final result will be a completely sorted vector: 
 
 
 
If you could always choose the optimal boundary between the small and large 
elements on each cycle, this algorithm would divide the vector in half each time and 
end up demonstrating the same qualitative characteristics as merge sort.  "
vector,"Since all the elements on the left side of the boundary line are smaller than 
all those on the right, the final result will be a completely sorted vector: 
 
 
 
If you could always choose the optimal boundary between the small and large 
elements on each cycle, this algorithm would divide the vector in half each time and 
end up demonstrating the same qualitative characteristics as merge sort.  "
vector,"In practice, 
the Quicksort algorithm selects some existing element in the vector and uses that 
value as the dividing line between the small and large elements.  "
vector,"For example, a 
common approach is to pick the first element, which was 56 in the original vector, 
and use it as the demarcation point between small and large elements.  "
vector,"When the 
vector is reordered, the boundary is therefore at a particular index position rather 
than between two positions, as follows: 
 
 
 
From this point, the recursive calls must sort the vector between positions 0 and 3 
and the vector between positions 5 and 7, leaving index position 4 right where it is. 
 
"
vector,"When the 
vector is reordered, the boundary is therefore at a particular index position rather 
than between two positions, as follows: 
 
 
 
From this point, the recursive calls must sort the vector between positions 0 and 3 
and the vector between positions 5 and 7, leaving index position 4 right where it is. 
 
"
vector,"When the 
vector is reordered, the boundary is therefore at a particular index position rather 
than between two positions, as follows: 
 
 
 
From this point, the recursive calls must sort the vector between positions 0 and 3 
and the vector between positions 5 and 7, leaving index position 4 right where it is. 
 
"
vector,"454     Algorithmic Analysis 
 
As in merge sort, the simple case of the Quicksort algorithm is a vector of size 0 
or 1, which must already be sorted.  "
vector,"For the moment, it is 
sufficient to choose any element for this purpose, and the simplest strategy is to 
select the first element in the vector. 
"
vector,"2. 
Rearrange the elements in the vector so that large elements are moved toward 
the end of the vector and small elements toward the beginning.  "
vector,"2. 
Rearrange the elements in the vector so that large elements are moved toward 
the end of the vector and small elements toward the beginning.  "
vector,"This processing is 
called partitioning the vector and is discussed in detail in the next section. 
"
vector,"3. 
Sort the elements in each of the partial vectors.  "
vector,"Because all elements to the left 
of the pivot boundary are strictly less than all those to the right, sorting each of 
the vectors must leave the entire vector in sorted order.  "
vector,"Because all elements to the left 
of the pivot boundary are strictly less than all those to the right, sorting each of 
the vectors must leave the entire vector in sorted order.  "
vector,"Moreover, since the 
algorithm uses a divide-and-conquer strategy, these smaller vectors can be 
sorted using a recursive application of Quicksort. 
 
"
vector,"Partitioning the vector 
In the partition step of the Quicksort algorithm, the goal is to rearrange the elements 
so that they are divided into three classes: those that are smaller than the pivot; the 
pivot element itself, which is situated at the boundary position; and those elements 
that are at least as large as the pivot.  "
vector,"Use two index values, lh and rh, to record the 
index positions of the first and last elements in the rest of the vector, as shown: 
 
 
10.5"
vector,"If the lh and rh index values have not yet reached the same position, exchange 
the elements in those positions in the vector, which leaves it looking like this: 
 
 
 
5. 
"
vector,"Unless the chosen pivot just happened to be the smallest element in the entire 
vector (and the code includes a special check for this case), the point at which 
the lh and rh index positions coincide will be the small value that is furthest to 
the right in the vector.  "
vector,"Unless the chosen pivot just happened to be the smallest element in the entire 
vector (and the code includes a special check for this case), the point at which 
the lh and rh index positions coincide will be the small value that is furthest to 
the right in the vector.  "
vector,"The only remaining step is to exchange that value in this 
position with the pivot element at the beginning of the vector, as shown: 
 
456     Algorithmic Analysis 
 
 
 
 
Note that this configuration meets the requirements of the partitioning step.  
"
vector,"As long as the Quicksort algorithm chooses a pivot that is close to the 
median value in the vector, the partition step will divide the vector into roughly 
equal parts.  "
vector,"As long as the Quicksort algorithm chooses a pivot that is close to the 
median value in the vector, the partition step will divide the vector into roughly 
equal parts.  "
vector,"If the algorithm chooses its pivot value poorly, one of the two partial 
vectors may be much larger than the other, which defeats the purpose of the 
divide-and-conquer strategy.  "
vector,"In a vector with randomly chosen elements, Quicksort 
tends to perform well, with an average-case complexity of O(N log N).  "
vector,"In the worst 
458     Algorithmic Analysis 
 
case—which paradoxically consists of a vector that is already sorted—the 
performance degenerates to O(N2).  "
vector,"There are several strategies you can use to increase the likelihood that the pivot 
is in fact close to the median value in the vector.  "
vector,"Moreover, there is no distribution of the original vector that is 
always bad.  "
vector,"Given any input, choosing the pivot randomly ensures that the 
average-case performance for that vector would be O(N log N).  "
vector,"Another 
possibility, which is explored in more detail in exercise 6, is to select a few values, 
typically three or five, from the vector and choose the median of those values as the 
pivot. 
 
"
vector,"When sorting a vector of 
10,000 integers, for example, the Quicksort algorithm outperforms selection sort by 
a factor of almost 250; as the vector sizes get larger, the difference in efficiency 
between these algorithms will become even more pronounced. 
 
"
vector,"When sorting a vector of 
10,000 integers, for example, the Quicksort algorithm outperforms selection sort by 
a factor of almost 250; as the vector sizes get larger, the difference in efficiency 
between these algorithms will become even more pronounced. 
 
"
vector,"For algorithms that operate on large integers, the size of 
the integer provides an effective measure of problem size; for algorithms that 
operate on arrays or vectors, it usually makes sense to define the problem size as 
the number of elements. 
"
vector,"4. 
Suppose that you are using the selection sort algorithm to sort a vector of 250 
values and find that it takes 50 milliseconds to complete the operation.  "
vector,"What 
would you expect the running time to be if you used the same algorithm to sort 
a vector of 1000 values on the same machine? 
 
"
vector,"You go through each element in the vector in turn, as 
with the selection sort algorithm.  "
vector,"For example, if you consider again the data used in the sorting examples 
from this chapter, the first cycle of the insertion sort algorithm requires no 
work, because a vector of one element is always sorted: 
 
 
 
On the next cycle, you need to put 25 into the correct position with respect to 
the elements you have already seen, which means that you need to exchange 
the 56 and 25 to reach the following configuration: 
 
 
 
On the third cycle, you need to find where the value 37 should go.  "
vector,"Thus, the configuration after the third cycle looks like this: 
 
 
 
After each cycle, the initial portion of the vector is always sorted, which 
implies that cycling through all the positions in this way will sort the entire 
vector. 
 
"
vector,"Thus, the configuration after the third cycle looks like this: 
 
 
 
After each cycle, the initial portion of the vector is always sorted, which 
implies that cycling through all the positions in this way will sort the entire 
vector. 
 
"
vector,"The insertion sort algorithm is important in practice because it runs in 
linear time if the vector is already more or less in the correct order.  "
vector,"It 
therefore makes sense to use insertion sort to restore order to a large vector in 
which only a few elements are out of sequence. 
 
"
vector,"3. 
Write a function that keeps track of the elapsed time as it executes the sort 
procedure on a randomly chosen vector.  "
vector,"The reason is that the processing unit on most machines can execute many 
instructions in the space of a single clock tick—almost certainly enough to get 
the entire sorting process done for a vector of 10 elements.  "
vector,"Write a program that generates a table comparing the performance of two 
algorithms—linear and binary search—when used to find a randomly chosen 
integer key in a sorted Vector<int>.  "
vector,"The linear search algorithm simply 
goes through each element of the vector in turn until it finds the desired one or 
determines that the key does not appear.  "
vector,"The binary search algorithm, which 
is implemented for string vectors in Figure 7-5, uses a divide-and-conquer 
 
Exercises      469 
 
strategy by checking the middle element of the vector and then deciding which 
half of the remaining elements to search. 
 
"
vector,"The binary search algorithm, which 
is implemented for string vectors in Figure 7-5, uses a divide-and-conquer 
 
Exercises      469 
 
strategy by checking the middle element of the vector and then deciding which 
half of the remaining elements to search. 
 
"
vector,"The table you generate in this problem, rather than computing the time as 
in exercise 3, should instead calculate the number of comparisons made 
against elements of the vector.  "
vector,"Change the implementation of the Quicksort algorithm so that, instead of 
picking the first element in the vector as the pivot, the partition function 
chooses the median of the first, middle, and last elements. 
 
"
vector,"Although O(N log N) sorting algorithms are clearly more efficient than O(N2) 
algorithms for large vectors, the simplicity of quadratic algorithms like 
selection sort often means that they perform better for small values of N.  This 
fact raises the possibility of developing a strategy that combines the two 
algorithms, using Quicksort for large vectors but selection sort whenever the 
vectors become less than some threshold called the crossover point.  
"
vector,"Although O(N log N) sorting algorithms are clearly more efficient than O(N2) 
algorithms for large vectors, the simplicity of quadratic algorithms like 
selection sort often means that they perform better for small values of N.  This 
fact raises the possibility of developing a strategy that combines the two 
algorithms, using Quicksort for large vectors but selection sort whenever the 
vectors become less than some threshold called the crossover point.  
"
vector,"Although O(N log N) sorting algorithms are clearly more efficient than O(N2) 
algorithms for large vectors, the simplicity of quadratic algorithms like 
selection sort often means that they perform better for small values of N.  This 
fact raises the possibility of developing a strategy that combines the two 
algorithms, using Quicksort for large vectors but selection sort whenever the 
vectors become less than some threshold called the crossover point.  
"
vector,"Another interesting hybrid strategy for the sorting problem is to start with a 
recursive implementation of Quicksort that simply returns when the size of the 
vector falls below a certain threshold.  "
vector,"When this function returns, the vector is 
not sorted, but all the elements are relatively close to their final positions.  "
vector,"At 
470     Algorithmic Analysis 
 
this point, you can use the insertion sort algorithm presented in exercise 2 on 
the entire vector to fix any remaining problems.  "
vector,"Because insertion sort runs in 
linear time on vectors that are mostly sorted, you may be able to save some 
time using this approach. 
 
"
vector,"If you’re ready for a real algorithmic challenge, write the function 
 
int findMajorityElement(Vector<int> & vec); 
 
that takes a vector of nonnegative integers and returns the majority element, 
which is defined to be a value that occurs in an absolute majority (at least 50 
percent plus one) of the element positions.  "
vector,"In other words, it may use individual 
temporary variables but may not allocate any additional array or vector 
storage.  "
vector,"• It may not change any of the values in the vector. 
 
"
vector,"Play with some sample vectors and see if you can come up 
with the right strategy. 
 
"
vector,"Suppose that you have a vector 
of N elements, in which each element has a value in the inclusive range 1 to 
472     Algorithmic Analysis 
 
N–1.  "
vector,"Given that there are N elements in the vector and only N–1 possible 
values to store in each slot, there must be at least one value that is duplicated 
in the vector.  "
vector,"Given that there are N elements in the vector and only N–1 possible 
values to store in each slot, there must be at least one value that is duplicated 
in the vector.  "
vector,"Your task in this problem is to write a function 
 
int findDuplicate(Vector<int> vec); 
 
that takes a vector whose values are constrained to be in the 1 to N–1 range 
and returns one of the duplicated values.  "
vector,"In other words, it may use individual 
temporary variables but may not allocate any additional array or vector 
storage.  "
vector,"• It may not change any of the values in the vector. 
 
"
vector,"When the Vector class first appeared in Chapter 5, the introduction to that section 
described vectors in terms of arrays, noting that you were likely to have some idea 
about arrays from your previous programming experience.  "
vector,"When the Vector class first appeared in Chapter 5, the introduction to that section 
described vectors in terms of arrays, noting that you were likely to have some idea 
about arrays from your previous programming experience.  "
vector,"C++ offers a built-in 
array type, which is based on the language model that C++ inherits from C.  Given 
that the Vector collection class is uniformly more flexible and convenient, there 
are few reasons to use arrays in new code, although you will certainly encounter 
arrays in existing applications. 
 
"
vector,"Given, however, that you are already familiar with the Vector class, it’s probably 
easiest to think of arrays as a primitive implementation of the vector idea.  "
vector,"Given, however, that you are already familiar with the Vector class, it’s probably 
easiest to think of arrays as a primitive implementation of the vector idea.  "
vector,"As with 
 
11.3 Arrays     495 
vectors, arrays are composed of individual elements of some base type selected by 
an integer index.  "
vector,"The pictures one draws to represent a vector almost certainly work 
for arrays as well.  "
vector,"The real difference is that arrays have the following limitations that make 
them less useful in practice than the more powerful vector type: 
 
"
vector,"As with the elements in a vector, the index numbers for an array always begin with 
0 and run up to the array size minus one.  "
vector,"The 
process of identifying a particular element within an array is called selection, and is 
indicated in C++ by writing the name of the array and following it with the index 
written in square brackets, just as if you are selecting an element from a vector. 
 
"
vector,"As in a vector, each element in an array 
has an integer index that begins with 0. 
"
vector,"A sample run of this program might look like this: 
 
 
 
7. 
Rewrite the implementation of the merge sort algorithm from Figure 10-3 so 
that it sorts an array rather than a vector.  "
vector,"There is no arbitrary limit on the 
size of a Vector or a Map.  "
vector,"The 
Vector class introduced in Chapter 5 is almost always a better choice in practice, 
primarily because the Vector class performs its own memory management, thereby 
relieving you of that responsibility. 
 
"
vector,"The 
Vector class introduced in Chapter 5 is almost always a better choice in practice, 
primarily because the Vector class performs its own memory management, thereby 
relieving you of that responsibility. 
 
"
vector,"As you think about what such a structure might look like, one idea you will 
probably consider is to use a Vector<char> to hold the elements of the stack.  
"
vector,"Vectors grow dynamically, which is just what you need for this application.  "
vector,"In fact, 
using Vector<char> as the underlying representation makes the implementation 
extremely easy, as shown in Figures 12-5 and 12-6. 
 
 
 
12.4 Defining a CharStack class     531 
Vector-based charstack.cpp 
532     Dynamic Memory Management 
Choosing Vector<char> as the underlying representation shows just the right 
instincts.  "
vector,"In fact, 
using Vector<char> as the underlying representation makes the implementation 
extremely easy, as shown in Figures 12-5 and 12-6. 
 
 
 
12.4 Defining a CharStack class     531 
Vector-based charstack.cpp 
532     Dynamic Memory Management 
Choosing Vector<char> as the underlying representation shows just the right 
instincts.  "
vector,"In fact, 
using Vector<char> as the underlying representation makes the implementation 
extremely easy, as shown in Figures 12-5 and 12-6. 
 
 
 
12.4 Defining a CharStack class     531 
Vector-based charstack.cpp 
532     Dynamic Memory Management 
Choosing Vector<char> as the underlying representation shows just the right 
instincts.  "
vector,"Moreover, as 
a software-engineering strategy, there is absolutely nothing wrong with using 
vectors to implement stacks.  "
vector,"The only problem is that using Vector compromises the instructional value of the 
example.  "
vector,"Implementing vectors turns out to be considerably more complicated than 
implementing stacks.  "
vector,"Using Vector as the underlying representation does nothing 
to demystify the operation of the CharStack class, but merely hides the mystery 
under a somewhat larger stone. 
 
"
vector,"Perhaps more importantly, relying on the Vector class makes it harder to 
analyze the performance of the CharStack class because the Vector class hides so 
much complexity.  "
vector,"Perhaps more importantly, relying on the Vector class makes it harder to 
analyze the performance of the CharStack class because the Vector class hides so 
much complexity.  "
vector,"Because you don’t yet know how the Vector class works in 
detail, you have no idea how much work is involved in adding or deleting an 
element, as the push and pop methods require.  "
vector,"The most significant change from the vector-based implementation occurs in the 
push method, which adds a new character to the top of the stack.  "
vector,"If k is outside the 
vector bounds, get should call error with an appropriate message. 
"
vector,"Because the buffer contains an ordered sequence of 
characters, one seemingly obvious choice is to use a string or a Vector<char> 
as the underlying representation.  "
vector,"That point is 
difficult to make if you use higher-level structures like string and Vector 
because the inner workings of those classes are not visible to clients.  "
vector,"— Jane Austen, Persuasion, 1818 
616     Linear Structures 
The Stack, Queue, and Vector classes introduced in Chapter 5 are examples of a 
general category of abstract data types called linear structures, in which the 
elements are arranged in a linear order.  "
vector,"Stacks, 
queues, and vectors can also be implemented using a linked list much like the one 
used to implement the editor buffer in Chapter 13.  "
list,"To illustrate more 
of the features of C++, Figure 1-3 shows the code for a program that lists powers of 
two along with some annotations that describe the various parts of the program. 
 
"
list,"If you type in 8, for example, the program will 
generate a list of the powers of two up to 28, as follows: 
 
 
 
"
list,"""This program lists powers of two."""
list,"The usual syntax for declaring a variable is 
 
type namelist; 
 
where type indicates the data type and namelist is a list of variable names separated 
by commas.  "
list,"The name must not be one of the reserved keywords listed in Table 1-1. 
 
Uppercase and lowercase letters appearing in an identifier are considered to be 
different.  "
list,"If you use the type name string in a program, you need to add the 
string library to the list of #include lines, like this: 
 
#include <string> 
 
Moreover, because the string type is part of the standard library namespace, the 
compiler will recognize the type name only if you have included the line 
 
using namespace std; 
 
at the beginning of the file, as the programs in this book invariably do. 
 
"
list,"C++ allows you to define new types simply by listing 
the elements in their domain.  "
list,"The syntax for defining an enumerated type is 
 
enum typename { namelist }; 
 
where typename is the name of the new type and namelist is a list of the constants in 
the domain, separated by commas.  "
list,"A list of the operators available in C++ appears in 
Table 1-4.  "
list,"Precedence and associativity 
The point of listing all the operators in a single table is to establish how they relate 
to one another in terms of precedence, which is a measure of how tightly an 
operator binds to its operands in the absence of parentheses.  "
list,"The precedence of the unary and binary versions of an operator are 
different and are listed separately in the precedence table. 
 
"
list,"These operators are listed in decreasing order of precedence. 
 
"
list,"The AddIntegerList program in 
Figure 1-5 uses the read-until-sentinel pattern to compute the sum of a list of 
integers terminated by the sentinel value 0. 
 
"
list,"A list of the C++ 
operators appears in Table 1-4 along with their precedence and associativity. 
"
list,"List all possible values of type bool. 
 
"
list,"Write a program that reads in a list of integers from the user until the user 
enters the value 0 as a sentinel.  "
list,"When the sentinel appears, your program 
should display the largest value in the list, as illustrated in the following sample 
run: 
 
 
 
Be sure to define the sentinel value as a constant in a way that makes it easy to 
change.  "
list,"6. 
For a slightly more interesting challenge, write a program that finds both the 
largest and the second-largest number in a list, prior to the entry of a sentinel.  
"
list,"7. 
Using the AddIntegerList program from Figure 1-5 as a model, write a 
program AverageList that reads in a list of integers representing exam scores 
and then prints out the average."
list,"To specify a function call in C++, you write the name of the 
function, followed by a list of expressions enclosed in parentheses.  "
list,"} 
 
In this example, type is the type returned by the function, name is the function name, 
and parameters is a list of declarations separated by commas, giving the type and 
name of each parameter to the function.  "
list,"If a function takes no parameters, the 
entire parameter list in the function header line is empty. 
 
"
list,"Any default parameters must appear at the end of the parameter list. 
 
"
list,"The 
standard approach to solving the problem is to turn that function into a procedure 
and pass values back and forth through the argument list. 
 
"
list,"The association of arguments and parameters always follows the order in which 
the variables appear in each of the lists. 
"
list,"What criteria does this chapter list as important in the process of interface 
design? 
 
 
"
list,"To test your algorithm, write a main program that lists the prime 
numbers between 1 and 100. 
 
7. 
"
list,"The object-oriented version of the statement that sets nChars to the length of the 
string object str is therefore 
 
int nChars = str.length(); 
 
Table 3-1 lists the most common methods exported by the <string> library, all of 
which use the receiver syntax. 
 
"
list,"You can see on this list 
several functions whose definitions appear in this chapter.  "
list,"The output of the program is shown in Figure 4-2. 
164     Streams 
Program listing for PrecisionExample. 
 
"
list,"If necessary, you can change this behavior by using the skipws 
and noskipws manipulators, which appear in the list of input manipulators in 
Table 4-2.  "
list,"The simplest strategy is to use the first form of the get method listed in 
Table 4-3, which stores the next character from the stream in a variable passed by 
reference, as shown in the following code that reads the first character from the 
infile stream into the variable ch: 
 
char ch; 
infile.get(ch); 
 
For most applications, of course, the goal is not to read a single character, but 
instead to read successive characters, one at a time, as you go through the file.  "
list,"PowersOfTwo
This program lists powers of two.
"
list,"Although it is possible to list the contents of each of those interfaces in tables of 
the sort you have already seen for the standard libraries, most modern interfaces are 
not described on paper.  "
list,"The 
most important methods that apply to file streams are listed in Table 4-3. 
•"
list,"The numeric columns should all be aligned on the right, and the columns 
containing the trigonometric functions (which are listed here for angles at 
15-degree intervals) should all have seven digits after the decimal point. 
 
"
list,"As an example, the following code writes out the contents of the vector vec as a 
comma-separated list enclosed in square brackets: 
 
cout <<"
list,"For this reason, both of these functions—along with many other 
useful functions for working with files—are included in the filelib.h library 
listed in Appendix A. 
 
Creating a Vector of a predefined size 
The examples you have seen up to this point start out with an empty vector and then 
add elements to it, one at a time.  "
list,"The two versions of the Vector 
constructor appear—along with a complete list of the Vector methods—in 
Table 5-1. 
 
"
list,"The list of entries 
exported by the stack.h interface appears in Table 5-3. 
 
 
"
list,"The list of entries in 
Table 5-4 bears out that supposition.  "
list,"The data you need is in the form of a text file called AirportCodes.txt, which 
contains a list of the several thousand airport codes that IATA has assigned.  "
list,"This function makes it very easy to define sets like the set of 
punctuation characters simply by listing the characters that fit that description. 
 
"
list,"Creating a word list 
In the discussion of the Map class earlier in the chapter, one of the examples used to 
explain the underlying concept was that of a dictionary in which the keys were 
individual words and the corresponding values were the definitions.  "
list,"The library distribution also includes a data file called EnglishWords.dat that 
contains a compiled representation of a lexicon containing a reasonably complete 
list of English words.  "
list,"Given that you have a lexicon containing 
English words, you could create such a list by generating all two-letter strings and 
then using the lexicon to check which of the resulting combinations are actually 
words.  "
list,"5.6 Iterating over a collection 
The TwoLetterWords program introduced in Figure 5-9 produces a list of the 
two-letter words by generating every possible combination of two letters and then 
looking up each one to see whether that two-letter string appears in the lexicon of 
English words.  "
list,"Given the range-based for loop and the 
translateWord function from the PigLatin program from Chapter 3, it is easy 
to write a program that lists all such words, as shown in Figure 5-10. 
 
240     Collections 
Computing word frequencies 
The WordFrequency program in Figure 5-11 is another application in which 
iteration plays an important role.  "
list,"5. 
List at least three advantages of the Vector class over the more primitive 
array mechanism available in C++. 
 
6. 
"
list,"6. 
In the third century B.C.E., the Greek astronomer Eratosthenes developed an 
algorithm for finding all the prime numbers up to some upper limit N.  To 
apply the algorithm, you start by writing down a list of the integers between 2 
and N.  "
list,"For example, if N were 20, you would begin by writing the following 
list: 
 
 
 
You then circle the first number in the list, indicating that you have found a 
prime.  "
list,"For example, if N were 20, you would begin by writing the following 
list: 
 
 
 
You then circle the first number in the list, indicating that you have found a 
prime.  "
list,"Whenever you mark a number as a prime, you go through the rest of 
the list and cross off every multiple of that number, since none of those 
multiples can itself be prime.  "
list,"Thus, after executing the first cycle of the 
algorithm, you will have circled the number 2 and crossed off every multiple 
of 2, as follows: 
 
 
 
To complete the algorithm, you simply repeat the process by circling the 
first number in the list that is neither crossed off nor circled, and then crossing 
off its multiples.  "
list,"In this example, you would circle 3 as a prime and cross off 
all multiples of 3 in the rest of the list, which results in the following state: 
 
 
 
Eventually, every number in the list will either be circled or crossed out, as 
shown in this diagram: 
 
 
 
"
list,"In this example, you would circle 3 as a prime and cross off 
all multiples of 3 in the rest of the list, which results in the following state: 
 
 
 
Eventually, every number in the list will either be circled or crossed out, as 
shown in this diagram: 
 
 
 
"
list,"Write a program that uses the sieve of Eratosthenes to generate a list of the 
primes between 2 and 1000. 
 
"
list,"This rule makes 
it possible to list the geographical locations of each area code in a data file.  
"
list,"For this problem, assume that you have access to the file AreaCodes.txt, 
which lists all the area codes paired with their locations as illustrated by the 
first few lines of that file: 
 
 
Exercises      259 
 
 
Using the AirportCodes program as a model, write the code necessary to 
read this file into a Map<int,string>, where the key is the area code and the 
value is the location.  "
list,"Once you’ve read in the data, write a main program that 
repeatedly asks the user for an area code and then looks up the corresponding 
location, as illustrated in the following sample run: 
 
 
 
As the prompt suggests, however, your program should also allow users to 
enter the name of a state or province and have the program list all the area 
codes that serve that area, as illustrated by the following sample run: 
 
 
 
20."
list,"When you wrote the FindAreaCode program for the previous exercise, it is 
likely that you generated the list of area codes for a state by looping through 
the entire map and printing out any area codes that mapped to that state.  
"
list,"Rewrite the FindAreaCode program so 
that it creates an inverted map after reading in the data file and then uses that 
map to list the area codes for a state. 
 
"
list,"Use that function together with the 
English lexicon to print out a list of all words that are palindromes. 
 
"
list,"In Scrabble, knowing the two-letter word list is important because those short 
words make it easy to “hook” a new word into tiles already on the board.  
"
list,"Another list that Scrabble experts memorize is the list of three-letter words 
that can be formed by adding a letter to the front or back of a two-letter word.  
"
list,"Another list that Scrabble experts memorize is the list of three-letter words 
that can be formed by adding a letter to the front or back of a two-letter word.  
"
list,"Write a program that generates this list. 
 
"
list,"Write a 
program that uses the English lexicon to make a list of all such words. 
 
"
list,"The 
default constructor is used to initialize an object declared without specifying a 
parameter list.  "
list,"You could, for example, have the token scanner return a 
vector containing the entire list of tokens.  "
list,"That strategy, however, isn’t appropriate 
for applications that work with large input file, because the scanner has to create a 
single vector containing the entire list of tokens.  "
list,"Being able to share access to such data among all the methods 
in the class substantially reduces the size and complexity of the parameter lists, 
which in this example shrink from three parameters to zero. 
 
"
list,"By looking at the list of terms in the sequence 
 
 
t0 
t1 
t2 
t3 
t4 
t5 
t6 
t7 
t8 
t9 
 
 
3 
7 
10 
17 
27 
44 
71 
115 
186 
301 
. . . 
 
"
list,"If you enter the string ""aeinrst"", you get the 
following output—a list that serious Scrabble players will recognize instantly: 
 
 
368     Recursive Strategies 
 8.4 Graphical recursion 
Some of the most exciting applications of recursion use graphics to create intricate 
pictures in which a particular motif is repeated at many different scales.  "
list,"Use this strategy to implement a function 
 
void listPermutations(string str); 
 
that lists on cout all permutations of the string str without generating any 
sets at all or applying any string methods other than length or selection.  "
list,"The interesting challenge comes in 
adapting the structure of the algorithm so that it lists each unique permutation 
exactly once without using sets to accomplish that task.  "
list,"For example, the call 
 
listMnemonics(""723"") 
 
should list the following 36 possible letter combinations that correspond to 
that prefix: 
 
PAD PBD PCD QAD QBD QCD RAD RBD RCD SAD SBD SCD 
PAE PBE PCE QAE QBE QCE RAE RBE RCE SAE SBE SCE 
PAF PBF PCF QAF QBF QCF RAF RBF RCF SAF SBF SCF 
 
11."
list,"Rewrite the program from exercise 4 so that it uses the Lexicon class and the 
EnglishWords.dat file so that the program only lists mnemonics that are 
valid English words. 
 
"
list,"If you want to program a computer to take one side of a two-player game, one 
approach is to have the computer follow all the branches in the list of possibilities.  
"
list,"Your foreman gives you a list of the varying lengths of 
pipe needed, but the distributor sells stock pipe only in one fixed size.  "
list,"Your job is to figure out 
the minimum number of stock pipes required to satisfy the list of requests, 
thereby saving money and minimizing waste. 
 
"
list,"If this pattern continues, sorting a list of a million numbers 
would take about four and a half hours.  "
list,"When you call the merge sort implementation of sort on a list of N numbers, 
the running time can be divided into two components: 
 
1. 
"
list,"Algorithms whose complexity class appears earlier in this 
list are more efficient than those that come afterward when the problems being 
considered are sufficiently large. 
"
list,"In this 
case, the equal sign specifying the initial value is followed by a list of initializers 
enclosed in curly braces.  "
list,"In the DIGITS example, you know that there are 10 digits in the list.  "
list,"[] = { 
   ""New York"", 
   ""Los Angeles"", 
   ""Chicago"", 
   ""Houston"", 
   ""Philadelphia"", 
   ""Phoenix"", 
   ""San Antonio"", 
   ""San Diego"", 
   ""Dallas"", 
}; 
 
This list, however, is not static over time.  "
list,"Between the census results of 1990 and 
2000, Detroit dropped off this list while Phoenix and San Antonio joined it.  "
list,"When 
the results are in from the 2020 census, it is likely that San Jose will join the list of 
cities with more than 1,000,000 people.  "
list,"If you are responsible for maintaining the 
program that contains this code, the last thing you want to do is to have to count 
how many cities there are in the list just so the program can determine how many 
elements there are.  "
list,"What you would like to do instead is update the list of cities and 
have the compiler figure out how many there are. 
 
"
list,"The name list represents an array but can also be used as a pointer value.  
"
list,"When it is used as a pointer, list is defined to be the address of the initial element 
in the array.  "
list,"Thus, if the compiler encounters the variable name list on its own, 
without any subscript after it, it translates the array name into the pointer value at 
which the array begins in memory. 
 
"
list,"Suppose, 
for example, that a function includes the following declarations: 
 
double list[3] = { 1.61803, 2.71828, 3.14159 }; 
double *p = list; 
 
Each of these variables is given space in the frame for this function.  "
list,"For the array 
variable list, the compiler allocates space for the three elements in the array, each 
of which is large enough to hold a double.  "
list,"The 
elements of the array list are initialized to the values 1.61803, 2.71828, and 
3.14159.  "
list,"The declaration 
 
double *p = list; 
 
initializes the pointer variable p so that it holds the address of the beginning of the 
array.  "
list,"If the stack frame begins at location FFA0, the memory looks like this: 
 
 
 
In this diagram, p now points to the initial address in the array list.  "
list,"2. 
Copy that same list in reverse order below the original one. 
"
list,"3. 
Add a 0 bit in front of the encodings in the original half of the list and a 1 
bit in front of those in the reversed copy. 
 
"
list,"The declaration 
 
 
12.2 Linked lists     519 
Rational *rp = new Rational(2, 3); 
 
therefore creates the following state: 
 
 
 
 12.2 Linked lists 
Pointers make it possible to record connections among different values in a larger 
data structure.  "
list,"The declaration 
 
 
12.2 Linked lists     519 
Rational *rp = new Rational(2, 3); 
 
therefore creates the following state: 
 
 
 
 12.2 Linked lists 
Pointers make it possible to record connections among different values in a larger 
data structure.  "
list,"To give you a preview of those coming attractions 
and to provide more examples of the use of pointers to structures in the heap, the 
subsections that follow introduce a fundamental data structure called a linked list in 
which the pointers connect individual data values in a single linear chain. 
 
"
list,"The Beacons of Gondor 
Before looking at the details of how linked lists are represented in C++, it makes 
sense to describe my favorite example of a linked list, which takes its inspiration 
from the following passage in The Return of the King by J. R. R. Tolkien: 
 
"
list,"The Beacons of Gondor 
Before looking at the details of how linked lists are represented in C++, it makes 
sense to describe my favorite example of a linked list, which takes its inspiration 
from the following passage in The Return of the King by J. R. R. Tolkien: 
 
"
list,"Each of the individual Tower structures represents a cell in the linked list, 
and the internal pointers are called links.  "
list,"The program begins by calling the function createBeaconsOfGondor, 
which assembles the linked list and returns a pointer to the first tower in the chain.  
"
list,"The implementation of createBeaconsOfGondor assembles the list 
in reverse order, starting with Rohan at the end of the chain and continuing on, one 
tower at a time, until it reaches Minas Tirith at the beginning of the chain.  "
list,"In a 
more general application, it would be preferable to read the values for the individual 
cells from a data file, and you will have a chance to implement this extension in 
exercise 3. 
 
 
 
12.2 Linked lists     521 
BeaconsOfGondor.cpp 
522     Dynamic Memory Management 
After the linked list has been initialized, the main program calls signal to 
display the names of the towers.  "
list,"In a 
more general application, it would be preferable to read the values for the individual 
cells from a data file, and you will have a chance to implement this extension in 
exercise 3. 
 
 
 
12.2 Linked lists     521 
BeaconsOfGondor.cpp 
522     Dynamic Memory Management 
After the linked list has been initialized, the main program calls signal to 
display the names of the towers.  "
list,"Given the list shown in Figure 12-2, the output of 
the program looks like this: 
 
 
 
The result is less exciting than the scene from Jackson’s Oscar-winning movie, but 
that may reflect only the limitations of console output.  "
list,"12.3 Freeing memory     523 
Iteration in linked lists 
The code for signal illustrates one of the fundamental programming patterns for 
linked lists, which is embodied in the for loop 
 
for (Tower *tp = start; tp !"
list,"12.3 Freeing memory     523 
Iteration in linked lists 
The code for signal illustrates one of the fundamental programming patterns for 
linked lists, which is embodied in the for loop 
 
for (Tower *tp = start; tp !"
list,"The effect of the for loop pattern in the signal function is to cycle through each 
element in the linked list in much the same way as the classic for loop pattern 
cycles through the elements in an array.  "
list,"The initialization expression declares a 
temporary pointer variable—in this case, the variable tp, which is intended to 
suggest the words tower pointer—and initializes it to the first pointer in the list.  
"
list,"tp->link; 
 
which changes the value of tp to the value of the link pointer in the current Tower 
structure, thereby advancing tp to the next tower in the list. 
 
"
list,"Recursion and lists 
Although most code used to process linked lists proceeds iteratively in the manner 
described in the preceding section, linked lists have a recursive character that often 
turns out to be useful in practice.  "
list,"Recursion and lists 
Although most code used to process linked lists proceeds iteratively in the manner 
described in the preceding section, linked lists have a recursive character that often 
turns out to be useful in practice.  "
list,"Recursion and lists 
Although most code used to process linked lists proceeds iteratively in the manner 
described in the preceding section, linked lists have a recursive character that often 
turns out to be useful in practice.  "
list,"The simple case is that of the empty list, which is 
represented in C++ using the pointer value NULL.  "
list,"In the general case, a linked list 
consists of a cell followed by a linked list.  "
list,"In the general case, a linked list 
consists of a cell followed by a linked list.  "
list,"This formulation leads to a natural 
recursive decomposition in which you first check whether the list is empty and, if 
not, perform some operation on the first cell and then call yourself recursively on 
the rest of the list.  "
list,"This formulation leads to a natural 
recursive decomposition in which you first check whether the list is empty and, if 
not, perform some operation on the first cell and then call yourself recursively on 
the rest of the list.  "
list,"Thus, if you allocate a dynamic array by writing 
 
double *array = new double[3]; 
 
you can free the allocated memory by executing the statement 
 
delete[] array; 
 
If you need to free a linked list, you have to cycle through the individual cells, 
freeing each one as you go.  "
list,"Your loop structure 
must therefore store the pointer to the next cell before it frees the cell in which that 
pointer appears, as illustrated by the following while loop: 
 
while (list !"
list,"Tower *next = list->link; 
   delete list; 
   list = next; 
} 
 
Deleting every pointer in a linked list is easier if you use the recursive formulation: 
 
void freeList(Tower *list) { 
   if (list !"
list,"Tower *next = list->link; 
   delete list; 
   list = next; 
} 
 
Deleting every pointer in a linked list is easier if you use the recursive formulation: 
 
void freeList(Tower *list) { 
   if (list !"
list,"Tower *next = list->link; 
   delete list; 
   list = next; 
} 
 
Deleting every pointer in a linked list is easier if you use the recursive formulation: 
 
void freeList(Tower *list) { 
   if (list !"
list,"Tower *next = list->link; 
   delete list; 
   list = next; 
} 
 
Deleting every pointer in a linked list is easier if you use the recursive formulation: 
 
void freeList(Tower *list) { 
   if (list !"
list,"Tower *next = list->link; 
   delete list; 
   list = next; 
} 
 
Deleting every pointer in a linked list is easier if you use the recursive formulation: 
 
void freeList(Tower *list) { 
   if (list !"
list,"= NULL) { 
      freeList(list->link); 
      delete list; 
   } 
} 
 
 
12.3 Freeing memory     525 
Strategies for freeing memory 
Knowing when to free a piece of memory is not an easy task, particularly as 
programs become large.  "
list,"C++ allows the programmer to specify that a method does not change the state of 
the associated object by adding the keyword const after the parameter list.  "
list,"One particularly important application of this technique is the 
linked list in which the pointers form a linear chain.  "
list,"Each element in a linked list 
is called a cell, and the pointers that define the order of the elements are called 
links.  "
list,"The last cell in a linked list contains a NULL link pointer, which serves as a 
sentinel marking the end of the list. 
"
list,"The last cell in a linked list contains a NULL link pointer, which serves as a 
sentinel marking the end of the list. 
"
list,"6. 
Define the terms cell and link as they are used in the context of the linked list 
data structure. 
 
"
list,"What is the standard technique for marking the end of a linked list? 
 
8. 
"
list,"What structure definition would you use to define the cell type for a linked list 
of integers? 
 
"
list,"9. 
Given your definition in the preceding exercise, how would you write a for 
loop to step through every element of a linked list stored in the variable list? 
 
"
list,"9. 
Given your definition in the preceding exercise, how would you write a for 
loop to step through every element of a linked list stored in the variable list? 
 
"
list,"The names of the towers in the BeaconsOfGondor program from Figure 12-1 
are listed explicitly in the createBeaconsOfGondor function.  "
list,"Modify the BeaconsOfGondor program so that the first 
statement in the main program calls a function 
 
Tower *readBeaconsFromFile(string filename); 
 
that reads in the list of towers from the specified file.  "
list,"This chapter implements the editor buffer abstraction using three different 
underlying representations—a character array, a pair of character stacks, and a 
linked list of characters—and evaluates their advantages and disadvantages. 
 
"
list,"A list-based implementation     591 
given the array implementation but fast when using the stack approach.  "
list,"A list-based implementation 
As an initial step toward finding a more efficient representation for the editor buffer"
list,"In the list of grievances against King 
George, you carefully pen the following text: 
 
 
 
Unfortunately, just at the last minute, someone decides that this sentence needs the 
word only before the phrase by repeated injury.  "
list,A linked list allows you to achieve much the same effect.  
list,"If the characters are 
stored in a linked list rather than a character array, all you need to do to insert a 
missing character is change a couple of pointers.  "
list,"If the original contents of the 
buffer were stored as the linked list 
 
 
 
all you need to do is (1) write the B down somewhere, (2) draw an arrow from B to 
the letter to which A is pointing (which is currently the C), and (3) change the arrow 
pointing from the A so that it now points to the B, like this: 
 
 
 
This structure has the same form as the linked-list example from Chapter 12.  "
list,"If the original contents of the 
buffer were stored as the linked list 
 
 
 
all you need to do is (1) write the B down somewhere, (2) draw an arrow from B to 
the letter to which A is pointing (which is currently the C), and (3) change the arrow 
pointing from the A so that it now points to the B, like this: 
 
 
 
This structure has the same form as the linked-list example from Chapter 12.  "
list,"To 
represent the chain of characters, all you need to do is store the characters in the 
cells of a linked list.  "
list,"The list for the characters ABC, for example, looks like this: 
 
 
 
In list structure diagrams, however, it is common to indicate the NULL value with a 
diagonal line across the box, as shown in the preceding example. 
 
"
list,"The list for the characters ABC, for example, looks like this: 
 
 
 
In list structure diagrams, however, it is common to indicate the NULL value with a 
diagonal line across the box, as shown in the preceding example. 
 
"
list,"At first glance, it might seem that the linked list is all you need to represent the 
contents of the buffer."
list,"If you store the cursor as an integer, finding the current position will require 
counting through the cells in the list until you reach the desired index.  "
list,"A better approach is to define the EditorBuffer class so that 
it maintains two pointers to Cell objects: a start pointer that shows where the list 
begins and a cursor pointer that marks the current cursor position. 
 
 
"
list,"A list-based implementation     593 
"
list,"If you have a buffer containing three characters, your first reaction 
is almost certain to be that you using a linked list with three cells.  "
list,"There are many tactical approaches to solving this problem, but the one that 
usually turns out to be the best is to allocate an extra cell so that the list contains one 
cell for each possible insertion point.  "
list,"Typically, this cell goes at the beginning of 
the list and is called a dummy cell.  "
list,"Even though the rest of this structure is not formally a part of the 
object, it will help programmers who later have to work with this structure if you 
document the data structure design in the private section of the buffer.h file, as 
shown in Figure 13-8. 
594     Efficiency and Representation 
private section (list) 
 
13.5"
list,"A list-based implementation     595 
Insertion into a linked-list buffer 
"
list,"A list-based implementation     595 
Insertion into a linked-list buffer 
"
list,"No matter where the cursor is positioned, the insertion operation for a linked list 
consists of the following steps: 
 
"
list,"A list-based implementation     597 
The final step consists of changing the cursor field in the buffer structure so 
that it also points to the new cell, which results in the following configuration: 
 
 
 
When the program returns from the insertCharacter method, the temporary 
variable cp is released, which results in the following final buffer state: 
 
 
 
which represents the buffer contents 
 
 
 
The following implementation of the insertCharacter method is a simple 
translation into C++ code of the informal steps illustrated in the last several 
diagrams: 
 
void EditorBuffer::insertCharacter(char ch) { 
   Cell *cp = new Cell; 
   "
list,"598     Efficiency and Representation 
Deletion in a linked-list buffer 
To delete a cell in a linked list, all you have to do is remove it from the pointer 
chain.  "
list,"598     Efficiency and Representation 
Deletion in a linked-list buffer 
To delete a cell in a linked list, all you have to do is remove it from the pointer 
chain.  "
list,"The 
necessary statement is therefore 
 
cursor->link = cursor->link->link; 
 
Executing this statement leaves the buffer in the following state: 
 
 
 
Because the cell containing B is no longer accessible through the linked-list 
structure, it is good policy to free its storage by calling delete, as shown in the 
following implementation of deleteCharacter: 
 
void EditorBuffer::deleteCharacter() { 
   if (cursor->link !"
list,"A list-based implementation     599 
Note that you need a variable like oldCell to hold a copy of the pointer to the cell 
about to be freed while you adjust the chain pointers.  "
list,"Cursor motion in the linked-list representation 
The remaining operations in the EditorBuffer class simply move the cursor.  
"
list,"How would you go about implementing these operations in the linked-list buffer?  
"
list,"Two of these operations—moveCursorForward and moveCursorToStart—are 
easy to perform in the linked-list model.  "
list,"The list structure diagram for the buffer 
is then 
 
 
 
and the result of executing the moveCursorForward operation is 
 
 
 
Of course, when you reach the end of the buffer, you can no longer move 
forward.  "
list,"In the list-structure representation of the buffer, you have to implement every 
operation in terms of the data that you can see from the buffer structure itself, which 
contains the start and the cursor pointers.  "
list,"The 
start pointer, however, gives you access to the entire linked-list chain.  "
list,"A list-based implementation     601 
Before you abandon hope, you need to recognize that it is possible to find the 
cell that precedes the current cell.  "
list,"This cell must be the preceding cell in the list.  
"
list,"You can write the code to find the cursor pointer using the traditional for loop 
idiom for linked lists introduced in Chapter 12.  "
list,"When the destructor is 
called, it is responsible for freeing any memory allocated by the class, which 
includes every cell in the linked-list chain.  "
list,"To avoid this problem, you need to maintain your position in the list in a separate 
variable as you free each cell; in essence, you need a place to stand.  "
list,"cp = next; 
   } 
} 
 
The complete code for the linked-list implementation of the buffer class appears 
in Figure 13-9. 
 
 
"
list,"A list-based implementation     603 
buffer.cpp (list), p1 
604     Efficiency and Representation 
buffer.cpp (list), p2 
 
13.5"
list,"A list-based implementation     603 
buffer.cpp (list), p1 
604     Efficiency and Representation 
buffer.cpp (list), p2 
 
13.5"
list,"A list-based implementation     603 
buffer.cpp (list), p1 
604     Efficiency and Representation 
buffer.cpp (list), p2 
 
13.5"
list,"A list-based implementation     605 
Computational complexity of the linked-list buffer 
From the discussion in the preceding section, it is easy to add another column to the 
complexity table showing the cost of the fundamental editing operations as a 
method of the number of characters in the buffer.  "
list,"A list-based implementation     605 
Computational complexity of the linked-list buffer 
From the discussion in the preceding section, it is easy to add another column to the 
complexity table showing the cost of the fundamental editing operations as a 
method of the number of characters in the buffer.  "
list,"The new table, which includes 
the data for all three implementations, appears in Table 13-4. 
 
606     Efficiency and Representation 
Unfortunately, the table for the list structure representation still contains two 
O(N) operations, moveCursorBackward and moveCursorToEnd.  "
list,"Doubly linked lists 
The good news is that this problem is easy to solve.  "
list,"The resulting structure is 
called a doubly linked list. 
 
"
list,"Each cell in the doubly linked list has two link fields, a prev field that points to 
the previous cell and a next field that points to the next one.  "
list,"The actual 
implementation, however, is left as an exercise so that you can refine your 
understanding of linked lists. 
 
"
list,"By the 
time you get around to adding the prev field to each cell for the doubly linked list, 
you will end up using at least nine bytes of memory to represent each character.  
"
list,"For example, you could combine the array and linked-list strategies 
by representing the buffer as a doubly linked list of lines, where each line was 
represented using the array form.  "
list,"For example, you could combine the array and linked-list strategies 
by representing the buffer as a doubly linked list of lines, where each line was 
represented using the array form.  "
list,"In programming, structures 
designed in this way are called linked lists.  "
list,"The conventional way to mark the end of a linked list is to store the pointer 
constant NULL in the link field of the last cell. 
"
list,"If you are inserting and deleting values from a linked list, it is often convenient 
to allocate an extra dummy cell at the beginning of the list.  "
list,"If you are inserting and deleting values from a linked list, it is often convenient 
to allocate an extra dummy cell at the beginning of the list.  "
list,"• Insertions and deletions at specified points in a linked list are constant-time 
operations. 
"
list,"• You can iterate through the cells of a linked list by using the following idiom: 
 
for (Cell *cp = list; cp != NULL; cp = cp->link) { 
    .  .  .  "
list,"• You can iterate through the cells of a linked list by using the following idiom: 
 
for (Cell *cp = list; cp != NULL; cp = cp->link) { 
    .  .  .  "
list,". 
} 
 
• Doubly linked lists make it possible to traverse a list efficiently in both 
directions. 
"
list,". 
} 
 
• Doubly linked lists make it possible to traverse a list efficiently in both 
directions. 
"
list,"• Linked lists tend to be efficient in execution time but inefficient in their use of 
memory.  "
list,"In some cases, you may be able to design a hybrid strategy that allows 
you to combine the execution efficiency of linked lists with the space advantages 
of arrays. 
 
 "
list,"What is the purpose of the dummy cell in a linked list used to represent the 
editor buffer? 
 
11."
list,Does the dummy cell go at the beginning or the end of a linked list?  
list,"What are the five steps required to insert a new character into the linked-list 
buffer? 
 
13."
list,"Draw a diagram showing all the cells in the linked-list representation of a 
buffer that contains the following text, with the cursor positioned as shown: 
 
 
 
14."
list,"What is meant by the phrase traversing a list? 
 
"
list,"What is the standard idiomatic pattern used in C++ to traverse a linked list? 
 
17."
list,"Which editor operations require linear time in the linked-list representation of 
the editor buffer?  "
list,"What modification can you make to the linked-list structure so that all six of the 
editor operations run in constant time? 
 
"
list,"Write a new 
implementation of linked-list version of buffer.cpp in which you make the 
following changes: 
 
"
list,"The linked list contains no dummy cell—just a cell for every character. 
"
list,"Implement the EditorBuffer class using the strategy described in the section 
entitled “Doubly linked lists” earlier in this chapter.  "
list,"Stacks, 
queues, and vectors can also be implemented using a linked list much like the one 
used to implement the editor buffer in Chapter 13.  "
list,"By studying the linked-list 
implementation of these structures, you will increase your understanding not only of 
how linked lists work but also of how you can apply them in practical programming 
contexts. 
 
"
list,"By studying the linked-list 
implementation of these structures, you will increase your understanding not only of 
how linked lists work but also of how you can apply them in practical programming 
contexts. 
 
"
list,"In the sections 
that follow, these blue boxes will be replaced by two different underlying 
representations for the stack class: one that uses a dynamic array to store the values 
and a second that uses a linked list. 
 
"
list,"14.2 Implementing stacks      623 
stack-impl, p1 
624     Linear Structures 
stack-impl, p2 
 
14.2 Implementing stacks      625 
Implementing stacks as linked lists 
Although arrays are the most common underlying representation for stacks, it is also 
possible to implement the Stack class using linked lists.  "
list,"14.2 Implementing stacks      623 
stack-impl, p1 
624     Linear Structures 
stack-impl, p2 
 
14.2 Implementing stacks      625 
Implementing stacks as linked lists 
Although arrays are the most common underlying representation for stacks, it is also 
possible to implement the Stack class using linked lists.  "
list,"If you do so, the 
conceptual representation for the empty stack is simply the NULL pointer: 
 
 
 
626     Linear Structures 
When you push a new element onto the stack, the element is simply added to the 
front of the linked-list chain.  "
list,"The steps involved are the same as those required to insert a character into a 
linked-list buffer.  "
list,"Thus, if you push the element e2 on the stack, you get the following configuration: 
 
 
 
In the linked-list representation, the pop operation consists of removing the first 
cell in the chain and returning the value stored there.  "
list,"Thus, a pop operation from 
the stack shown in the preceding diagram returns e2 and restores the previous state 
of the stack, as follows: 
 
 
 
Although it would be possible to store only the pointer to the start of the linked 
list in the underlying representation, doing so has an unfortunate consequence for 
the efficiency of the size method.  "
list,"If the class stores only the linked list, the only 
way to determine the length of that list is to walk through the elements of the list 
until you find the NULL pointer at the end.  "
list,"If the class stores only the linked list, the only 
way to determine the length of that list is to walk through the elements of the list 
until you find the NULL pointer at the end.  "
list,"If the class stores only the linked list, the only 
way to determine the length of that list is to walk through the elements of the list 
until you find the NULL pointer at the end.  "
list,"Adopting this design 
means that the private section declares two instance variables: a pointer to the start 
of the list and the count of the number of items.  "
list,"The contents of the revised private section of the stack.h interface for the 
list-based stack appear in Figure 14-4.  "
list,"The complete listing of the implementation section for 
the list-based version of stack.h appears in Figure 14-5. 
 
"
list,"The constructor, as always, is responsible for setting up the initial state of the 
object, which consists of an empty linked list and an element count of zero.  "
list,"The 
constructor in Figure 14-5 initializes these fields explicitly, as follows: 
 
template <typename ValueType> 
Stack<ValueType>::Stack() { 
   list = NULL; 
   count = 0; 
} 
 
F I G U R E  1 4 - 4
Private section for the list-based stack 
/* Private section */
private:
/*
 *"
list,"The 
constructor in Figure 14-5 initializes these fields explicitly, as follows: 
 
template <typename ValueType> 
Stack<ValueType>::Stack() { 
   list = NULL; 
   count = 0; 
} 
 
F I G U R E  1 4 - 4
Private section for the list-based stack 
/* Private section */
private:
/*
 *"
list,"This version of the stack.h interface uses a linked list to store
 * the elements of the stack.  "
list,"The top item is always at the front of
 * the linked list and is therefore always accessible without searching.
 "
list,"*/
/* Type for linked list cell */
   struct Cell {
      ValueType data;                   /*"
list,"The data value                  */
      Cell *link;                       /* Link to the next cell           */
   };
/* Instance variables */
   Cell *list;                          /"
list,"Initial pointer in the list     */
   int count;                           /"
list,"* Number of elements              */
/* Private method prototypes */
   void deepCopy(const Stack<ValueType> & src);
628     Linear Structures 
list-stack-impl, p1 
 
14.2 Implementing stacks      629 
list-stack-impl, p2 
630     Linear Structures 
list-stack-impl, p3 
 
14.2 Implementing stacks      631 
"
list,"* Number of elements              */
/* Private method prototypes */
   void deepCopy(const Stack<ValueType> & src);
628     Linear Structures 
list-stack-impl, p1 
 
14.2 Implementing stacks      629 
list-stack-impl, p2 
630     Linear Structures 
list-stack-impl, p3 
 
14.2 Implementing stacks      631 
"
list,"* Number of elements              */
/* Private method prototypes */
   void deepCopy(const Stack<ValueType> & src);
628     Linear Structures 
list-stack-impl, p1 
 
14.2 Implementing stacks      629 
list-stack-impl, p2 
630     Linear Structures 
list-stack-impl, p3 
 
14.2 Implementing stacks      631 
"
list,"The push method illustrates the standard pattern for adding a new cell to the 
beginning of a linked list: 
 
template <typename ValueType> 
void Stack<ValueType>::push(ValueType value)"
list,"= value; 
   cp->link = list; 
   list = cp; 
   count++; 
} 
 
This pattern is sufficiently important that it is worth going through the steps using a 
heap-stack diagram.  "
list,"= value; 
   cp->link = list; 
   list = cp; 
   count++; 
} 
 
This pattern is sufficiently important that it is worth going through the steps using a 
heap-stack diagram.  "
list,"In this example, that chain is empty, but it 
always has the value that used to be in the list field of the Stack object to which 
push is applied.  "
list,"Thus, the statement 
 
cp->link = list; 
 
makes sure that this cell appears at the beginning of the existing list.  "
list,"Thus, the statement 
 
cp->link = list; 
 
makes sure that this cell appears at the beginning of the existing list.  "
list,"The next step in the process consists of updating the list field in the Stack 
object so that the list begins with the newly allocated cell.  "
list,"The next step in the process consists of updating the list field in the Stack 
object so that the list begins with the newly allocated cell.  "
list,"The statement 
 
list = cp; 
 
leaves memory looking like this: 
 
 
 
 
14.2 Implementing stacks      633 
From there, the push method increments the count field and then returns to the 
main program, with the memory diagram in the following state: 
 
 
 
"
list,"The heart of the pop implementation is the line 
 
list = list->link; 
 
which replaces the linked list in the Stack object with the sublist that follows the 
current cell, which is NULL in the current example.  "
list,"The heart of the pop implementation is the line 
 
list = list->link; 
 
which replaces the linked list in the Stack object with the sublist that follows the 
current cell, which is NULL in the current example.  "
list,"Assigning this value to the 
list component of the stack, decrementing the count, freeing the cell, and 
634     Linear Structures 
returning from the method leaves the following final state, which corresponds to an 
empty stack: 
 
 
 
 14.3 Implementing queues 
As you know from Chapter 5, stacks and queues are very similar structures.  "
list,"Given the conceptual similarity of these structures and their interfaces, it is not 
surprising that both stacks and queues can be implemented using either array-based 
or list-based strategies.  "
map,"Once you’ve done that, all you need to do is map the interval number 
into the value the client wants. 
 
"
map,"This chapter introduces five classes—Vector, Stack, Queue, Map, and Set—
each of which represents an important abstract data type.  "
map,"226     Collections 
 5.4 The Map class 
This section introduces another generic collection called a map, which is 
conceptually similar to a dictionary.  "
map,"226     Collections 
 5.4 The Map class 
This section introduces another generic collection called a map, which is 
conceptually similar to a dictionary.  "
map,"A map is a generalization of this idea that provides an association 
between an identifying tag called a key and an associated value, which may be a 
much larger and more complicated structure.  "
map,Maps have many applications in programming.  
map,"A map makes it easy to maintain the association 
between the name of a variable and its corresponding value.  "
map,"When they are used in 
this context, maps are often called symbol tables, which is just another name for the 
same concept. 
 
"
map,"In addition to the Map class described in this section, the Stanford libraries offer 
a HashMap class that has almost the same structure and behavior.  "
map,"For now, it’s best to focus on the Map class until you understand how maps work in 
general.  "
map,"For now, it’s best to focus on the Map class until you understand how maps work in 
general.  "
map,"You’ll have a chance to learn about the differences between these two 
implementations of the map concept in Chapters 15 and 16. 
 
"
map,"The structure of the Map class 
As with the collection classes introduced earlier in this chapter, Map is implemented 
as a template class that must be parameterized with both the key type and the value 
type.  "
map,"The structure of the Map class 
As with the collection classes introduced earlier in this chapter, Map is implemented 
as a template class that must be parameterized with both the key type and the value 
type.  "
map,"For example, if you want to simulate a dictionary in which individual words 
are associated with their definitions, you can start by declaring a dictionary 
variable as follows: 
 
Map<string,string> dictionary; 
 
Similarly, if you are implementing a programming language, you could use a Map to 
store the values of floating-point variables by associating variable names and 
values, as follows: 
 
Map<string,double> symbolTable; 
 
These definitions create empty maps that contain no keys and values.  "
map,"For example, if you want to simulate a dictionary in which individual words 
are associated with their definitions, you can start by declaring a dictionary 
variable as follows: 
 
Map<string,string> dictionary; 
 
Similarly, if you are implementing a programming language, you could use a Map to 
store the values of floating-point variables by associating variable names and 
values, as follows: 
 
Map<string,double> symbolTable; 
 
These definitions create empty maps that contain no keys and values.  "
map,"For example, if you want to simulate a dictionary in which individual words 
are associated with their definitions, you can start by declaring a dictionary 
variable as follows: 
 
Map<string,string> dictionary; 
 
Similarly, if you are implementing a programming language, you could use a Map to 
store the values of floating-point variables by associating variable names and 
values, as follows: 
 
Map<string,double> symbolTable; 
 
These definitions create empty maps that contain no keys and values.  "
map,"For example, if you want to simulate a dictionary in which individual words 
are associated with their definitions, you can start by declaring a dictionary 
variable as follows: 
 
Map<string,string> dictionary; 
 
Similarly, if you are implementing a programming language, you could use a Map to 
store the values of floating-point variables by associating variable names and 
values, as follows: 
 
Map<string,double> symbolTable; 
 
These definitions create empty maps that contain no keys and values.  "
map,"In either 
case, you would subsequently need to add key/value pairs to the map.  "
map,"5.4 The Map class      227 
The most common methods used with the Map class appear in Table 5-5.  "
map,"5.4 The Map class      227 
The most common methods used with the Map class appear in Table 5-5.  "
map,"Of 
these, the ones that implement the fundamental behavior of the map concept are put 
and get.  "
map,"If no 
value appears in the map for a particular key, calling get with that key returns the 
default value for the value type.  "
map,"You can check whether a key exists in a map by 
calling the containsKey method, which returns true or false depending on 
whether the specified key has been defined. 
 
"
map,"A few simple diagrams may help to illustrate the operation of the Map class in 
more detail.  "
map,"Suppose that you have declared the symbolTable variable to be a 
Map<string,double> as you saw earlier in the section.  "
map,"That declaration creates 
228     Collections 
an empty map with no associations, as represented by the following diagram that 
contains an empty set of bindings: 
 
 
 
Once you have the map, you can use put to establish new associations.  "
map,"That declaration creates 
228     Collections 
an empty map with no associations, as represented by the following diagram that 
contains an empty set of bindings: 
 
 
 
Once you have the map, you can use put to establish new associations.  "
map,"Although it hardly makes sense in the case of mathematical constants, you could 
change the values in the map by making additional calls to put.  "
map,"You could, for 
example, reset the value associated with ""pi"" (as an 1897 bill before the Indiana 
State General Assembly sought to do) by calling 
 
symbolTable.put(""pi"", 3.0); 
 
which would leave the map in the following state: 
 
 
 
At this point, calling symbolTable.containsKey(""pi"") would return true; by 
contrast, calling symbolTable.containsKey(""x"") would return false. 
 
 
"
map,"5.4 The Map class      229 
Using maps in an application 
If you fly at all frequently, you quickly learn that every airport in the world has a 
three-letter code assigned by the International Air Transport Association (IATA).  
"
map,"5.4 The Map class      229 
Using maps in an application 
If you fly at all frequently, you quickly learn that every airport in the world has a 
three-letter code assigned by the International Air Transport Association (IATA).  
"
map,"The existence of the Map class makes this application extremely easy to write.  
"
map,"The entire application fits on a single page, as shown in Figure 5-7. 
230     Collections 
Figure 4-7 
 
5.4 The Map class      231 
"
map,"The main program in the AirportCodes application reads in three-letter codes, 
looks up the corresponding location, and writes that back to the console, as shown 
in the following sample run: 
 
 
 
Maps as associative arrays 
"
map,"The Map class overloads the square bracket operators used for array selection so that 
the statement 
 
map[key] = value; 
 
acts as a shorthand for 
 
map.put(key, value); 
 
Similarly, the expression map[key] returns the value from map associated with key 
in exactly the same way that map.get(key) does.  "
map,"The Map class overloads the square bracket operators used for array selection so that 
the statement 
 
map[key] = value; 
 
acts as a shorthand for 
 
map.put(key, value); 
 
Similarly, the expression map[key] returns the value from map associated with key 
in exactly the same way that map.get(key) does.  "
map,"While these shorthand forms of 
the put and get methods are undoubtedly convenient, using array notation for 
maps is initially surprising, given that maps and arrays seem to be entirely different 
in their structure.  "
map,"While these shorthand forms of 
the put and get methods are undoubtedly convenient, using array notation for 
maps is initially surprising, given that maps and arrays seem to be entirely different 
in their structure.  "
map,"If you think about maps and arrays in the right way, however, 
they turn out to be more alike than you might at first suspect. 
 
"
map,"The insight necessary to unify these two seemingly different structures is that 
you can think of arrays as structures that map index positions to elements.  "
map,"This array maps the key 0 into the value 9.2, the key 1 into 9.9, the key 2 into 9.7, 
and so forth.  "
map,"Thus, you can think of an array as simply a map with integer keys.  
"
map,"Conversely, you can think of a map as an array that uses the key type as its indices, 
which is precisely what the overloaded selection syntax for the Map class suggests. 
 
"
map,"Conversely, you can think of a map as an array that uses the key type as its indices, 
which is precisely what the overloaded selection syntax for the Map class suggests. 
 
"
map,"232     Collections 
Using array syntax to perform map operations is becoming increasingly common 
in programming languages even beyond the C++ domain.  "
map,"Many popular scripting 
languages implement all arrays internally as maps, making it possible to use index 
values that are not necessarily integers.  "
map,"Arrays implemented using maps as their 
underlying representation are called associative arrays. 
 
 "
map,"Creating a word list 
In the discussion of the Map class earlier in the chapter, one of the examples used to 
explain the underlying concept was that of a dictionary in which the keys were 
individual words and the corresponding values were the definitions.  "
map,"Instead of a map containing both words and definitions, all you need is a 
Set<string> whose elements are the legal words.  "
map,"Moreover, if the package of collection classes is well designed, clients should 
be able to use the same strategy to perform that operation, no matter whether they 
are cycling through all elements in a vector or a grid, all keys in a map, or all words 
in a lexicon.  "
map,"• When you iterate through the elements of the Map class, the range-based for 
loop returns the keys in the natural order for the key type.  "
map,"For example, a Map 
whose keys are integers will process the keys in ascending numerical order.  "
map,"A 
Map whose keys are strings will process the keys in lexicographic order, which 
is the order determined by comparing the underlying ASCII codes. 
"
map,"To keep track of the mapping between words and their 
associated counts, a Map<string,int> is precisely what you need. 
 
 
"
map,"Thus, given the file Macbeth.txt, you would like 
your program to produce something like the following output: 
 
 
 
 Summary 
This chapter introduced the C++ classes Vector, Stack, Queue, Map, and Set that 
together represent a powerful framework for storing collections.  "
map,"Given that you will 
be implementing them as you complete the text, the classes presented here have 
been simplified to some extent from the vector, stack, queue, map, and set 
classes in the Standard Template Library, although they export a very similar 
collection of methods.  "
map,"The Map class makes it possible to associate keys with values in a way that 
makes it possible to retrieve those associations efficiently.  "
map,"The fundamental 
operations on a map are put, which adds a key/value pair, and get, which 
returns the value associated with a particular key. 
"
map,"In addition to the Map and Set classes, the Stanford libraries export the closely 
related classes HashMap and HashSet.  "
map,"The only difference between Map and 
HashMap (or between Set and HashSet) is the order in which the range-based 
for loop iterates through the elements.  "
map,"The Map and Set classes step through 
the elements in increasing order as defined by the value type.  "
map,"What are the two type parameters used with the Map class. 
 
23."
map,"What happens if you call get for a key that doesn’t exist in a map? 
 
"
map,"What are the syntactic shorthand forms for get and put that allow you to treat 
maps as associative arrays? 
 
"
map,"For this problem, assume that you have access to the file AreaCodes.txt, 
which lists all the area codes paired with their locations as illustrated by the 
first few lines of that file: 
 
 
Exercises      259 
 
 
Using the AirportCodes program as a model, write the code necessary to 
read this file into a Map<int,string>, where the key is the area code and the 
value is the location.  "
map,"When you wrote the FindAreaCode program for the previous exercise, it is 
likely that you generated the list of area codes for a state by looping through 
the entire map and printing out any area codes that mapped to that state.  
"
map,"When you wrote the FindAreaCode program for the previous exercise, it is 
likely that you generated the list of area codes for a state by looping through 
the entire map and printing out any area codes that mapped to that state.  
"
map,"Although this strategy is fine for small maps like the area code example, 
efficiency will become an issue in working with much larger data maps. 
 
"
map,"Although this strategy is fine for small maps like the area code example, 
efficiency will become an issue in working with much larger data maps. 
 
"
map,"An alternative approach is to invert the map so that you can perform 
lookup operations in either direction.  "
map,"You can’t, however, declare the inverted 
map as a Map<string,int>, because there is often more than one area code 
associated with a state.  "
map,"You can’t, however, declare the inverted 
map as a Map<string,int>, because there is often more than one area code 
associated with a state.  "
map,"What you need to do instead is to make the inverted 
map a Map< string,Vector<int> > that maps each state name to a vector 
260     Collections 
of the area codes that serve that state.  "
map,"What you need to do instead is to make the inverted 
map a Map< string,Vector<int> > that maps each state name to a vector 
260     Collections 
of the area codes that serve that state.  "
map,"What you need to do instead is to make the inverted 
map a Map< string,Vector<int> > that maps each state name to a vector 
260     Collections 
of the area codes that serve that state.  "
map,"Rewrite the FindAreaCode program so 
that it creates an inverted map after reading in the data file and then uses that 
map to list the area codes for a state. 
 
"
map,"Rewrite the FindAreaCode program so 
that it creates an inverted map after reading in the data file and then uses that 
map to list the area codes for a state. 
 
"
map,"On a telephone keypad, the digits are mapped onto the alphabet as shown in 
the diagram below: 
 
 
 
"
map,"As a simple example of where this issue comes up, consider the problem of 
connecting two points A and B with a fractal that looks like a coastline on a 
map.  "
map,"That sequence of bits represents the number forty-two, which you can verify by 
calculating the contribution for each of the individual bits, as follows: 
 
 
 
This diagram illustrates how to map an integer into bits using binary notation, 
but also helps to demonstrate the fact that writing numbers in binary form is terribly 
inconvenient.  "
map,"There is no arbitrary limit on the 
size of a Vector or a Map.  "
set,"This library 
defines a set of simple input and output operations based on a data structure called a 
stream, which is a data structure used to manage the flow of information to or from 
some data source, such as the console or a file. 
 
"
set,"To ensure that the names defined in different parts of a 
large system do not interfere with one another, the designers of C++ made it 
possible to segment code into structures called namespaces, each of which keeps 
track of its own set of names.  "
set,"Thus, when the user types 
8 and hits the RETURN key, the effect is to set limit to 8. 
 
"
set,You set the type of the variable as part of the declaration.  
set,"From a formal perspective, a 
data type is defined by two properties: a domain, which is the set of values that 
belong to that type, and a set of operations, which defines the behavior of that type.  
"
set,"From a formal perspective, a 
data type is defined by two properties: a domain, which is the set of values that 
belong to that type, and a set of operations, which defines the behavior of that type.  
"
set,"The set of 
operations applicable to values of type int includes, for example, the standard 
arithmetic operations like addition and multiplication.  "
set,"Other types have a different 
domain and set of operations. 
 
"
set,"The domain of type char 
is the set of symbols that can be displayed on the screen or typed on the keyboard: 
the letters, digits, punctuation marks, spacebar, RETURN key, and so forth.  
"
set,"The decimal values of the characters in the 
ASCII set are shown in Table 1-2, where the ASCII code for any character is the 
sum of the numbers at the beginning of its row and column. 
 
"
set,"For the 
moment, you can simply imagine that C++ offers a built-in data type called string 
whose domain is the set of all sequences of characters.  "
set,"If n is 
declared to be of type int, the assignment 
 
n = 3.14159265; 
 
has the effect of setting n to 3, because the value is truncated to fit in the integer 
variable. 
 
"
set,"For 
example, the expression 
 
z = (x = 6) + (y = 7) 
 
has the effect of setting x to 6, y to 7, and z to 13.  "
set,"Of these, the most important is when you want to set 
several variables to the same value.  "
set,"C++’s definition of assignment as an operator 
32     Overview of C++ 
makes it possible, instead of writing separate assignment statements, to write a 
single statement like 
 
n1 = n2 = n3 = 0; 
 
which has the effect of setting all three variables to 0.  "
set,"The expression n3 = 0 is evaluated, which sets n3 to 0 and then passes 0 along as 
the value of the assignment expression.  "
set,"The easiest way to 
express conditional execution in C++ is by using the if statement, which comes in 
two forms: 
 
if (condition) statement 
 
if (condition) statement else statement 
 
You use the first form of the if statement when your solution strategy calls for a set 
of statements to be executed only if a particular Boolean condition is true.  "
set,"You use the second form of the if statement for situations in 
which the program must choose between two independent sets of actions based on 
the result of a test.  "
set,"In this pattern, the body of the for loop is executed with the variable var set to each 
value between start and finish, inclusive.  "
set,"The 
convention of using single-letter names such as i and j for index variables dates 
back at least as far as the early versions of FORTRAN (which required integer 
variables to start with a predefined set of letters in the middle of the alphabet) but 
also fits with similar conventions in mathematics.  "
set,the loop will begin by setting the index variable i to 0.  
set,"A typical C++ program consists of comments, library inclusions, program-level 
definitions, function prototypes, a function named main that is called when the 
program is started, and a set of auxiliary functions that work together with the 
main program to accomplish the required task. 
"
set,A data type is defined by a domain of values and a set of operations.  
set,"If a function requires no information from its caller, it need not have any 
arguments, but an empty set of parentheses must appear in both the function 
definition and any calls to that function. 
 
"
set,"What you want to do instead is subdivide the 
high-level problem into a set of lower-level functions, each of which makes sense 
on its own.  "
set,"If r is not zero, set x to the old value of y, set y equal to r, and repeat the process. 
 
 
"
set,"If r is not zero, set x to the old value of y, set y equal to r, and repeat the process. 
 
 
"
set,"For example, if 
you were designing a set of functions to implement a word processor, you might 
define a procedure with the following prototype: 
 
void formatInColumns(int nColumns = 2); 
 
The formatInColumns procedure takes the number of columns as an argument, 
but the = 2 in the prototype declaration means that this argument may be omitted.  "
set,"As a computer 
scientist, you should immediately think about the more general question: Given a 
set containing n distinct elements, how many ways can you choose a subset with k 
elements?  "
set,"The 
assignment statement 
 
var = 0; 
 
inside the function sets the local copy to 0 but leaves x unchanged in the calling 
program. 
 
"
set,"Although calling setToZero(x) would 
correctly set the integer variable x to 0, it would be illegal to call setToZero(3) 
because 3 is not assignable. 
 
"
set,"The only other parts of the interface are the 
prototype for the error function and three additional lines that are often referred to 
as interface boilerplate, which is a patterned set of lines that appears in every 
 
2.6 Interfaces and implementations     79 
interface.  "
set,"A function gives its caller access to a set of steps that together implement a single 
operation.  "
set,"A library gives its client access to a set of functions and types that 
implement what computer scientists describe as a programming abstraction.  "
set,"An interface that performs a narrowly defined set of 
operations for one client is not as useful as one that can be used in many 
different situations. 
"
set,"From a theoretical 
perspective, a number is random if there is no way to determine in advance what 
value it will have among a set of equally probable possibilities.  "
set,"How is it 
possible to generate unpredictable results by following a deterministic set of rules?  
 
"
set,"If a number is the result of a deterministic process, any user should be able to work 
through that same set of rules and anticipate the computer’s response. 
 
"
set,"This strategy works because, even though the user could, in 
theory, follow the same set of rules and anticipate the computer’s response, no one 
actually bothers to do so.  "
set,"Choosing the right set of functions 
As an interface designer, one of your primary challenges is choosing what functions 
to export.  "
set,"Translating these conceptual operations into a set of function prototypes is a 
relatively straightforward task.  "
set,"The rand function generates each new 
random value by applying a set of mathematical calculations to the last value it 
produced.  "
set,"In the <cstdlib> library, you can set 
that seed explicitly by calling srand(seed). 
 
"
set,"As you know from the multiple runs of the RandTest program, the C++ library 
sets the initial seed to a constant value every time a program is started, which is why 
rand always generates the same sequence of values.  "
set,"To implement this change, the functions randomInteger, randomReal, and 
randomChance must first check to see whether the random number seed has 
already been initialized and, if not, set it to some starting value that would be 
difficult for users to predict, which is usually taken from the value of the system 
clock.  "
set,"This technique allows you to write the following statement, which has the 
effect of initializing the pseudorandom number generator to an unpredictable point: 
 
srand(int(time(NULL))); 
 
Although it requires only a single line, the operation to set the random seed to an 
unpredictable value based on the system clock is quite obscure.  "
set,"If you declare other global values whose initial values 
were produced by the random-library library, there would be no way to ensure that 
the initialization flag had been set correctly. 
 
"
set,"As part of the supporting material for this textbook, Stanford University provides 
a set of libraries that make learning to program in C++ both easier and more 
enjoyable.  "
set,"Instead of the lines 
 
int limit; 
cout << ""Enter exponent limit: ""; 
cin >> limit; 
 
using simpio.h allows you to collapse this set of operations into a single line: 
 
int limit = getInteger(""Enter exponent limit: ""); 
 
108     Functions and Libraries 
"
set,"Although the GWindow class exports a much larger set of methods, the programs in 
this book use only the methods shown in Table 2-2.  "
set,"By having y values increase as you 
move downward, successive lines of text appear at increasing values of y. 
 
 Summary 
In this chapter, you learned about functions, which enable you to refer to an entire 
set of operations by using a simple name.  "
set,"Allowing the same set 
of instructions to be shared by many parts of a program reduces both its size and 
its complexity.  "
set,"The combinations function C(n, k) described in this chapter determines the 
number of ways you can choose k values from a set of n elements, ignoring the 
order of the elements.  "
set,"In Chapter 1, you learned that data types are defined by two properties: a domain 
and a set of operations.  "
set,"For strings, the domain is easy to identify: the domain of 
type string is the set of all sequences of characters.  "
set,"The more interesting problem 
is to identify the appropriate set of operations.  "
set,"For example, the declaration 
 
const string ALPHABET = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""; 
 
sets the constant ALPHABET to a 26-character string containing the uppercase letters. 
 
 
"
set,"The most common whitespace character is the space 
character itself, but the set of whitespace characters also includes tabs and the 
characters that mark the end of a line. 
 
"
set,"The problem with 
this expression is that the data type string is not a traditional type but is instead an 
example of a class, which is probably easiest to define informally as a template that 
describes a set of values together with an associated set of operations.  "
set,"The problem with 
this expression is that the data type string is not a traditional type but is instead an 
example of a class, which is probably easiest to define informally as a template that 
describes a set of values together with an associated set of operations.  "
set,"The object-oriented version of the statement that sets nChars to the length of the 
string object str is therefore 
 
int nChars = str.length(); 
 
Table 3-1 lists the most common methods exported by the <string> library, all of 
which use the receiver syntax. 
 
"
set,"Both the + and += operators allow concatenation of strings or single 
characters, as illustrated by the following example, which sets the string variable 
str to the string ""abcd"": 
 
string str = ""abc""; 
str += 'd'; 
 
Those of you who are familiar with Java may expect the + operator to support 
values of other types by converting those values to strings and then concatenating 
them together.  "
set,"The first section of Table 3-2 defines a set of predicate functions to test whether 
a character belongs to a particular category.  "
set,"In all other cases, add just an s. 
 
Write a test program and design a set of test cases to verify that your program 
works. 
 
13."
set,"Manipulators typically have the effect of setting properties of the output stream 
in a way that changes the formatting of subsequent output.  "
set,"Since >> returns the stream, it will 
indicate the end-of-file condition by setting the fail flag, which C++ then 
interprets as false. 
 
"
set,"The crux of the problem is that the extraction operator in the expression 
 
infile >> value; 
 
will set the failure indicator in either of two cases: 
 
1. 
"
set,"Here, 
the line 
 
istringstream stream(str); 
 
declares a variable named stream and initializes it to an istringstream object 
that is already set up to read data from the string variable str.  "
set,"Although C++ 
tends to use inheritance somewhat less frequently than many object-oriented 
languages do, it is nonetheless one of the features that sets the object-oriented 
paradigm apart from earlier programming models. 
 
"
set,"So far, you have seen 
two types of input streams—ifstream and istringstream—and two types of 
output streams—ofstream and ostringstream—that in each pairing share a 
common set of operations.  "
set,"This 
library exports a set of manipulators, the most important of which appear in 
Table 4-1.  "
set,"In James Thurber’s children’s story The Wonderful O, the island of Ooroo is 
invaded by pirates who set out to banish the letter O from the alphabet.  "
set,"In programming, tab stops are usually set at every eight columns.  "
set,"If the tab stops are set every eight 
spaces, the first tab character must be replaced by five spaces and the second 
tab character by three. 
 
"
set,"This chapter introduces five classes—Vector, Stack, Queue, Map, and Set—
each of which represents an important abstract data type.  "
set,"The collection classes used in this book are inspired by and draw much of their 
structure from a more advanced set of classes available for C++ called the 
Standard Template Library, or STL for short.  "
set,"As a client of the Vector class, you are concerned with a different set of issues 
and need to answer the following questions: 
 
1. 
"
set,"Symmetrically, you can use the set method to change the value of an existing 
element.  "
set,"For example, calling 
 
vec.set(3, 70); 
 
changes the value in index position 3 from 50 to 70, like this: 
 
 
 
The get, set, insertAt, and removeAt methods all check to make sure that 
the index value you supply is valid for the vector.  "
set,"For get, set, and removeAt, the Vector implementation checks that the index is 
greater than or equal to 0 and less than the number of elements.  "
set,"Even though the get and set methods are easy to use, hardly anyone actually calls 
these methods.  "
set,"One of the characteristics of C++ that sets it apart from most other 
languages is that classes can override the definition of the standard operators.  "
set,"For example, you can set element 3 in vec to 70 by writing 
 
vec[3] = 70; 
 
The resulting syntax is marginally shorter than calling set, but is more evocative of 
the array operations that the Vector class is designed to emulate. 
 
"
set,"For example, you can set element 3 in vec to 70 by writing 
 
vec[3] = 70; 
 
The resulting syntax is marginally shorter than calling set, but is more evocative of 
the array operations that the Vector class is designed to emulate. 
 
"
set,"For this reason, 
declarations of primitive variables usually include an explicit initializer that sets the 
variable to the desired starting value, as in 
 
double total = 0.0; 
 
The situation is different when you declare a variable to be an instance of a C++ 
class.  "
set,"A floating-point number 
• An arithmetic operator chosen from the set +, -, *, and / 
•"
set,"That declaration creates 
228     Collections 
an empty map with no associations, as represented by the following diagram that 
contains an empty set of bindings: 
 
 
 
Once you have the map, you can use put to establish new associations.  "
set,"Suppose, 
for example, that you have an array—or equivalently a vector—containing a set of 
scores such as those you might assign for a gymnastics match: 
 
 
 
"
set,"5.5 The Set class 
One of the most useful collection classes is the Set class, which exports the entries 
shown in Table 5-6.  "
set,"5.5 The Set class 
One of the most useful collection classes is the Set class, which exports the entries 
shown in Table 5-6.  "
set,"This class is used to model the mathematical abstraction of a 
set, which is a collection in which the elements are unordered and in which each 
value appears only once.  "
set,"Sets turn out to be extremely useful in many algorithmic 
 
5.5 The Set class      233 
applications and are therefore worth a chapter of their own.  "
set,"Sets turn out to be extremely useful in many algorithmic 
 
5.5 The Set class      233 
applications and are therefore worth a chapter of their own.  "
set,"Even before you have a 
chance to read the more detailed account in Chapter 18, it is worth presenting a few 
examples of sets so you can get a better sense of how they work and how they might 
be useful in applications. 
 
"
set,"Things 
would be a lot easier if you could simply define a set of all the punctuation marks, 
in which case all you need to do to implement ispunct(ch) is check whether the 
character ch is in that set. 
 
"
set,"Things 
would be a lot easier if you could simply define a set of all the punctuation marks, 
in which case all you need to do to implement ispunct(ch) is check whether the 
character ch is in that set. 
 
"
set,"A set-based implementation of the predicate functions from <cctype> appears 
in Figure 5-8.  "
set,"The code creates a Set<char> for each of the character types and 
then defines the predicate functions so that they simply invoke contains on the 
appropriate set.  "
set,"The code creates a Set<char> for each of the character types and 
then defines the predicate functions so that they simply invoke contains on the 
appropriate set.  "
set,"For example, to implement isdigit, the cctype implementation 
defines a set containing the digit characters like this: 
 
const Set<char>"
set,"For example, to implement isdigit, the cctype implementation 
defines a set containing the digit characters like this: 
 
const Set<char>"
set,"DIGIT_SET = setFromString(""0123456789""); 
 
The setFromString function, which appears at the bottom of Figure 5-8, is a 
simple helper function that creates a set by adding each of the characters in the 
argument string.  "
set,"This function makes it very easy to define sets like the set of 
punctuation characters simply by listing the characters that fit that description. 
 
"
set,"This function makes it very easy to define sets like the set of 
punctuation characters simply by listing the characters that fit that description. 
 
"
set,"One of the advantages of working with sets is that doing so makes it easier to 
think in terms of abstract, high-level operations.  "
set,"While most of the sets in 
cctype.cpp use setFromString to create the set from the actual characters, a 
few use the + operator, which is overloaded to return the union of two sets.  "
set,"While most of the sets in 
cctype.cpp use setFromString to create the set from the actual characters, a 
few use the + operator, which is overloaded to return the union of two sets.  "
set,"While most of the sets in 
cctype.cpp use setFromString to create the set from the actual characters, a 
few use the + operator, which is overloaded to return the union of two sets.  "
set,"For 
example, once you have defined the sets LOWER_SET and UPPER_SET so that they 
contain the lowercase and uppercase letters, you can define ALPHA_SET by writing 
 
const Set<char> ALPHA_SET = LOWER_SET + UPPER_SET; 
 
234     Collections 
 
Figure 4-8 
 
5.5 The Set class      235 
"
set,"For 
example, once you have defined the sets LOWER_SET and UPPER_SET so that they 
contain the lowercase and uppercase letters, you can define ALPHA_SET by writing 
 
const Set<char> ALPHA_SET = LOWER_SET + UPPER_SET; 
 
234     Collections 
 
Figure 4-8 
 
5.5 The Set class      235 
"
set,"For 
example, once you have defined the sets LOWER_SET and UPPER_SET so that they 
contain the lowercase and uppercase letters, you can define ALPHA_SET by writing 
 
const Set<char> ALPHA_SET = LOWER_SET + UPPER_SET; 
 
234     Collections 
 
Figure 4-8 
 
5.5 The Set class      235 
"
set,"For such applications, the Set class is an 
ideal tool.  "
set,"Instead of a map containing both words and definitions, all you need is a 
Set<string> whose elements are the legal words.  "
set,"A word is legal if it is 
contained in the set, and illegal if it is not. 
 
"
set,A set of words with no associated definitions is called a lexicon.  
set,"If you have a 
text file named EnglishWords.txt containing all the words in English, one word 
per line, you could create an English lexicon using the following code: 
 
Set<string> lexicon; 
ifstream infile; 
infile.open(""EnglishWords.txt""); 
if (infile.fail())"
set,"{ 
   lexicon.add(word); 
} 
infile.close(); 
 
The Lexicon class in the Stanford libraries 
Although the Set class works reasonably well as the underlying representation for a 
lexicon, it is not particularly efficient.  "
set,"Because having an efficient representation 
for lexicons opens up many exciting possibilities for programming projects, the 
Stanford libraries include a Lexicon class, which is essentially a specialized 
version of Set optimized for storing sets of words.  "
set,"Because having an efficient representation 
for lexicons opens up many exciting possibilities for programming projects, the 
Stanford libraries include a Lexicon class, which is essentially a specialized 
version of Set optimized for storing sets of words.  "
set,"As you can see, these entries are largely the 
same as those for Set. 
 
"
set,"• When you iterate through the elements of a Set or a Lexicon, the range-based 
for loop always returns the elements in the natural order for the value type.  "
set,"Thus, given the file Macbeth.txt, you would like 
your program to produce something like the following output: 
 
 
 
 Summary 
This chapter introduced the C++ classes Vector, Stack, Queue, Map, and Set that 
together represent a powerful framework for storing collections.  "
set,"Given that you will 
be implementing them as you complete the text, the classes presented here have 
been simplified to some extent from the vector, stack, queue, map, and set 
classes in the Standard Template Library, although they export a very similar 
collection of methods.  "
set,"The Set class represents a collection in which the elements are unordered and in 
which each value appears only once, as with sets in mathematics.  "
set,"The Set class represents a collection in which the elements are unordered and in 
which each value appears only once, as with sets in mathematics.  "
set,"The 
fundamental operations on a set include add, which stores a new element in the 
set and contains, which checks to see whether an element is in the set. 
"
set,"The 
fundamental operations on a set include add, which stores a new element in the 
set and contains, which checks to see whether an element is in the set. 
"
set,"The 
fundamental operations on a set include add, which stores a new element in the 
set and contains, which checks to see whether an element is in the set. 
"
set,"In addition to the Map and Set classes, the Stanford libraries export the closely 
related classes HashMap and HashSet.  "
set,"The only difference between Map and 
HashMap (or between Set and HashSet) is the order in which the range-based 
for loop iterates through the elements.  "
set,"The Map and Set classes step through 
the elements in increasing order as defined by the value type.  "
set,"What feature of the Vector class makes it possible to avoid explicit use of the 
get and set methods? 
 
"
set,"Why do the Stanford libraries include a separate Lexicon class even though it 
is easy to implement a lexicon using the Set class? 
 
"
set,"Calling readVector a third time 
should set roots to an empty vector. 
 
"
set,"One of the primary goals of statistical analysis is to find ways to compress the 
complete set of data into summary statistics that express properties of the 
distribution as a whole.  "
set,"For example, given the set of exam scores 
 
100, 95, 47, 88, 86, 92, 75, 89, 81, 70, 55, 80 
 
a traditional histogram would have the following form: 
 
 
 
The asterisks in the histogram indicate one score in the 40s, one score in the 
50s, five scores in the 80s, and so forth. 
 
"
set,"One of the problems in using the Grid class is that it isn’t as easy to set up a 
particular set of initial values as it is with a vector, where you can add the 
250     Collections 
elements you want with the += operator.  "
set,"One of the problems in using the Grid class is that it isn’t as easy to set up a 
particular set of initial values as it is with a vector, where you can add the 
250     Collections 
elements you want with the += operator.  "
set,"The ping-pong balls bounce around the sides of the box and 
eventually land on the floor, where they are likely to set off more mousetraps. 
 
"
set,"One approach that is useful in some 
situations is to export methods that set the values of specific instance variables.  
"
set,"It is generally more useful 
to export class definitions in a library, thereby making those definitions available to 
a broader set of applications.  "
set,"3. 
Define a set of constructors to create new objects.  "
set,"In that setting, it would be useful to work together 
with those clients to agree on a set of design goals. 
 
"
set,"When you use this design, the 
process of reading tokens from a scanner has the following pseudocode form: 
 
Set the input for the token scanner to be some string or input stream. 
"
set,"As you will learn if you go on to take a course on compilers, it is possible to 
build a token scanner that allows the client to specify what constitutes a legal token, 
typically by supplying a precise set of rules.  "
set,"The setInput method that sets the scanner input to a string 
•"
set,"Test your implementation of the Domino class by writing a program that 
creates a full set of dominos from 0-0 up to 6-6 and then displays those 
dominos on the console.  "
set,"A full set of dominos contains one copy of each 
possible domino in that range, disallowing duplicates that result from flipping 
a domino over.  "
set,"A domino set, therefore, has a 4-1 domino but not a separate 
1-4 domino. 
 
"
set,"A default constructor that sets the date to January 1, 1900. 
"
set,"However, you might also need to label points in a geometric diagram, 
 
Exercises      311 
in which case you would want a similar but independent set of labels for 
points such as ""P0"", ""P1"", ""P2"", and so forth. 
 
"
set,"You should use the token scanner to read the terms and operators 
and set up the scanner so that it ignores any whitespace characters.  "
set,"The circles are then connected by a set of labeled arcs that 
indicate how the process moves from one state to another.  "
set,"336     Introduction to Recursion 
If neither of these cases applies, the implementation can simplify the problem by 
choosing the appropriate half of the array and calling itself recursively with an 
updated set of search limits. 
 
 "
set,"Thus, the new stack 
frame looks like this: 
 
 
 
As the diagram illustrates, the new stack frame has its own set of variables, which 
temporarily supersede the variables in frames that are further down on the stack.  
"
set,"The problem covered in this section is called the subset-sum problem, which can 
be defined as follows: 
 
Given a set of integers and a target value, determine whether it is 
possible to find a subset of those integers whose sum is equal to 
the specified target. 
 
"
set,"For example, given the set { –2, 1, 3, 8 } and the target value 7, the answer to the 
subset-sum question is yes, because the subset { –2, 1, 8 } adds up to 7.  "
set,"The concrete 
goal is to write a predicate function 
 
bool subsetSumExists(Set<int> & set, int target); 
 
that takes the required information and returns true if it is possible to generate the 
value target by adding up some combination of elements chosen from set. 
 
"
set,"The concrete 
goal is to write a predicate function 
 
bool subsetSumExists(Set<int> & set, int target); 
 
that takes the required information and returns true if it is possible to generate the 
value target by adding up some combination of elements chosen from set. 
 
"
set,"In applications that 
work with sets, the simple case is almost always when the set is empty.  "
set,"In applications that 
work with sets, the simple case is almost always when the set is empty.  "
set,"If the set is 
empty, there is no way that you can add elements to produce a target value unless 
the target is zero.  "
set,"bool subsetSumExists(Set<int> & set, int target) { 
   if (set.isEmpty()) { 
      return target == 0; 
   } else { 
      Find a recursive decomposition that simplifies the problem. 
   } 
} 
 
"
set,"In this case, what you 
need to do is make the set smaller, because what you’re trying to do is move toward 
the simple case that occurs when the set is empty.  "
set,"In this case, what you 
need to do is make the set smaller, because what you’re trying to do is move toward 
the simple case that occurs when the set is empty.  "
set,"If you take an element out of the 
set, what’s left over is smaller by one element.  "
set,"The operations exported by the Set 
 
8.2 The subset-sum problem      363 
class make it easy to choose an element from a set and then determine what’s left 
over.  "
set,"The operations exported by the Set 
 
8.2 The subset-sum problem      363 
class make it easy to choose an element from a set and then determine what’s left 
over.  "
set,"All you need is the following code: 
 
int element = set.first(); 
Set<int> rest = set - element; 
 
The first method returns the element of the set that appears first in its iteration 
order, and the expression involving the overloaded - operator produces the set that 
contains every element in set except the value of element.  "
set,"All you need is the following code: 
 
int element = set.first(); 
Set<int> rest = set - element; 
 
The first method returns the element of the set that appears first in its iteration 
order, and the expression involving the overloaded - operator produces the set that 
contains every element in set except the value of element.  "
set,"All you need is the following code: 
 
int element = set.first(); 
Set<int> rest = set - element; 
 
The first method returns the element of the set that appears first in its iteration 
order, and the expression involving the overloaded - operator produces the set that 
contains every element in set except the value of element.  "
set,"All you need is the following code: 
 
int element = set.first(); 
Set<int> rest = set - element; 
 
The first method returns the element of the set that appears first in its iteration 
order, and the expression involving the overloaded - operator produces the set that 
contains every element in set except the value of element.  "
set,"All you need is the following code: 
 
int element = set.first(); 
Set<int> rest = set - element; 
 
The first method returns the element of the set that appears first in its iteration 
order, and the expression involving the overloaded - operator produces the set that 
contains every element in set except the value of element.  "
set,"All you really need is some 
way to choose some element and then to create a smaller set by removing the 
element you selected from the original set. 
 
"
set,"All you really need is some 
way to choose some element and then to create a smaller set by removing the 
element you selected from the original set. 
 
"
set,"The inclusion/exclusion pattern 
Making the set smaller, however, is not enough to solve this problem.  "
set,"The code to 
divide a set into an element and the rest of the set will come up again in many 
recursive applications and is part of a general programming pattern for working 
with the Set class.  "
set,"The code to 
divide a set into an element and the rest of the set will come up again in many 
recursive applications and is part of a general programming pattern for working 
with the Set class.  "
set,"The code to 
divide a set into an element and the rest of the set will come up again in many 
recursive applications and is part of a general programming pattern for working 
with the Set class.  "
set,"Structurally, you know that subsetSumExists must call itself 
recursively on the smaller set now stored in the variable rest.  "
set,"For that to happen, it must be possible to take the rest of the set and 
produce the value target - element.  "
set,"The other possibility is that the subset 
you’re looking for excludes that element, in which case it must be possible to 
generate the value target using only the leftover set of elements.  "
set,"This insight is 
enough to complete the implementation of subsetSumExists, as follows: 
 
bool subsetSumExists(Set<int> & set, int target) { 
   if (set.isEmpty())"
set,"{ 
      return target == 0; 
   } else { 
      int element = set.first(); 
      Set<int> rest = set - element; 
      return subsetSumExists(rest, target) 
          || subsetSumExists(rest, target - element); 
   } 
} 
 
Because the recursive strategy subdivides the general case into one branch that 
includes a particular element and another that excludes it, this strategy is sometimes 
364     Recursive Strategies 
called the inclusion/exclusion pattern.  "
set,"{ 
      return target == 0; 
   } else { 
      int element = set.first(); 
      Set<int> rest = set - element; 
      return subsetSumExists(rest, target) 
          || subsetSumExists(rest, target - element); 
   } 
} 
 
Because the recursive strategy subdivides the general case into one branch that 
includes a particular element and another that excludes it, this strategy is sometimes 
364     Recursive Strategies 
called the inclusion/exclusion pattern.  "
set,"Although the pattern is easiest 
to recognize when you are working with sets, it also comes up in applications 
involving vectors and strings, and you should be on the lookout for it in those 
situations as well. 
 
 "
set,"8.3 Generating permutations 
Many word games and puzzles require the ability to rearrange a set of letters to 
form a word.  "
set,"Thus, if you wanted to write a Scrabble program, it would be useful to 
have a facility for generating all possible arrangements of a particular set of tiles.  "
set,"Let’s suppose you want to write a function 
 
Set<string> generatePermutations(string str); 
 
that returns a set containing all permutations of the string.  "
set,"Let’s suppose you want to write a function 
 
Set<string> generatePermutations(string str); 
 
that returns a set containing all permutations of the string.  "
set,"For example, if you call 
 
generatePermutations(""ABC"") 
 
the function should return a set containing the following elements: 
 
{ ""ABC"", ""ACB"", ""BAC"", ""BCA"", ""CAB"", ""CBA"" } 
 
How might you go about implementing the generatePermutations function?  
"
set,"The character 'A' followed by every possible permutation of ""BCDE"" 
• The character 'B' followed by every possible permutation of ""ACDE"" 
• The character 'C' followed by every possible permutation of ""ABDE"" 
• The character 'D' followed by every possible permutation of ""ABCE"" 
• The character 'E' followed by every possible permutation of ""ABCD"" 
 
More generally, you can construct the set of all permutations of a string of length n 
by selecting each character in turn and then, for each of those n possible first 
characters, concatenating the selected character on to the front of every possible 
permutation of the remaining n – 1 characters.  "
set,"If you call 
generatePermutations(""""), you should get back a set containing a single 
element, which is the empty string. 
 
"
set,"366     Recursive Strategies 
Permutations.cpp 
 
8.3 Generating permutations      367 
 
If you run the Permutations program and enter the string ""ABC"", you see the 
following output: 
 
 
 
The use of sets in this application ensures that the program generates permutations 
in alphabetical order and that each distinct ordering of the characters appears 
exactly once, even if there are repeated letters in the input string.  "
set,"The recursive process adds a new element to this set the full total of 24 (4!) times, 
but the implementation of the Set class ensures that no duplicate values appear. 
 
"
set,"The recursive process adds a new element to this set the full total of 24 (4!) times, 
but the implementation of the Set class ensures that no duplicate values appear. 
 
"
set,"For example, given the set 
 
Exercises      377 
{ 1, 3, 4, 5 }, there are two different ways to produce the target value 5: 
 
• Select the 1 and the 4 
• Select"
set,"just the 5 
 
By contrast, there is no way to partition the set { 1, 3, 4, 5 } to get 11. 
 
"
set,"Write a function 
 
int countSubsetSumWays(Set<int> & set, int target); 
 
that returns the number of ways in which you can produce the target value by 
choosing a subset of the specified set.  "
set,"Write a function 
 
int countSubsetSumWays(Set<int> & set, int target); 
 
that returns the number of ways in which you can produce the target value by 
choosing a subset of the specified set.  "
set,"For example, suppose that sampleSet 
has been initialized as follows: 
 
Set<int> sampleSet; 
sampleSet += 1, 3, 4, 5; 
 
Given this definition of sampleSet, calling 
 
countSubsetSumWays(sampleSet, 5); 
 
should return 2 (there are two ways to make 5), and calling 
 
countSubsetSumWays(sampleSet, 11) 
 
should return 0 (there are no ways to make 11). 
 
"
set,"If you are using a limited set of weights, however, you can only measure 
certain quantities accurately.  "
set,"With these you can easily 
measure out 4 ounces, as shown: 
 
 
 
It is somewhat more interesting to discover that you can also measure out 2 
ounces by shifting the 1-ounce weight to the other side, as follows: 
 
 
 
Write a recursive function 
 
bool isMeasurable(int target, Vector<int> & weights) 
 
that determines whether it is possible to measure out the desired target amount 
with a given set of weights, which is stored in the vector weights. 
 
"
set,"For example, suppose that sampleWeights has been initialized like this: 
 
Vector<int> sampleWeights; 
sampleWeights += 1, 3; 
 
Given these values, the function call 
 
isMeasurable(2, sampleWeights) 
 
should return true because it is possible to measure out 2 ounces using the 
sample weight set as illustrated in the preceding diagram.  "
set,"7. 
In the card game called Cribbage, part of the game consists of adding up the 
score from a set of five playing cards.  "
set,"As a second example, the cards 
 
 
 
contain the following eight different combinations that add up to 15: 
 
5C + JC 
5D + JC 
5H + JC 
5S + JC 
5C + 5D + 5H 
5C + 5D + 5S 
5C + 5H + 5S 
5D + 5H + 5S 
 
Write a function 
 
int countFifteens(Vector<Card> & cards); 
 
that takes a vector of Card values (as defined in Chapter 6, exercise 2) and 
returns the number of ways you can make 15 from that set of cards.  "
set,"Another way to 
look at the problem is to solve the recursive case looks like this: 
 
a) Remove the first character from the string and store it in the variable ch. 
b) Generate the set containing all permutations of the remaining characters. 
"
set,"c) Form a new set by inserting ch in every possible position in each of those 
permutations. 
 
"
set,"The resulting code is not 
particularly efficient, mostly because it ends up generating sets that are later 
discarded and because it applies methods like substr that require copying the 
characters in a string.  "
set,"Use this strategy to implement a function 
 
void listPermutations(string str); 
 
that lists on cout all permutations of the string str without generating any 
sets at all or applying any string methods other than length or selection.  "
set,"The interesting challenge comes in 
adapting the structure of the algorithm so that it lists each unique permutation 
exactly once without using sets to accomplish that task.  "
set,"If you make the correct set of choices, you end up at the solution.  "
set,"To house this deadly creature, Minos forced his servant 
Daedalus (the engineering genius who later escaped by constructing a set of wings) 
to build a vast underground labyrinth at Knossos.  "
set,"You still have to identify a set of simple cases 
so that the recursion can terminate, but the hard work has been done. 
 
"
set,"Fortunately, it is possible to set 
those details aside by introducing a new interface that hides some of the complexity.  
"
set,"Depending on which move is chosen, the second player then has a particular set of 
responses.  "
set,"This code is responsible for setting up the game, 
printing out instructions, keeping track of whose turn it is, asking the user for a 
move, checking whether that move is legal, updating the number of coins, figuring 
out when the game is over, and letting the user know who won. 
 
"
set,"At the end of each turn, the code for the play method passes 
the turn to the next player by setting whoseTurn to opponent(whoseTurn). 
 
"
set,"The play method, for example, is 
directly responsible for setting up the nCoins variable and updating it after each 
player moves.  "
set,"The usual strategy for limiting the search is to set some maximum value for the 
depth of the recursion.  "
set,"Such 
an analysis is useful because it allows you to set an upper bound on the 
computational complexity.  "
set,"From a practical point of view, it is often useful to 
consider how well an algorithm performs if you average its behavior over all 
possible sets of input data.  "
set,"All you need 
to do to satisfy the constraints is to set the constants C and N0 both to 1.  "
set,"Another is the traveling salesman problem, which seeks to find the shortest route 
by which one can visit a set of N cities connected by some transportation system 
and then return to the starting point.  "
set,"Use that function to write a program 
that produces a table of the observed running times for a predefined set of 
sizes, as shown in the following sample run: 
 
 
 
The best way to measure elapsed system time for programs of this sort is to 
use the ANSI clock function, which is exported by the ctime interface.  "
set,"There may, of course, be many duplicated values, but you know 
that there must be at least one by virtue of what mathematicians call the 
pigeonhole principle: if you have more items to put into a set of pigeonholes 
than the number of pigeonholes, there must be some pigeonhole that ends up 
with more than one item. 
 
"
set,"The hard part of this problem is to 
design an algorithm so that your implementation adheres to the same set of 
conditions as the solution to the preceding exercise: 
 
"
set,"This design decision makes it more difficult for C++ 
programs to work with expanded character sets needed to encode languages that 
don’t fit easily into the ASCII model.  "
set,"Fortunately, C++ offers a standard idiom for determining the allocated size of an 
array that uses static initialization to set the number of elements.  "
set,"The technique of setting a pointer to the address of an existing array is rather 
limited.  "
set,"Thus, if you had set p to the address of list[1] using 
 
p = &list[1]; 
 
the addresses corresponding to p - 1 and p + 1 would be the addresses of list[0] 
and list[2], respectively. 
 
"
set,"By far the 
easiest one to use is the string class exported by the <string> interface, which 
defines a set of high-level operations that make string manipulation relatively easy.  
"
set,"The binary 
numbers with N bits consist of the following two sets in order: 
 
• All binary numbers with N !"
set,"6. 
Using the definitions of MAX_JUDGES and scores on page 498 as a starting 
point, write a program that reads in gymnastics scores between 0 and 10 from 
a set of judges and then computes the average of the scores after eliminating 
both the highest and lowest scores from consideration.  "
set,"The call to the new operator returns the address of a storage location in the heap that 
has been set aside to hold an integer.  "
set,"Choosing a representation for the character stack 
When you set out to design the underlying data structure for a class, the first 
question you should ask yourself is what information needs to be stored inside each 
object.  "
set,"The first line sets the capacity to 
the constant INITIAL_CAPACITY, which is defined to be 10.  "
set,"By entering the right combinations of these 
commands, you can make any desired set of changes.  "
set,"In the buffer.h interface, you define the 
EditorBuffer class whose public interface provides the required set of operations, 
while the data representation is kept private.  "
set,"After evaluating the tradeoffs, you might 
decide to use one strategy in a certain set of circumstances and a different strategy 
in another.  "
set,"At the same time, it is important to note that, no matter what 
representation you choose, the editor must always be able to perform the same set of 
commands.  "
set,"cp = cp->link; 
} 
 
When the while loop exits, cp is set to the cell prior to the cursor.  "
set,"The constructor, as always, is responsible for setting up the initial state of the 
object, which consists of an empty linked list and an element count of zero.  "
queue,"This chapter introduces five classes—Vector, Stack, Queue, Map, and Set—
each of which represents an important abstract data type.  "
queue,"The complete implementation of the calculator application appears in Figure 5-4. 
 
5.2 The Stack class      215 
 Figure 4-4 
216     Collections 
 
Figure 4-4 
 
5.3 The Queue class      217 
 5.3 The Queue class 
As you learned in section 5.2, the defining feature of a stack is that the last item 
pushed is always the first item popped.  "
queue,"The complete implementation of the calculator application appears in Figure 5-4. 
 
5.2 The Stack class      215 
 Figure 4-4 
216     Collections 
 
Figure 4-4 
 
5.3 The Queue class      217 
 5.3 The Queue class 
As you learned in section 5.2, the defining feature of a stack is that the last item 
pushed is always the first item popped.  "
queue,A data structure that stores items using a FIFO discipline is called a queue.  
queue,"The 
fundamental operations on a queue—which are analogous to the push and pop 
operations for stacks—are called enqueue and dequeue.  "
queue,"The enqueue operation 
adds a new element to the end of the queue, which is traditionally called its tail.  
"
queue,"The dequeue operation removes the element at the beginning of the queue, which 
is called its head. 
 
"
queue,"In a stack, the client must add and remove elements from the same 
end of the internal data structure, as follows: 
 
 
 
In a queue, the client adds elements at one end and removes them from the other, 
like this: 
 
 
 
As you might expect from the fact that the models are so similar, the structure of 
the Queue class looks very much like its Stack counterpart.  "
queue,"In a stack, the client must add and remove elements from the same 
end of the internal data structure, as follows: 
 
 
 
In a queue, the client adds elements at one end and removes them from the other, 
like this: 
 
 
 
As you might expect from the fact that the models are so similar, the structure of 
the Queue class looks very much like its Stack counterpart.  "
queue,"218     Collections 
The queue data structure has many applications in programming.  "
queue,"Not 
surprisingly, queues turn up in many situations in which it is important to maintain a 
first-in/first-out discipline in order to ensure that service requests are treated fairly.  
"
queue,"For example, if you are working in an environment in which a single printer is 
shared among several computers, the printing software is usually designed so that 
all print requests are entered in a queue.  "
queue,"Thus, if several users decide to enter print 
requests, the queue structure ensures that each user’s request is processed in the 
order received. 
 
"
queue,"Queues are also common in programs that simulate the behavior of waiting lines.  
"
queue,"Such a program would almost certainly involve queues, 
because a checkout line operates in a first-in/first-out way.  "
queue,"For example, it would be very useful to 
know how various pollutants affect the ozone layer and how the resulting changes 
 
5.3 The Queue class      219 
in the ozone layer affect the global climate.  "
queue,"For example, to 
make the initial implementation of the simulation as simple as possible, you might 
begin by assuming that there is one cashier who serves customers from a single 
queue.  "
queue,"You might then assume that customers arrive with a random probability and 
enter the queue at the end of the line.  "
queue,"After an appropriate 
service period—which you must also model in some way—the cashier completes 
the transaction with the current customer, and is free to serve the next customer in 
the queue. 
 
"
queue,"Another is that the cashier might finish with the current customer and go on the 
 
5.3 The Queue class      221 
serve the next person in line.  "
queue,"Determine whether a new customer has arrived and, if so, add that person to the 
queue. 
"
queue,"222     Collections 
 
Figure 4-5 
 
5.3 The Queue class      223 
 
Figure 4-5 
224     Collections 
 
"
queue,"The waiting line itself is represented, naturally enough, as a queue.  "
queue,"The value 
stored in the queue is the time at which that customer arrived in the queue, which 
makes it possible to determine how many seconds that customer spent in line before 
reaching the head of the queue. 
 
"
queue,"The value 
stored in the queue is the time at which that customer arrived in the queue, which 
makes it possible to determine how many seconds that customer spent in line before 
reaching the head of the queue. 
 
"
queue,"The value 
stored in the queue is the time at which that customer arrived in the queue, which 
makes it possible to determine how many seconds that customer spent in line before 
reaching the head of the queue. 
 
"
queue,"5.3 The Queue class      225 
"
queue,"When this arrival level is reached, the length of the queue 
and the average waiting time both begin to grow very quickly.  "
queue,"• You cannot use the range-based for loop in conjunction with the Stack and 
Queue classes.  "
queue,"Allowing unrestricted access to these structures would violate 
the principle that only one element (the element at the top of a stack or the one at 
the head of a queue) is visible at a particular time. 
 
"
queue,"Thus, given the file Macbeth.txt, you would like 
your program to produce something like the following output: 
 
 
 
 Summary 
This chapter introduced the C++ classes Vector, Stack, Queue, Map, and Set that 
together represent a powerful framework for storing collections.  "
queue,"Given that you will 
be implementing them as you complete the text, the classes presented here have 
been simplified to some extent from the vector, stack, queue, map, and set 
classes in the Standard Template Library, although they export a very similar 
collection of methods.  "
queue,"The Queue class is similar to the Stack class except for the fact that elements 
are removed from a queue in the same order in which they were added: first in, 
first out (FIFO).   "
queue,"The Queue class is similar to the Stack class except for the fact that elements 
are removed from a queue in the same order in which they were added: first in, 
first out (FIFO).   "
queue,"The fundamental operations on a queue are enqueue, which 
adds a value to the end of a queue, and dequeue, which removes and returns the 
value from the front. 
"
queue,"The fundamental operations on a queue are enqueue, which 
adds a value to the end of a queue, and dequeue, which removes and returns the 
value from the front. 
"
queue,"• With the exception of Stack and Queue, all collection classes support the the 
range-based for loop pattern, which makes it easy to cycle through the elements 
of the collection.  "
queue,"How do these terms apply 
to stacks and queues? 
 
"
queue,"What are the names for the corresponding operations for a queue? 
 
20."
queue,"What does the peek operation do in each of the Stack and Queue classes? 
 
"
queue,"What reason does the chapter offer for disallowing the use of the range-based 
for loop with the Stack and Queue classes? 
 
"
queue,"—Bob Dylan, “The Times They Are a-Changin’,” 1963 
 
Following the inspiration from Bob Dylan’s song (which is itself inspired by 
Matthew 19:30), write a function 
 
void reverseQueue(Queue<string> & queue); 
 
that reverses the elements in the queue.  "
queue,"—Bob Dylan, “The Times They Are a-Changin’,” 1963 
 
Following the inspiration from Bob Dylan’s song (which is itself inspired by 
Matthew 19:30), write a function 
 
void reverseQueue(Queue<string> & queue); 
 
that reverses the elements in the queue.  "
queue,"Remember that you have no access to 
the internal representation of the queue and must therefore come up with an 
algorithm—presumably involving other structures—that accomplishes the 
task. 
 
"
queue,"As a first step, 
rewrite the simulation so that there are several independent queues, as is 
usually the case in supermarkets.  "
queue,"A customer arriving at the checkout area 
finds the shortest checkout line and enters that queue.  "
queue,"In each cycle of the simulation, any cashier that becomes idle serves the next 
customer in the queue.  "
queue,"— Jane Austen, Persuasion, 1818 
616     Linear Structures 
The Stack, Queue, and Vector classes introduced in Chapter 5 are examples of a 
general category of abstract data types called linear structures, in which the 
elements are arranged in a linear order.  "
queue,"Stacks, 
queues, and vectors can also be implemented using a linked list much like the one 
used to implement the editor buffer in Chapter 13.  "
queue,"Assigning this value to the 
list component of the stack, decrementing the count, freeing the cell, and 
634     Linear Structures 
returning from the method leaves the following final state, which corresponds to an 
empty stack: 
 
 
 
 14.3 Implementing queues 
As you know from Chapter 5, stacks and queues are very similar structures.  "
queue,"Assigning this value to the 
list component of the stack, decrementing the count, freeing the cell, and 
634     Linear Structures 
returning from the method leaves the following final state, which corresponds to an 
empty stack: 
 
 
 
 14.3 Implementing queues 
As you know from Chapter 5, stacks and queues are very similar structures.  "
queue,"A queue adopts a first-in/first-out (FIFO) model that 
more closely resembles a waiting line.  "
queue,"The interfaces for stacks and queues are also 
extremely similar.  "
queue,"Given the conceptual similarity of these structures and their interfaces, it is not 
surprising that both stacks and queues can be implemented using either array-based 
or list-based strategies.  "
queue,"With each of these models, however, the implementation of 
a queue has subtleties that don’t arise in the case of a stack.  "
queue,"In a queue, the enqueue operation happens at one end, and the 
dequeue operation happens at the other. 
 
"
stack,"These variables are allocated together in a 
block, which is called a stack frame. 
"
stack,The stack frame created for this function call is discarded.  
stack,"And while you can trace through a program on paper or 
a whiteboard, it may be better to get yourself a supply of 3!5 index cards and then 
use a card to represent each stack frame.  "
stack,"The advantage of the index-card model is 
that you can create a stack of index cards that closely models the operation of the 
computer.  "
stack,"To implement a function 
call, the system—which encompasses both the operating system you’re using and 
the hardware on which it runs—creates a new stack frame to keep track of the local 
variables that function declares."
stack,"In the Combinations program, the main function 
declares two integers, n and k, so the stack frame must include space for these 
variables. 
 
"
stack,"In the diagrams in this book, each stack frame appears as a rectangle surrounded 
by a double line.  "
stack,"The stack frame for 
main therefore looks like this when execution begins: 
 
 
 
From this point, the system executes the statements in order, printing out the 
prompts on the console, reading in the associated values from the user, and storing 
those values in the variables in that frame.  "
stack,"and k when the computer 
creates the combinations stack frame.  "
stack,"The new frame gets stacked on top of the 
old one, which allows the computer to remember the values of the local variables in 
main, even though they are not currently accessible.  "
stack,"To evaluate this function, the system must create yet another 
stack frame, this time for the function fact with an argument value of 6: 
 
 
 
Unlike the earlier stack frames, the frame for fact includes both parameters and 
local variable.  "
stack,"To evaluate this function, the system must create yet another 
stack frame, this time for the function fact with an argument value of 6: 
 
 
 
Unlike the earlier stack frames, the frame for fact includes both parameters and 
local variable.  "
stack,"Until you assign a new value to those variables, they will contain 
whatever data happened to be left over in the memory cells assigned to that stack 
frame, which is completely unpredictable.  "
stack,"When the program reaches the return 
statement, the stack frame looks like this: 
 
 
 
In this diagram, the box for the variable i is empty, because the value of i is no 
longer defined at this point in the program.  "
stack,"That value is then used to 
initialize the parameter n in the new stack frame, as follows: 
 
 
 
The computation of fact(2) is a bit easier to perform in one’s head than the 
earlier call to fact(6).  "
stack,"Internally, all the variables declared within a function are stored 
together in a stack frame. 
"
stack,"The computer refers to this point as the return address and keeps 
track of it in the stack frame. 
"
stack,"What is a stack frame? 
 
11."
stack,"This chapter introduces five classes—Vector, Stack, Queue, Map, and Set—
each of which represents an important abstract data type.  "
stack,"5.2 The Stack class      211 
 5.2 The Stack class 
When measured in terms of the operations it supports, the simplest collection class 
is the Stack class, which—despite its simplicity—turns out to be useful in a variety 
of programming applications.  "
stack,"5.2 The Stack class      211 
 5.2 The Stack class 
When measured in terms of the operations it supports, the simplest collection class 
is the Stack class, which—despite its simplicity—turns out to be useful in a variety 
of programming applications.  "
stack,"5.2 The Stack class      211 
 5.2 The Stack class 
When measured in terms of the operations it supports, the simplest collection class 
is the Stack class, which—despite its simplicity—turns out to be useful in a variety 
of programming applications.  "
stack,"Conceptually, a stack provides storage for a 
collection of data values, subject to the restriction that values must be removed from 
a stack in the opposite order from which they were added.  "
stack,"Conceptually, a stack provides storage for a 
collection of data values, subject to the restriction that values must be removed from 
a stack in the opposite order from which they were added.  "
stack,"This restriction implies 
that the last item added to a stack is always the first item that gets removed. 
 
"
stack,"In light of their importance in computer science, stacks have a terminology of 
their own.  "
stack,"Adding a new value to a stack is called pushing that value; removing the 
most recent item from a stack is called popping the stack.  "
stack,"Adding a new value to a stack is called pushing that value; removing the 
most recent item from a stack is called popping the stack.  "
stack,"Adding a new value to a stack is called pushing that value; removing the 
most recent item from a stack is called popping the stack.  "
stack,"Moreover, the order in 
which stacks are processed is sometimes called LIFO, which stands for “last in, 
first out.” 
 
"
stack,"A common (but possibly apocryphal) explanation for the words stack, push, and 
pop is that the stack model is derived from the way plates are stored in a cafeteria.  
"
stack,"A common (but possibly apocryphal) explanation for the words stack, push, and 
pop is that the stack model is derived from the way plates are stored in a cafeteria.  
"
stack,"Particularly, if you are in a cafeteria in which customers pick up their own plates at 
the beginning of a buffet line, those plates are placed in spring-loaded columns that 
make it easy for people in the cafeteria line to take the top plate, as illustrated in the 
following diagram: 
 
 
 
When a dishwasher adds a new plate, it goes on the top of the stack, pushing the 
others down slightly as the spring is compressed, as shown: 
 
 
 
Customers can take plates only from the top of the stack.  "
stack,"Particularly, if you are in a cafeteria in which customers pick up their own plates at 
the beginning of a buffet line, those plates are placed in spring-loaded columns that 
make it easy for people in the cafeteria line to take the top plate, as illustrated in the 
following diagram: 
 
 
 
When a dishwasher adds a new plate, it goes on the top of the stack, pushing the 
others down slightly as the spring is compressed, as shown: 
 
 
 
Customers can take plates only from the top of the stack.  "
stack,"The last plate added to the stack is the first one a 
customer takes. 
 
"
stack,"The primary reason that stacks are important in programming is that nested 
function calls behave in a stack-oriented fashion.  "
stack,"The primary reason that stacks are important in programming is that nested 
function calls behave in a stack-oriented fashion.  "
stack,"For example, if the main program 
calls a function named f, a stack frame for f gets pushed on top of the stack frame 
for main, as illustrated by the following diagram: 
 
212     Collections 
 
 
If f calls g, a new stack frame for g is pushed on top of the frame for f, as follows: 
 
 
 
When g returns, its frame is popped off the stack, restoring f to the top of the stack 
as shown in the original diagram. 
 
"
stack,"For example, if the main program 
calls a function named f, a stack frame for f gets pushed on top of the stack frame 
for main, as illustrated by the following diagram: 
 
212     Collections 
 
 
If f calls g, a new stack frame for g is pushed on top of the frame for f, as follows: 
 
 
 
When g returns, its frame is popped off the stack, restoring f to the top of the stack 
as shown in the original diagram. 
 
"
stack,"For example, if the main program 
calls a function named f, a stack frame for f gets pushed on top of the stack frame 
for main, as illustrated by the following diagram: 
 
212     Collections 
 
 
If f calls g, a new stack frame for g is pushed on top of the frame for f, as follows: 
 
 
 
When g returns, its frame is popped off the stack, restoring f to the top of the stack 
as shown in the original diagram. 
 
"
stack,"For example, if the main program 
calls a function named f, a stack frame for f gets pushed on top of the stack frame 
for main, as illustrated by the following diagram: 
 
212     Collections 
 
 
If f calls g, a new stack frame for g is pushed on top of the frame for f, as follows: 
 
 
 
When g returns, its frame is popped off the stack, restoring f to the top of the stack 
as shown in the original diagram. 
 
"
stack,"For example, if the main program 
calls a function named f, a stack frame for f gets pushed on top of the stack frame 
for main, as illustrated by the following diagram: 
 
212     Collections 
 
 
If f calls g, a new stack frame for g is pushed on top of the frame for f, as follows: 
 
 
 
When g returns, its frame is popped off the stack, restoring f to the top of the stack 
as shown in the original diagram. 
 
"
stack,"The structure of the Stack class 
Like Vector and Grid, Stack is a collection class that requires you to specify the 
element type.  "
stack,"The structure of the Stack class 
Like Vector and Grid, Stack is a collection class that requires you to specify the 
element type.  "
stack,"For example, Stack<int> represents a stack whose elements are 
integers, and Stack<string> represents one in which the elements are strings.  
"
stack,"For example, Stack<int> represents a stack whose elements are 
integers, and Stack<string> represents one in which the elements are strings.  
"
stack,"For example, Stack<int> represents a stack whose elements are 
integers, and Stack<string> represents one in which the elements are strings.  
"
stack,"Similarly, if you define the classes Plate and Frame, you can create stacks of these 
objects using the classes Stack<Plate> and Stack<Frame>.  "
stack,"Similarly, if you define the classes Plate and Frame, you can create stacks of these 
objects using the classes Stack<Plate> and Stack<Frame>.  "
stack,"Similarly, if you define the classes Plate and Frame, you can create stacks of these 
objects using the classes Stack<Plate> and Stack<Frame>.  "
stack,"5.2 The Stack class      213 
Stacks and pocket calculators 
One interesting application of stacks is in electronic calculators, where they are used 
to store intermediate results of a calculation.  "
stack,"5.2 The Stack class      213 
Stacks and pocket calculators 
One interesting application of stacks is in electronic calculators, where they are used 
to store intermediate results of a calculation.  "
stack,"5.2 The Stack class      213 
Stacks and pocket calculators 
One interesting application of stacks is in electronic calculators, where they are used 
to store intermediate results of a calculation.  "
stack,"Although stacks play a central role in 
the operation of most calculators, that role is easiest to see in early scientific 
calculators that required users to enter expressions in Reverse Polish Notation, or 
RPN. 
 
"
stack,"For example, to compute the result of the expression 
 
8.5 * 4.4 + 6.9 / 1.5 
 
on an RPN calculator, you would enter the operations in the following order: 
 
 
 
When the ENTER button is pressed, the calculator takes the previous value and 
pushes it on a stack.  "
stack,"When an operator button is pressed, the calculator first checks 
whether the user has just entered a value and, if so, automatically pushes it on the 
stack.  "
stack,"It then computes the result of applying the operator by 
 
• Popping the top two values from the stack 
• Applying the arithmetic operation indicated by the button to these values 
• Pushing the result back on the stack 
 
Except when the user is actually typing in a number, the calculator display shows 
the value at the top of the stack.  "
stack,"It then computes the result of applying the operator by 
 
• Popping the top two values from the stack 
• Applying the arithmetic operation indicated by the button to these values 
• Pushing the result back on the stack 
 
Except when the user is actually typing in a number, the calculator display shows 
the value at the top of the stack.  "
stack,"It then computes the result of applying the operator by 
 
• Popping the top two values from the stack 
• Applying the arithmetic operation indicated by the button to these values 
• Pushing the result back on the stack 
 
Except when the user is actually typing in a number, the calculator display shows 
the value at the top of the stack.  "
stack,"Thus, at each point in the operation, the calculator 
display and stack contain the values shown in Figure 5-3. 
 
214     Collections 
Implementing the RPN calculator in C++ requires making some changes in the 
user-interface design.  "
stack,"The letter C, which clears any values left on the stack 
 
A sample run of the calculator program might therefore look like this: 
 
 
 
Because the user enters each number on a separate line terminated with the RETURN 
key, there is no need for any counterpart to the calculator’s ENTER button, which 
really serves only to indicate that a number is complete.  "
stack,"The calculator program 
can simply push the numbers on the stack as the user enters them.  "
stack,"When the 
calculator reads an operator, it pops the top two elements from the stack, applies the 
operator, displays the result, and then pushes the result back on the stack. 
 
"
stack,"When the 
calculator reads an operator, it pops the top two elements from the stack, applies the 
operator, displays the result, and then pushes the result back on the stack. 
 
"
stack,"The complete implementation of the calculator application appears in Figure 5-4. 
 
5.2 The Stack class      215 
 Figure 4-4 
216     Collections 
 
Figure 4-4 
 
5.3 The Queue class      217 
 5.3 The Queue class 
As you learned in section 5.2, the defining feature of a stack is that the last item 
pushed is always the first item popped.  "
stack,"The complete implementation of the calculator application appears in Figure 5-4. 
 
5.2 The Stack class      215 
 Figure 4-4 
216     Collections 
 
Figure 4-4 
 
5.3 The Queue class      217 
 5.3 The Queue class 
As you learned in section 5.2, the defining feature of a stack is that the last item 
pushed is always the first item popped.  "
stack,"The 
fundamental operations on a queue—which are analogous to the push and pop 
operations for stacks—are called enqueue and dequeue.  "
stack,"In a stack, the client must add and remove elements from the same 
end of the internal data structure, as follows: 
 
 
 
In a queue, the client adds elements at one end and removes them from the other, 
like this: 
 
 
 
As you might expect from the fact that the models are so similar, the structure of 
the Queue class looks very much like its Stack counterpart.  "
stack,"In a stack, the client must add and remove elements from the same 
end of the internal data structure, as follows: 
 
 
 
In a queue, the client adds elements at one end and removes them from the other, 
like this: 
 
 
 
As you might expect from the fact that the models are so similar, the structure of 
the Queue class looks very much like its Stack counterpart.  "
stack,"• You cannot use the range-based for loop in conjunction with the Stack and 
Queue classes.  "
stack,"Allowing unrestricted access to these structures would violate 
the principle that only one element (the element at the top of a stack or the one at 
the head of a queue) is visible at a particular time. 
 
"
stack,"Thus, given the file Macbeth.txt, you would like 
your program to produce something like the following output: 
 
 
 
 Summary 
This chapter introduced the C++ classes Vector, Stack, Queue, Map, and Set that 
together represent a powerful framework for storing collections.  "
stack,"Given that you will 
be implementing them as you complete the text, the classes presented here have 
been simplified to some extent from the vector, stack, queue, map, and set 
classes in the Standard Template Library, although they export a very similar 
collection of methods.  "
stack,"The Stack class represents a collection of objects whose behavior is defined by 
the property that items are removed from a stack in the opposite order from 
which they were added: last in, first out (LIFO).  "
stack,"The Stack class represents a collection of objects whose behavior is defined by 
the property that items are removed from a stack in the opposite order from 
which they were added: last in, first out (LIFO).  "
stack,"The fundamental operations on 
a stack are push, which adds a value to the stack, and pop, which removes and 
returns the value most recently pushed. 
"
stack,"The fundamental operations on 
a stack are push, which adds a value to the stack, and pop, which removes and 
returns the value most recently pushed. 
"
stack,"The Queue class is similar to the Stack class except for the fact that elements 
are removed from a queue in the same order in which they were added: first in, 
first out (FIFO).   "
stack,"• With the exception of Stack and Queue, all collection classes support the the 
range-based for loop pattern, which makes it easy to cycle through the elements 
of the collection.  "
stack,"How do these terms apply 
to stacks and queues? 
 
"
stack,"What are the names of the two fundamental operations for a stack? 
 
"
stack,"What does the peek operation do in each of the Stack and Queue classes? 
 
"
stack,"What reason does the chapter offer for disallowing the use of the range-based 
for loop with the Stack and Queue classes? 
 
"
stack,"Write a program that uses a stack to reverse a sequence of integers read from 
the console one number per line, as shown in the following sample run: 
 
 
 
 
Exercises      255 
13. 
"
stack,"PostScript 
programs store their data on a stack.  "
stack,"Many of the operators available in the 
PostScript language have the effect of manipulating the stack in some way.  
"
stack,"You can, for example, invoke the pop operator, which pops the top element 
off the stack, or the exch operator, which swaps the top two elements. 
 
"
stack,"The effect of 
applying roll(n, k) is to rotate the top n elements of a stack by k positions, 
where the general direction of the rotation is toward the top of the stack.  "
stack,"The effect of 
applying roll(n, k) is to rotate the top n elements of a stack by k positions, 
where the general direction of the rotation is toward the top of the stack.  "
stack,"More 
specifically, roll(n, k) has the effect of removing the top n elements, 
cycling the top element to the last position k times, and then replacing the 
reordered elements back on the stack.  "
stack,"256     Collections 
 
Write a function 
 
void roll(Stack<char> & stack, int n, int k) 
 
that implements the roll(n, k) operation on the specified stack.  "
stack,"256     Collections 
 
Write a function 
 
void roll(Stack<char> & stack, int n, int k) 
 
that implements the roll(n, k) operation on the specified stack.  "
stack,"Your 
implementation should check that n and k are both nonnegative and that n is 
not larger than the stack size; if either of these conditions is violated, your 
implementation should call error with the message 
 
roll: argument out of range 
 
Note, however, that k can be larger than n, in which case the roll operation 
continues through more than a complete cycle.  "
stack,"This case is illustrated in the 
final example in Figure 5-14, in which the top two elements on the stack are 
rolled four times, leaving the stack exactly as it started. 
 
"
stack,"This case is illustrated in the 
final example in Figure 5-14, in which the top two elements on the stack are 
rolled four times, leaving the stack exactly as it started. 
 
"
stack,"For example, if you include the local 
variable declaration 
 
Point p; 
 
in a function, the compiler will reserve space in the stack frame for a variable of 
type Point named p, just as the declaration 
 
int n; 
 
reserves space for a variable of type int named n.  "
stack,"When main calls fact, the computer creates a new 
stack frame and copies the argument value into the formal parameter n.  "
stack,"As before, this 
process requires the creation of a new stack frame, as shown: 
 
 
 
Following the same logic, the program must now call fact(1), which in turn calls 
fact(0), creating two new stack frames, as follows: 
 
 
 
7.2 The factorial function      323 
 
"
stack,"As before, this 
process requires the creation of a new stack frame, as shown: 
 
 
 
Following the same logic, the program must now call fact(1), which in turn calls 
fact(0), creating two new stack frames, as follows: 
 
 
 
7.2 The factorial function      323 
 
"
stack,"Because the value of n is 0, the 
function can return its result immediately by executing the statement 
 
return 1; 
 
The value 1 is returned to the calling frame, which resumes its position on top of the 
stack, as shown: 
 
 
 
From this point, the computation proceeds back through each of the recursive 
calls, completing the calculation of the return value at each level.  "
stack,"In this frame, for 
example, the call to fact(n - 1) can be replaced by the value 1, as shown in the 
diagram for the stack frame.  "
stack,"In this stack frame, n has the value 1, so the result of 
this call is simply 1.  "
stack,"Each call creates a new stack frame that contains the local 
variables for that call.  "
stack,"Because the computer creates a separate stack frame for 
each function call, the local variables at each level of the recursive 
decomposition remain separate. 
"
stack,"Using this 
section as a model, trace through the execution of fib(3), sketching out each 
stack frame created in the process. 
 
"
stack,"Spherical objects, such as cannonballs, can be stacked to form a pyramid with 
one cannonball at the top, sitting on top of a square composed of four 
cannonballs, sitting on top of a square composed of nine cannonballs, and so 
forth.  "
stack,"In particular, you should think about how being able to move a 
stack of seven disks would help you to solve the eight-disk case. 
 
"
stack,"Move the entire stack consisting of the top seven disks from spire A to spire C. 
2. 
"
stack,"Move the stack of seven disks from spire C to spire B. 
 
Executing the first step takes you to the following position: 
 
 
 
Once you have gotten rid of the seven disks on top of the largest disk, the second 
step is simply to move that disk from spire A to spire B, which results in the 
following configuration: 
 
 
 
All that remains is to move the tower of seven disks back from spire C to spire B, 
which is again a smaller problem of the same form.  "
stack,"3. 
Move the stack of N–1 disks from the temporary spire back to the finish spire. 
 
"
stack,"For each new function 
call, you introduce a stack frame that shows the values of the parameters for that 
call.  "
stack,"The initial call to moveTower, for example, creates the following stack frame: 
 
 
 
As the arrow in the code indicates, the function has just been called, so execution 
begins with the first statement in the function body.  "
stack,"358     Recursive Strategies 
Whenever you need to find the value of a variable, you use the value as it is defined 
in the current stack frame.  "
stack,"To trace the 
operation of the new function call, you need to generate a new stack frame and 
repeat the process.  "
stack,"As always, the parameters in the new stack frame are copied 
from the calling arguments in the order in which they appear.  "
stack,"Thus, the new stack 
frame looks like this: 
 
 
 
As the diagram illustrates, the new stack frame has its own set of variables, which 
temporarily supersede the variables in frames that are further down on the stack.  
"
stack,"Thus, the new stack 
frame looks like this: 
 
 
 
As the diagram illustrates, the new stack frame has its own set of variables, which 
temporarily supersede the variables in frames that are further down on the stack.  
"
stack,"Thus, the new stack 
frame looks like this: 
 
 
 
As the diagram illustrates, the new stack frame has its own set of variables, which 
temporarily supersede the variables in frames that are further down on the stack.  
"
stack,"Thus, as long as the program is executing in this stack frame, n will have the value 
2, start will be 'A', finish will be 'C', and tmp will be 'B'.  "
stack,"Once again, n is not 1, which requires another call of the form 
 
moveTower(n-1, start, tmp, finish); 
 
Because this call comes from a different stack frame, however, the value of the 
individual variables are different from those in the original call.  "
stack,"If you evaluate the 
arguments in the context of the current stack frame, you discover that this function 
call is equivalent to 
 
moveTower(1, 'A', 'B', 'C'); 
 
The effect of making this call is to introduce yet another stack frame for the 
moveTower function, as follows: 
 
 
8.1 The Towers of Hanoi      359 
 
 
This call to moveTower, however, does represent the simple case.  "
stack,"If you evaluate the 
arguments in the context of the current stack frame, you discover that this function 
call is equivalent to 
 
moveTower(1, 'A', 'B', 'C'); 
 
The effect of making this call is to introduce yet another stack frame for the 
moveTower function, as follows: 
 
 
8.1 The Towers of Hanoi      359 
 
 
This call to moveTower, however, does represent the simple case.  "
stack,"In the process, its stack frame is discarded, which brings the execution 
back to the previous stack frame, having just completed the first statement in the 
else clause: 
 
 
 
"
stack,"In the process, its stack frame is discarded, which brings the execution 
back to the previous stack frame, having just completed the first statement in the 
else clause: 
 
 
 
"
stack,"The call to moveSingleDisk again represents a simple operation, which leaves 
the puzzle in the following state: 
 
 
 
360     Recursive Strategies 
With the moveSingleDisk operation completed, the only remaining step 
required to finish the current call to moveTower is the last statement in the function: 
 
moveTower(n-1, tmp, finish, start); 
 
Evaluating these arguments in the context of the current frame reveals that this call 
is equivalent to 
 
moveTower(1, 'B', 'C', 'A'); 
 
Once again, this call requires the creation of a new stack frame.  "
stack,"Internally, 
the function determines that n is 1 and then calls moveSingleDisk to reach the 
following configuration: 
 
 
 
This operation again completes a call to moveTower, allowing it to return to its 
caller having completed the subtask of moving a tower of size 2 from A to C.  
Discarding the stack frame from the just-completed subtask reveals the stack frame 
for the original call to moveTower, which is now in the following state: 
 
 
 
"
stack,"Internally, 
the function determines that n is 1 and then calls moveSingleDisk to reach the 
following configuration: 
 
 
 
This operation again completes a call to moveTower, allowing it to return to its 
caller having completed the subtask of moving a tower of size 2 from A to C.  
Discarding the stack frame from the just-completed subtask reveals the stack frame 
for the original call to moveTower, which is now in the following state: 
 
 
 
"
stack,"The next step is to call moveSingleDisk to move the largest disk from A to B, 
which results in the following position: 
 
 
 
The only operation that remains is to call 
 
 
8.2 The subset-sum problem      361 
moveTower(n-1, tmp, finish, start); 
 
with the arguments from the current stack frame, which are 
 
moveTower(2, 'C', 'B', 'A'); 
 
If you’re still suspicious of the recursive process, you can draw the stack frame 
created by this function call and continue tracing the process to its ultimate 
conclusion.  "
stack,"The next step is to call moveSingleDisk to move the largest disk from A to B, 
which results in the following position: 
 
 
 
The only operation that remains is to call 
 
 
8.2 The subset-sum problem      361 
moveTower(n-1, tmp, finish, start); 
 
with the arguments from the current stack frame, which are 
 
moveTower(2, 'C', 'B', 'A'); 
 
If you’re still suspicious of the recursive process, you can draw the stack frame 
created by this function call and continue tracing the process to its ultimate 
conclusion.  "
stack,"If you need to do so, you can simulate the operation of 
the computer yourself by drawing the stack frames for every procedure that is 
called in the course of the solution.  "
stack,"b. Move a stack of N–1 disks from the start spire to the finish spire. 
"
stack,"3. 
Rewrite the Towers of Hanoi program so that it uses an explicit stack of 
pending tasks instead of recursion.  "
stack,"At 
the beginning of the process, you push onto your stack a single task that 
describes the process of moving the entire tower.  "
stack,"The program then 
repeatedly pops the stack and executes the task found there until no tasks are 
left.  "
stack,"Except for the simple cases, the process of executing a task results in the 
creation of more tasks that get pushed onto the stack for later execution. 
 
4. 
"
stack,"The recursion systematically explores 
every corridor along this path, backing up through the stack of recursive calls 
whenever it reaches a dead end.  "
stack,"Moreover, this condition rules out recursive solutions, because the 
space required to store the stack frames would grow with the depth of the 
recursion. 
"
stack,"Moreover, this condition rules out recursive solutions, because the 
space required to store the stack frames would grow with the depth of the 
recursion. 
"
stack,The highest addresses in memory represent the stack area.  
stack,"Each time your 
program calls a function or a method, the computer creates a new stack frame in this 
memory region.  "
stack,"When that function returns, the stack frame is discarded leaving 
the memory free to be used for the stack frames of subsequent calls.  "
stack,"When that function returns, the stack frame is discarded leaving 
the memory free to be used for the stack frames of subsequent calls.  "
stack,"The structure 
of these stack frames is described in more detail in the next section. 
 
"
stack,"The region of memory between the end of the program data and the stack is 
called the heap area."
stack,"Local variables are allocated in the 
stack region at the high end of memory in a contiguous block of addresses called a 
stack frame.  "
stack,"Local variables are allocated in the 
stack region at the high end of memory in a contiguous block of addresses called a 
stack frame.  "
stack,"You’ve already seen stack frames beginning in Chapter 2, but those 
frames have been represented abstractly as boxes.  "
stack,"Internally, these variables are 
482     Pointers and Arrays 
assigned space in a block that is pushed onto the top of the stack at the time of each 
function call. 
 
"
stack,"To make this discussion concrete, it makes sense to walk through the execution 
of the PowersOfTwo program from Chapter 1 to show exactly what happens on the 
stack.  "
stack,"The stack frame must 
therefore allocate space for these integer variables, as follows: 
 
 
 
 
11.1"
stack,"What you can count on is that 
both of these variables will be allocated in the region assigned to that stack frame.  
"
stack,"If nothing else, each stack frame needs to keep track 
of the location in the program to which it should return.  "
stack,"The stack diagrams in this book include a gray 
rectangle in each stack frame both to remind you that this extra information exists 
and to make it easier to see the extent of each frame visually. 
 
"
stack,"The stack diagrams in this book include a gray 
rectangle in each stack frame both to remind you that this extra information exists 
and to make it easier to see the extent of each frame visually. 
 
"
stack,"When the program runs, each function has access to its own stack frame and 
updates the values of the local variables as they change.  "
stack,"Assuming that the user has 
entered 8 as the value of limit, the situation immediately before the first call to 
raiseToPower looks like this: 
 
 
 
Calling raiseToPower(2, i)creates a new stack frame on top of the existing one.  
"
stack,"The parameter variables are initialized to the values of the 
arguments, which means that the stack now looks like this: 
 
 
 
When raiseToPower returns, its stack frame is discarded, restoring the state 
before the call. 
 
"
stack,"The parameter variables are initialized to the values of the 
arguments, which means that the stack now looks like this: 
 
 
 
When raiseToPower returns, its stack frame is discarded, restoring the state 
before the call. 
 
"
stack,"For concreteness, let’s suppose that these values are stored on 
the stack at the machine addresses indicated by the following diagram: 
 
 
 
Given these declarations, you can assign values to x and y just as you always 
have.  "
stack,"When a parameter is passed by reference, the stack 
frame stores a pointer to the location in the caller at which that value resides.  "
stack,"The contents of 
the stack immediately before that call look like this: 
 
 
 
The function swap takes its parameters by reference, which means that the stack 
frame for swap is given the addresses of the calling arguments rather than the 
values.  "
stack,"The contents of 
the stack immediately before that call look like this: 
 
 
 
The function swap takes its parameters by reference, which means that the stack 
frame for swap is given the addresses of the calling arguments rather than the 
values.  "
stack,"Immediately after the call, the contents of the stack look like this: 
 
 
 
 
11.2 Pointers     493 
"
stack,"Exchanging those values means that the effect 
of this function persists after the call to swap returns, when the stack looks like this: 
 
 
 
The program continues with the updated values, leading to the following output: 
 
494     Pointers and Arrays 
 
 
"
stack,"The declaration 
 
int list[5]; 
 
allocates space for an array of five integers, which is assigned storage in the current 
stack frame, as illustrated in the following diagram: 
 
 
11.3"
stack,"In either 
case, the value stored in the stack frame under the name array is the address of the 
initial element of the calling argument.  "
stack,"If the stack frame begins at location FFA0, the memory looks like this: 
 
 
 
In this diagram, p now points to the initial address in the array list.  "
stack,"Local variables are allocated in a 
region called the stack, which is apportioned into structures called frames that 
contain all of the local variables for a function or method.  "
stack,"• Reference parameters are implemented in C++ by storing a pointer to the calling 
argument in the stack frame. 
"
stack,"Assuming that variables of type int and all pointers require four bytes of 
memory, draw a diagram showing a portion of the stack frame that contains 
the following declarations: 
 
int v1 = 10; 
int v2 = 25; 
int *p1 = &v1; 
int *p2 = &v2; 
 
"
stack,"When you declare a 
local variable inside a function, the space for that variable is allocated on the stack.  
"
stack,"In most modern architectures, memory is arranged so that the heap and the stack 
grow in opposite directions toward each other, as illustrated in the following 
diagram: 
 
 
 
 
12.1 Dynamic allocation and the heap     517 
"
stack,"If the first free word in the heap is located at 
address 1000, the variable ip in the current stack frame will be assigned the address 
of that memory word, as follows: 
 
 
 
Conceptually, the local variable ip on the stack points to the newly allocated word 
on the heap.  "
stack,"If the first free word in the heap is located at 
address 1000, the variable ip in the current stack frame will be assigned the address 
of that memory word, as follows: 
 
 
 
Conceptually, the local variable ip on the stack points to the newly allocated word 
on the heap.  "
stack,"Thus, the declaration 
 
double *array = new double[3]; 
 
initializes array so that it points to a contiguous block of memory large enough to 
hold three doubles, like this: 
 
 
 
The variable array is now a fully functioning array whose storage lives in the heap 
rather than on the stack.  "
stack,"In most cases, objects are 
declared as local variables within some function, which means that they are 
allocated on the stack.  "
stack,"The easiest container class to implement is the Stack class, mostly because it 
exports the smallest number of methods.  "
stack,"To make the implementation even 
simpler, however, it makes sense to restrict the elements in the stack to a single data 
type—in this case a stack of characters that will turn out to be useful in Chapter 13.  
"
stack,"To make the implementation even 
simpler, however, it makes sense to restrict the elements in the stack to a single data 
type—in this case a stack of characters that will turn out to be useful in Chapter 13.  
"
stack,"You will have a chance to write the polymorphic version of the Stack class when 
you learn about the template facility described in Chapter 14.  "
stack,"At the moment, the 
goal is to see how classes like Stack use dynamic allocation to manage memory.  
"
stack,"For that purpose, the base type of the stack is not important, and the character stack 
will be sufficient to illustrate the general principles. 
 
"
stack,"For that purpose, the base type of the stack is not important, and the character stack 
will be sufficient to illustrate the general principles. 
 
"
stack,"The entries 
exported by the interface include the default constructor, a destructor, and the 
various methods—size, isEmpty, clear, push, pop, and peek—that define the 
behavior of the stack abstraction.  "
stack,"In the next few sections, you’ll have 
a chance to explore several possible representations for the character stack, each of 
which requires you to replace the box in Figure 12-4 with a different piece of code 
appropriate for that representation. 
 
"
stack,"Choosing a representation for the character stack 
When you set out to design the underlying data structure for a class, the first 
question you should ask yourself is what information needs to be stored inside each 
object.  "
stack,"A character stack must keep track of the characters that have been pushed in 
the order in which they appear.  "
stack,"As with any collection class, there is no reason to 
put an arbitrary limit on the number of characters the stack can contain.  "
stack,"As you think about what such a structure might look like, one idea you will 
probably consider is to use a Vector<char> to hold the elements of the stack.  
"
stack,"Moreover, as 
a software-engineering strategy, there is absolutely nothing wrong with using 
vectors to implement stacks.  "
stack,"The library version of the Stack class does just that.  
"
stack,"Implementing vectors turns out to be considerably more complicated than 
implementing stacks.  "
stack,"In 
the case of the character stack, using the built-in array type to store the elements has 
the advantage that an array hides nothing.  "
stack,"As noted at the beginning of this section, whatever representation 
you use to store the characters in the stack must allow for expansion.  "
stack,"To store the stack elements, the new version of the private section needs to keep 
track of several variables.  "
stack,"It also needs to keep track of 
how many elements have been allocated to that array so that the implementation can 
tell when the stack runs out of space and needs to reallocate its internal storage.  
"
stack,"Including these three instance variables in the private 
section makes it possible to implement the stack operations using nothing more 
complicated than array operations.  "
stack,"The constructor, for 
example, must initialize the internal data structure to represent an empty stack.  "
stack,"The 
count variable must be zero, but there is no reason not to provide the stack with 
some initial capacity.  "
stack,"Choosing a large value reduces the 
chance that the stack will have to expand and therefore saves execution time; 
choosing a small one conserves memory.  "
stack,"The most significant change from the vector-based implementation occurs in the 
push method, which adds a new character to the top of the stack.  "
stack,"The implementation of the CharStack class takes care of freeing the heap memory 
used by a character stack as soon as it goes out of scope. 
 
 "
stack,"12.5 Heap-stack diagrams 
It is difficult to understand how memory allocation works without drawing lots of 
pictures.  "
stack,"In my experience, the single best tool for visualizing the allocation 
process is the heap-stack diagram, in which you diagram the state of memory on 
both the heap and the stack.  "
stack,"In my experience, the single best tool for visualizing the allocation 
process is the heap-stack diagram, in which you diagram the state of memory on 
both the heap and the stack.  "
stack,"Dynamically allocated memory created using the new 
 
12.5 Heap-stack diagrams     537 
operator appears on the left hand side of the diagram, which represents the heap.  
"
stack,"The stack frames for each function call appear on the right. 
 
"
stack,"Unlike the process of writing code, which invariably requires creativity, drawing 
heap-stack diagrams is essentially a mechanical activity.  "
stack,"The best way to understand how to create heap-stack diagrams is to go through 
an example.  "
stack,"The focus of this example is not on what the program does, 
but rather on how it allocates memory on the stack and the heap.  "
stack,"The rest of this 
section traces the execution of the program in the form of a series of heap-stack 
diagrams constructed according to the process outlined in Figure 12-9.  "
stack,"Before any initialization, the stack frame therefore 
looks like this (nothing has yet been allocated on the heap, so that side of the 
diagram is empty): 
 
538     Dynamic Memory Management 
 
 
1."
stack,"Before you begin, draw a vertical line on the page to separate the heap space from 
the stack space.  "
stack,"In a typical machine, the heap expands 
towards larger memory addresses and thus grows downward on the page; the stack, by contrast grows in the 
opposite direction and therefore grows upward on the page.  "
stack,"The diagrams in this book make 1000 the first 
address in the heap and FFFF the last byte in the stack, but these choices are simply a convention. 
"
stack,3. Add a new stack frame for each function or method call.  
stack,"Every time the program begins a function call 
(including the initial call to main), new memory is allocated on the stack side of the diagram to store the stack 
frame for that call.  "
stack,"Every time the program begins a function call 
(including the initial call to main), new memory is allocated on the stack side of the diagram to store the stack 
frame for that call.  "
stack,"Drawing a stack frame is worth describing in a step-by-step process of its own. 
"
stack,Include space in the stack frame for all local variables declared by the function.  
stack,"The size of the stack 
frame you create depends on the number of variables it declares.  "
stack,"For each variable you find, allocate as much 
space in the stack frame as that variable requires, and then label the space with the variable name.  
"
stack,"If the call is a 
method call, the stack frame should also include a cell labeled this pointing to the current object.  "
stack,"The 
order of variables within a stack frame is arbitrary, so you can arrange them in any order you want. 
3c) Initialize the parameters by copying the values of the actual arguments.  "
stack,"After you have drawn the 
variables in the stack frame, you need to copy the argument values into the parameter variables, keeping in 
mind that the association is determined by the order of the arguments and not by their names.  "
stack,Pop the entire stack frame when the function returns.  
stack,"When you finish executing a function, the stack 
frame that it was using is automatically reclaimed.  "
stack,"12.5 Heap-stack diagrams     539 
 
 
Declaring an object in C++ automatically invokes its constructor, so the first 
thing that happens is a call to the CharStack constructor.  "
stack,"Even though the 
constructor takes no arguments and declares no local variables, the stack frame still 
contains an entry named this that points to the current object, since every method 
call includes this entry as an implicit parameter.  "
stack,"The 
last line initializes the count to zero to indicate that the stack is empty.  "
stack,"The 
contents of the heap and stack now look like this: 
 
 
 
540     Dynamic Memory Management 
The constructor then returns, leaving the object initialized as shown. 
 
"
stack,"The next nine cycles of the for loop proceed in the same way, filling up the 
available capacity in the stack: 
 
 
 
 
12.5 Heap-stack diagrams     541 
At this point, the next call to cstk.push creates a new frame as it prepares to push 
the character 'K' on the stack: 
 
 
 
The difference this time around is that count is equal to capacity, indicating that 
the existing array of characters is full.  "
stack,"The next nine cycles of the for loop proceed in the same way, filling up the 
available capacity in the stack: 
 
 
 
 
12.5 Heap-stack diagrams     541 
At this point, the next call to cstk.push creates a new frame as it prepares to push 
the character 'K' on the stack: 
 
 
 
The difference this time around is that count is equal to capacity, indicating that 
the existing array of characters is full.  "
stack,"The next nine cycles of the for loop proceed in the same way, filling up the 
available capacity in the stack: 
 
 
 
 
12.5 Heap-stack diagrams     541 
At this point, the next call to cstk.push creates a new frame as it prepares to push 
the character 'K' on the stack: 
 
 
 
The difference this time around is that count is equal to capacity, indicating that 
the existing array of characters is full.  "
stack,"This condition triggers a call to the private 
method expandCapacity, which leads to the creation of another stack frame.  "
stack,"The 
expandCapacity method declares the local variables oldArray and i, which 
means that these variables appear in the stack frame, along with the pointer to the 
current object.  "
stack,"The resulting stack frame appears at the top of the following 
diagram: 
 
 
 
The operation of expandCapacity is sufficiently interesting that it makes sense 
to go through the process in more detail.  "
stack,"The destructor ensures that the dynamic array storage 
allocated during the lifetime of the character stack is returned to the heap. 
 
 "
stack,"12.6 Unit testing 
The main program in the preceding section is useful as an illustration of heap-stack 
diagrams but does not really constitute an adequate test of the CharStack class, 
even if you were to display the contents of the stack by popping the letters and 
printing them out in reverse order.  "
stack,"12.6 Unit testing 
The main program in the preceding section is useful as an illustration of heap-stack 
diagrams but does not really constitute an adequate test of the CharStack class, 
even if you were to display the contents of the stack by popping the letters and 
printing them out in reverse order.  "
stack,"Tracing your code by hand—using 
heap-stack diagrams or whatever strategies seem most helpful—can often reveals 
bugs before the formal testing phase even begins.  "
stack,"To get more of a sense of the importance of this problem, think about what 
happens if you call the following code: 
 
CharStack s1, s2; 
s1.push('A'); 
s2 = s1; 
 
What you want this program to do is initialize s2 to be a copy of s1, which means 
that both stacks would contain the character A at the top of an independent stack.  
"
stack,"To get more of a sense of the importance of this problem, think about what 
happens if you call the following code: 
 
CharStack s1, s2; 
s1.push('A'); 
s2 = s1; 
 
What you want this program to do is initialize s2 to be a copy of s1, which means 
that both stacks would contain the character A at the top of an independent stack.  
"
stack,"The easiest way to see how this code works is to draw a heap-stack diagram 
showing the state of memory at the end of this sequence of statements.  "
stack,"If you were 
to pop the top character off stack s2 and then push some other character, that 
operation would change the contents of s1 as well, which is not what you want if 
the stacks are supposed to be independent copies. 
 
"
stack,"If you were 
to pop the top character off stack s2 and then push some other character, that 
operation would change the contents of s1 as well, which is not what you want if 
the stacks are supposed to be independent copies. 
 
"
stack,"Without this test, assigning a CharStack object to itself would end up freeing the 
array before calling deepCopy to copy that data into the destination stack.  "
stack,"In the case of the CharStack class for example, the push, pop, and clear 
methods all change the contents of the stack.  "
stack,"For 
example, the prototype for the size method in the charstack.h file should be 
written using the keyword const to let the compiler know that it leaves the stack 
unchanged, like this: 
 
int size() const; 
 
"
stack,"For the CharStack class, most of the methods run in constant time as a function 
of the current size of the stack.  "
stack,"*/
void CharStack::expandCapacity() {
   char *oldArray = array;
   capacity *= 2;
   array = new char[capacity];
   for (int i = 0; i < count; i++) {
      array[i] = oldArray[i];
   }
   delete[] oldArray;
}
 
12.9 Efficiency of the CharStack class     559 
of the stack makes any difference at all.  "
stack,"If, 
however, the array is full, the expandCapacity method has to copy the contents of 
that array into newly allocated memory, which will run more slowly as the stack 
grows larger.  "
stack,"In 
particular, if pushing one item on the stack triggers an expansion that makes that 
particular call run in O(N) time, the cost of pushing the next item is guaranteed to be 
O(1) because the capacity has already been expanded.  "
stack,Every push operation incurs some cost whether or not the stack is expanded.  
stack,"N.  Every so often, however, the implementation needs to expand the 
capacity of the internal array, which is a linear-time operation that costs some 
constant "" times the number of characters on the stack. 
 
"
stack,"In that case, the 
final push operation incurs an additional cost of ""N.  Given that expandCapacity 
always doubles the size of the array, the capacity also had to be expanded when the 
stack was half as large as N, a quarter as large as N, and so on.  "
stack,"The task of memory management in C++ is simplified considerably by the 
existence of destructors, which are called automatically when the stack frame 
containing that object disappears at the end of a method call.  "
stack,"• Heap-stack diagrams are useful in understanding how C++ allocates memory.  
"
stack,"Each function or method call creates a new stack frame with space for the local 
variables declared by that function.  "
stack,"Stack memory is reclaimed 
automatically when a function returns. 
"
stack,"Why does it make sense to start the heap and the stack at opposite ends of 
memory and have them grow toward each other? 
 
"
stack,When is new memory added to the stack side of a heap-stack diagram?  
stack,When is new memory added to the stack side of a heap-stack diagram?  
stack,"When is new memory added to the heap side of a heap-stack diagram and 
when is it reclaimed? 
 
"
stack,"What reasons does the chapter give for including the overhead word in 
heap-stack diagrams? 
 
"
stack,"How do you represent a reference parameter in a heap-stack diagram? 
 
"
stack,"What additional local variable gets added to a stack frame when you call a 
method as opposed to a function? 
 
"
stack,"Draw a 
heap-stack diagram showing the contents of memory just before the function 
initPair returns.  "
stack,"As in the preceding exercise, draw a heap-stack diagram showing the state of 
memory at the indicated point in Figure 12-16, which asks you to diagram 
memory during the second call to the constructor. 
"
stack,"566     Dynamic Memory Management 
Heap-stack exercise figures 
 
Exercises     567 
9. 
"
stack,"This chapter implements the editor buffer abstraction using three different 
underlying representations—a character array, a pair of character stacks, and a 
linked list of characters—and evaluates their advantages and disadvantages. 
 
"
stack,"A stack-based implementation 
The problem with the array implementation of the editor buffer is that insertions and 
deletions run slowly when they occur near the beginning of the buffer.  "
stack,"Because all changes to the buffer occur at the cursor 
position, each of those structures behaves like a stack and can be represented using 
the CharStack class introduced in Chapter 12.  "
stack,"The characters that precede the 
cursor are pushed on one stack so that the beginning of the buffer is at the base and 
the character just before the pointer is at the top.  "
stack,"The characters after the cursor are 
stored in the opposite direction, with the end of the buffer at the base of the stack 
and the character just after the pointer at the top. 
 
"
stack,"If the buffer contains 
 
 
 
the two-stack representation of the buffer looks like this: 
 
 
 
To read the contents of the buffer, it is necessary to read up through the characters 
in the before stack and then down the after stack, as indicated by the arrow. 
 
"
stack,"If the buffer contains 
 
 
 
the two-stack representation of the buffer looks like this: 
 
 
 
To read the contents of the buffer, it is necessary to read up through the characters 
in the before stack and then down the after stack, as indicated by the arrow. 
 
"
stack,"If the buffer contains 
 
 
 
the two-stack representation of the buffer looks like this: 
 
 
 
To read the contents of the buffer, it is necessary to read up through the characters 
in the before stack and then down the after stack, as indicated by the arrow. 
 
"
stack,"A stack-based implementation     587 
 
Defining the private data structure 
Using this strategy, the instance variables for a buffer object are a pair of stacks, one 
to hold the characters before the cursor and another to hold the ones that come after 
it.  "
stack,"A stack-based implementation     587 
 
Defining the private data structure 
Using this strategy, the instance variables for a buffer object are a pair of stacks, one 
to hold the characters before the cursor and another to hold the ones that come after 
it.  "
stack,"For the stack-based buffer, the private section of the class declares only the two 
instance variables shown in Figure 13-6.  "
stack,"Note that the cursor is not explicitly 
represented in this model but is instead simply the boundary between the two stacks. 
 
"
stack,"Implementing the buffer operations 
In the stack model, implementing most of the operations for the editor is 
surprisingly easy.  "
stack,"For example, moving backward consists of popping a character 
from the before stack and pushing it back on the after stack.  "
stack,"For example, moving backward consists of popping a character 
from the before stack and pushing it back on the after stack.  "
stack,"Inserting a character consists of pushing that character on the 
before stack.  "
stack,"Deleting a character consists of popping a character from the after 
stack and throwing it away. 
 
"
stack,"This conceptual outline makes it easy to write the code for the stack-based 
editor, which appears in Figure 13-7.  "
stack,"Four of the commands—insertCharacter, 
deleteCharacter, moveCursorForward, and moveCursorBackward—run in 
constant time because the stack operations they call are themselves O(1) operations. 
 
"
stack,"588     Efficiency and Representation 
buffer.cpp (stack), p1 
 
13.4 A stack-based implementation     589 
buffer.cpp (stack), p2 
590     Efficiency and Representation 
"
stack,"588     Efficiency and Representation 
buffer.cpp (stack), p1 
 
13.4 A stack-based implementation     589 
buffer.cpp (stack), p2 
590     Efficiency and Representation 
"
stack,"588     Efficiency and Representation 
buffer.cpp (stack), p1 
 
13.4 A stack-based implementation     589 
buffer.cpp (stack), p2 
590     Efficiency and Representation 
"
stack,"The moveCursorToStart and 
moveCursorToEnd methods each require the program to transfer the entire 
contents of one of the stacks to the other.  "
stack,"Given the operations provided by the 
CharStack class, the only way to accomplish this operation is to pop values from 
one stack and push them back on the other stack, one value at a time, until the 
original stack is empty.  "
stack,"Given the operations provided by the 
CharStack class, the only way to accomplish this operation is to pop values from 
one stack and push them back on the other stack, one value at a time, until the 
original stack is empty.  "
stack,"Given the operations provided by the 
CharStack class, the only way to accomplish this operation is to pop values from 
one stack and push them back on the other stack, one value at a time, until the 
original stack is empty.  "
stack,"Comparing computational complexities 
Table 13-3 shows the computational complexity of the editor operations for both the 
array- and the stack-based implementations of the editor.  "
stack,"Knowing a little about the way that people use editors, however, 
suggests that the stack-based strategy is likely to be more efficient because the slow 
operations for the array implementation (insertion and deletion) are used much more 
frequently than the slow operations for the stack implementation (moving the cursor 
a long distance). 
 
"
stack,"Knowing a little about the way that people use editors, however, 
suggests that the stack-based strategy is likely to be more efficient because the slow 
operations for the array implementation (insertion and deletion) are used much more 
frequently than the slow operations for the stack implementation (moving the cursor 
a long distance). 
 
"
stack,"A list-based implementation     591 
given the array implementation but fast when using the stack approach.  "
stack,"By 
contrast, moving to the front of the buffer is fast in the array case but slow in the 
stack case.  "
stack,"Using a 
pair of stacks, for example, reduces the cost of insertion and deletion at the cost 
of making it harder to move the cursor a long distance. 
"
stack,"7. 
Draw a diagram showing the contents of the before and after stack in the 
two-stack representation of a buffer that contains the following text, with the 
cursor positioned as shown: 
 
 
 
8. 
"
stack,"7. 
Draw a diagram showing the contents of the before and after stack in the 
two-stack representation of a buffer that contains the following text, with the 
cursor positioned as shown: 
 
 
 
8. 
"
stack,"How is the cursor position indicated in the two-stack representation of the 
editor buffer? 
 
"
stack,"Which editor operations require linear time in the two-stack representation? 
 
"
stack,"Even though the stacks in the two-stack implementation of the EditorBuffer 
class (see Figures 13-6 and 13-7) expand dynamically, the amount of character 
space required in the stacks is likely to be twice as large as that required in the 
corresponding array implementation.  "
stack,"Even though the stacks in the two-stack implementation of the EditorBuffer 
class (see Figures 13-6 and 13-7) expand dynamically, the amount of character 
space required in the stacks is likely to be twice as large as that required in the 
corresponding array implementation.  "
stack,"Even though the stacks in the two-stack implementation of the EditorBuffer 
class (see Figures 13-6 and 13-7) expand dynamically, the amount of character 
space required in the stacks is likely to be twice as large as that required in the 
corresponding array implementation.  "
stack,"The problem is that each stack must be 
able to accommodate all the characters in the buffer.  "
stack,"If you’re at the 
beginning of the buffer, those N characters are in the after stack; if you move 
to the end of the buffer, those N characters move to the before stack.  "
stack,"If you’re at the 
beginning of the buffer, those N characters are in the after stack; if you move 
to the end of the buffer, those N characters move to the before stack.  "
stack,"As a 
result, each of the stacks must have a capacity of N characters. 
 
"
stack,"You can reduce the storage requirement in the two-stack implementation of 
the buffer by storing the two stacks at opposite ends of the same internal array.  
"
stack,"You can reduce the storage requirement in the two-stack implementation of 
the buffer by storing the two stacks at opposite ends of the same internal array.  
"
stack,"The before stack starts at the beginning of the array, while the after stack 
starts at the end.  "
stack,"The before stack starts at the beginning of the array, while the after stack 
starts at the end.  "
stack,"The two stacks then grow toward each other as indicated by 
the arrows in the following diagram: 
 
 
 
Reimplement the EditorBuffer class using this representation (which is, in 
fact, the design strategy used in many editors today).  "
stack,"Make sure that your 
program continues to have the same computational efficiency as the two-stack 
implementation in the text and that the buffer space expands dynamically as 
needed. 
 
"
stack,"— Jane Austen, Persuasion, 1818 
616     Linear Structures 
The Stack, Queue, and Vector classes introduced in Chapter 5 are examples of a 
general category of abstract data types called linear structures, in which the 
elements are arranged in a linear order.  "
stack,"Stacks, 
queues, and vectors can also be implemented using a linked list much like the one 
used to implement the editor buffer in Chapter 13.  "
stack,"The actual Stack class allows the client to specify the type of 
value by providing a type parameter, as in Stack<int> or Stack<Point>.  "
stack,"The actual Stack class allows the client to specify the type of 
value by providing a type parameter, as in Stack<int> or Stack<Point>.  "
stack,"The actual Stack class allows the client to specify the type of 
value by providing a type parameter, as in Stack<int> or Stack<Point>.  "
stack,"Implementing stacks      619 
have access to the template implementation when it encounters a call to a template 
function.  "
stack,"14.2 Implementing stacks 
The CharStack class in Chapter 12 defines the relevant operations that all stacks 
require, but is limited because it can only store elements of type char.  "
stack,"14.2 Implementing stacks 
The CharStack class in Chapter 12 defines the relevant operations that all stacks 
require, but is limited because it can only store elements of type char.  "
stack,"To gain the 
flexibility of the library version of the Stack class, it is necessary to reimplement 
Stack as a template class, which is a class that uses the C++ template facility so 
that is works with any data type. 
 
"
stack,"To gain the 
flexibility of the library version of the Stack class, it is necessary to reimplement 
Stack as a template class, which is a class that uses the C++ template facility so 
that is works with any data type. 
 
"
stack,"For example, if you want to update the CharStack class from Chapter 12 
with a general Stack template, you begin by replacing the name CharStack with 
Stack and then add the following line before the class definition: 
 
template <typename ValueType> 
 
The template keyword indicates that the entire syntactic unit that follows this 
line—in this case the class definition—is part of a template pattern that can be used 
for many different values of the ValueType parameter.  "
stack,"For example, if you want to update the CharStack class from Chapter 12 
with a general Stack template, you begin by replacing the name CharStack with 
Stack and then add the following line before the class definition: 
 
template <typename ValueType> 
 
The template keyword indicates that the entire syntactic unit that follows this 
line—in this case the class definition—is part of a template pattern that can be used 
for many different values of the ValueType parameter.  "
stack,"In the for the Stack class, 
for example, you need to use the placeholder name ValueType wherever you refer 
to the type of element being stored.  "
stack,"As with the listing of the buffer.h interface in 
Chapter 13, the contents of the private section of the Stack class appear as a blue 
box that will be replaced by the definitions appropriate to a particular 
representation.  "
stack,"The fact that Stack is a template class, however, also means that 
the compiler must have access to the implementation along with the class definition 
itself.  "
stack,"In the sections 
that follow, these blue boxes will be replaced by two different underlying 
representations for the stack class: one that uses a dynamic array to store the values 
and a second that uses a linked list. 
 
"
stack,"620     Linear Structures 
stack.h, p1 
 
14.2 Implementing stacks      621 
stack.p2 
622     Linear Structures 
Implementing stacks using a dynamic array 
The most straightforward strategy for implementing the template version of the 
stack class is simply to adopt the dynamic-array model used for the CharStack 
class in Chapter 12.  "
stack,"620     Linear Structures 
stack.h, p1 
 
14.2 Implementing stacks      621 
stack.p2 
622     Linear Structures 
Implementing stacks using a dynamic array 
The most straightforward strategy for implementing the template version of the 
stack class is simply to adopt the dynamic-array model used for the CharStack 
class in Chapter 12.  "
stack,"620     Linear Structures 
stack.h, p1 
 
14.2 Implementing stacks      621 
stack.p2 
622     Linear Structures 
Implementing stacks using a dynamic array 
The most straightforward strategy for implementing the template version of the 
stack class is simply to adopt the dynamic-array model used for the CharStack 
class in Chapter 12.  "
stack,"As in the earlier example, the underlying representation of the 
Stack must keep track of a dynamic array of values, the capacity of that array, and 
the current count of the number of elements.  "
stack,"The private section for the 
array-based stack appears in Figure 14-2. 
 
"
stack,"The only substantive change is that 
the template version of the Stack class implements overloaded versions of the copy 
constructor and the assignment operator to ensure that clients can copy values of 
type Stack.  "
stack,"The only substantive change is that 
the template version of the Stack class implements overloaded versions of the copy 
constructor and the assignment operator to ensure that clients can copy values of 
type Stack.  "
stack,"14.2 Implementing stacks      623 
stack-impl, p1 
624     Linear Structures 
stack-impl, p2 
 
14.2 Implementing stacks      625 
Implementing stacks as linked lists 
Although arrays are the most common underlying representation for stacks, it is also 
possible to implement the Stack class using linked lists.  "
stack,"14.2 Implementing stacks      623 
stack-impl, p1 
624     Linear Structures 
stack-impl, p2 
 
14.2 Implementing stacks      625 
Implementing stacks as linked lists 
Although arrays are the most common underlying representation for stacks, it is also 
possible to implement the Stack class using linked lists.  "
stack,"14.2 Implementing stacks      623 
stack-impl, p1 
624     Linear Structures 
stack-impl, p2 
 
14.2 Implementing stacks      625 
Implementing stacks as linked lists 
Although arrays are the most common underlying representation for stacks, it is also 
possible to implement the Stack class using linked lists.  "
stack,"14.2 Implementing stacks      623 
stack-impl, p1 
624     Linear Structures 
stack-impl, p2 
 
14.2 Implementing stacks      625 
Implementing stacks as linked lists 
Although arrays are the most common underlying representation for stacks, it is also 
possible to implement the Stack class using linked lists.  "
stack,"14.2 Implementing stacks      623 
stack-impl, p1 
624     Linear Structures 
stack-impl, p2 
 
14.2 Implementing stacks      625 
Implementing stacks as linked lists 
Although arrays are the most common underlying representation for stacks, it is also 
possible to implement the Stack class using linked lists.  "
stack,"14.2 Implementing stacks      623 
stack-impl, p1 
624     Linear Structures 
stack-impl, p2 
 
14.2 Implementing stacks      625 
Implementing stacks as linked lists 
Although arrays are the most common underlying representation for stacks, it is also 
possible to implement the Stack class using linked lists.  "
stack,"14.2 Implementing stacks      623 
stack-impl, p1 
624     Linear Structures 
stack-impl, p2 
 
14.2 Implementing stacks      625 
Implementing stacks as linked lists 
Although arrays are the most common underlying representation for stacks, it is also 
possible to implement the Stack class using linked lists.  "
stack,"If you do so, the 
conceptual representation for the empty stack is simply the NULL pointer: 
 
 
 
626     Linear Structures 
When you push a new element onto the stack, the element is simply added to the 
front of the linked-list chain.  "
stack,"If you do so, the 
conceptual representation for the empty stack is simply the NULL pointer: 
 
 
 
626     Linear Structures 
When you push a new element onto the stack, the element is simply added to the 
front of the linked-list chain.  "
stack,"Thus, if you push the element e1 onto an empty stack, 
that element is stored in a new cell that becomes the only link in the chain: 
 
 
 
Pushing a new element onto the stack adds that element at the beginning of the 
chain.  "
stack,"Thus, if you push the element e1 onto an empty stack, 
that element is stored in a new cell that becomes the only link in the chain: 
 
 
 
Pushing a new element onto the stack adds that element at the beginning of the 
chain.  "
stack,"Thus, if you push the element e2 on the stack, you get the following configuration: 
 
 
 
In the linked-list representation, the pop operation consists of removing the first 
cell in the chain and returning the value stored there.  "
stack,"Thus, a pop operation from 
the stack shown in the preceding diagram returns e2 and restores the previous state 
of the stack, as follows: 
 
 
 
Although it would be possible to store only the pointer to the start of the linked 
list in the underlying representation, doing so has an unfortunate consequence for 
the efficiency of the size method.  "
stack,"Thus, a pop operation from 
the stack shown in the preceding diagram returns e2 and restores the previous state 
of the stack, as follows: 
 
 
 
Although it would be possible to store only the pointer to the start of the linked 
list in the underlying representation, doing so has an unfortunate consequence for 
the efficiency of the size method.  "
stack,"A more complete picture of a stack 
containing two items therefore looks like this: 
 
 
 
 
14.2 Implementing stacks      627 
"
stack,"A more complete picture of a stack 
containing two items therefore looks like this: 
 
 
 
 
14.2 Implementing stacks      627 
"
stack,"The contents of the revised private section of the stack.h interface for the 
list-based stack appear in Figure 14-4.  "
stack,"Once you have defined the data structure, 
you can then move on to rewrite the Stack class methods so that they operate on 
the new data representation.  "
stack,"The 
constructor in Figure 14-5 initializes these fields explicitly, as follows: 
 
template <typename ValueType> 
Stack<ValueType>::Stack() { 
   list = NULL; 
   count = 0; 
} 
 
F I G U R E  1 4 - 4
Private section for the list-based stack 
/* Private section */
private:
/*
 *"
stack,"The 
constructor in Figure 14-5 initializes these fields explicitly, as follows: 
 
template <typename ValueType> 
Stack<ValueType>::Stack() { 
   list = NULL; 
   count = 0; 
} 
 
F I G U R E  1 4 - 4
Private section for the list-based stack 
/* Private section */
private:
/*
 *"
stack,"This version of the stack.h interface uses a linked list to store
 * the elements of the stack.  "
stack,"* Number of elements              */
/* Private method prototypes */
   void deepCopy(const Stack<ValueType> & src);
628     Linear Structures 
list-stack-impl, p1 
 
14.2 Implementing stacks      629 
list-stack-impl, p2 
630     Linear Structures 
list-stack-impl, p3 
 
14.2 Implementing stacks      631 
"
stack,"* Number of elements              */
/* Private method prototypes */
   void deepCopy(const Stack<ValueType> & src);
628     Linear Structures 
list-stack-impl, p1 
 
14.2 Implementing stacks      629 
list-stack-impl, p2 
630     Linear Structures 
list-stack-impl, p3 
 
14.2 Implementing stacks      631 
"
stack,"* Number of elements              */
/* Private method prototypes */
   void deepCopy(const Stack<ValueType> & src);
628     Linear Structures 
list-stack-impl, p1 
 
14.2 Implementing stacks      629 
list-stack-impl, p2 
630     Linear Structures 
list-stack-impl, p3 
 
14.2 Implementing stacks      631 
"
stack,"* Number of elements              */
/* Private method prototypes */
   void deepCopy(const Stack<ValueType> & src);
628     Linear Structures 
list-stack-impl, p1 
 
14.2 Implementing stacks      629 
list-stack-impl, p2 
630     Linear Structures 
list-stack-impl, p3 
 
14.2 Implementing stacks      631 
"
stack,"* Number of elements              */
/* Private method prototypes */
   void deepCopy(const Stack<ValueType> & src);
628     Linear Structures 
list-stack-impl, p1 
 
14.2 Implementing stacks      629 
list-stack-impl, p2 
630     Linear Structures 
list-stack-impl, p3 
 
14.2 Implementing stacks      631 
"
stack,"* Number of elements              */
/* Private method prototypes */
   void deepCopy(const Stack<ValueType> & src);
628     Linear Structures 
list-stack-impl, p1 
 
14.2 Implementing stacks      629 
list-stack-impl, p2 
630     Linear Structures 
list-stack-impl, p3 
 
14.2 Implementing stacks      631 
"
stack,"The push method illustrates the standard pattern for adding a new cell to the 
beginning of a linked list: 
 
template <typename ValueType> 
void Stack<ValueType>::push(ValueType value)"
stack,"= value; 
   cp->link = list; 
   list = cp; 
   count++; 
} 
 
This pattern is sufficiently important that it is worth going through the steps using a 
heap-stack diagram.  "
stack,"Suppose that you are executing the following main program: 
 
int main() { 
   Stack<int>"
stack,"myStack; 
   myStack.push(42); 
   cout << myStack.pop() << endl; 
   return 0; 
} 
 
When execution reaches the call to push, no memory has yet been allocated on the 
heap, and the heap-stack diagram looks like this: 
 
 
 
Calling myStack.push(42) creates a new stack frame, with space for the pointer 
to the current object accessible through the keyword"
stack,"myStack; 
   myStack.push(42); 
   cout << myStack.pop() << endl; 
   return 0; 
} 
 
When execution reaches the call to push, no memory has yet been allocated on the 
heap, and the heap-stack diagram looks like this: 
 
 
 
Calling myStack.push(42) creates a new stack frame, with space for the pointer 
to the current object accessible through the keyword"
stack,"After initializing the parameters, the diagram 
looks like this: 
 
 
 
Once the new stack frame is ready to go, the push method has to allocate a new 
cell in which to store the value.  "
stack,"In this example, that chain is empty, but it 
always has the value that used to be in the list field of the Stack object to which 
push is applied.  "
stack,"The next step in the process consists of updating the list field in the Stack 
object so that the list begins with the newly allocated cell.  "
stack,"The statement 
 
list = cp; 
 
leaves memory looking like this: 
 
 
 
 
14.2 Implementing stacks      633 
From there, the push method increments the count field and then returns to the 
main program, with the memory diagram in the following state: 
 
 
 
"
stack,"Calling myStack.pop() in the 
current configuration creates a new stack frame that is essentially identical to the 
one for push, except that value is now a local variable rather than a parameter: 
 
 
 
"
stack,"After making sure the stack is not empty, the first two assignment statements in 
pop copy the pointer to the top stack cell and the value from that cell into local 
variables in the frame, as follows: 
 
 
 
The need to make a local copy of the value stems from the fact that pop has to free 
the cell so that the Stack implementation does not consume more and more 
memory as it runs.  "
stack,"After making sure the stack is not empty, the first two assignment statements in 
pop copy the pointer to the top stack cell and the value from that cell into local 
variables in the frame, as follows: 
 
 
 
The need to make a local copy of the value stems from the fact that pop has to free 
the cell so that the Stack implementation does not consume more and more 
memory as it runs.  "
stack,"After making sure the stack is not empty, the first two assignment statements in 
pop copy the pointer to the top stack cell and the value from that cell into local 
variables in the frame, as follows: 
 
 
 
The need to make a local copy of the value stems from the fact that pop has to free 
the cell so that the Stack implementation does not consume more and more 
memory as it runs.  "
stack,"The heart of the pop implementation is the line 
 
list = list->link; 
 
which replaces the linked list in the Stack object with the sublist that follows the 
current cell, which is NULL in the current example.  "
stack,"Assigning this value to the 
list component of the stack, decrementing the count, freeing the cell, and 
634     Linear Structures 
returning from the method leaves the following final state, which corresponds to an 
empty stack: 
 
 
 
 14.3 Implementing queues 
As you know from Chapter 5, stacks and queues are very similar structures.  "
stack,"Assigning this value to the 
list component of the stack, decrementing the count, freeing the cell, and 
634     Linear Structures 
returning from the method leaves the following final state, which corresponds to an 
empty stack: 
 
 
 
 14.3 Implementing queues 
As you know from Chapter 5, stacks and queues are very similar structures.  "
stack,"Assigning this value to the 
list component of the stack, decrementing the count, freeing the cell, and 
634     Linear Structures 
returning from the method leaves the following final state, which corresponds to an 
empty stack: 
 
 
 
 14.3 Implementing queues 
As you know from Chapter 5, stacks and queues are very similar structures.  "
stack,"A 
stack uses a last-in/first-out (LIFO) discipline in which the last item pushed is 
always the first item popped.  "
stack,"The interfaces for stacks and queues are also 
extremely similar.  "
stack,"The push 
method from the Stack class is now called enqueue, and the pop method is now 
dequeue.  "
stack,"Given the conceptual similarity of these structures and their interfaces, it is not 
surprising that both stacks and queues can be implemented using either array-based 
or list-based strategies.  "
stack,"With each of these models, however, the implementation of 
a queue has subtleties that don’t arise in the case of a stack.  "
stack,"These differences arise 
from the fact that all the operations on a stack occur at the same end of the internal 
data structure.  "
Algorithms,"Chapter 9 
Backtracking Algorithms 
 
 
 
 
 
 
 
 
Truth is not discovered by proofs but by exploration.  "
Algorithms,"— Simone Weil, The New York Notebook, 1942 
390     Backtracking Algorithms 
For many real-world problems, the solution process consists of working your way 
through a sequence of decision points in which each choice leads you further along 
some path.  "
Algorithms,"Instead, 
your goal is to find a recursive insight that simplifies the problem, one step at a 
392     Backtracking Algorithms 
time.  "
Algorithms,"394     Backtracking Algorithms 
Coding the maze solution algorithm 
"
Algorithms,"<< endl; 
   } 
   return 0; 
} 
 
 
9.1 Recursive backtracking in a maze      395 
 
maze.h, p1
396     Backtracking Algorithms 
maze.h, p2 
 
9.1 Recursive backtracking in a maze      397 
 
The code for the solveMaze function appears in Figure 9-3, along with the 
function adjacentPoint(start, dir), which returns the point you reach if you 
move in the specified direction from the starting point. 
 
"
Algorithms,"398     Backtracking Algorithms 
Convincing yourself that the solution works 
"
Algorithms,"The only difference along this route is that 
eventually—after descending through an additional recursive level for every step on 
the path—the program makes a recursive call in the following position: 
 
400     Backtracking Algorithms 
 
 
At this point, Theseus is outside the maze, so the simple case kicks in and returns 
true to its caller.  "
Algorithms,"402     Backtracking Algorithms 
"
Algorithms,"9.2 Backtracking and games      403 
 
Nim.cpp 
404     Backtracking Algorithms 
nim.cpp, p2 
 
9.2 Backtracking and games      405 
 
nim.cpp, p3 
406     Backtracking Algorithms 
nim.cpp, p4 
 
9.2 Backtracking and games      407 
 
A generalized program for two-player games 
The code in Figure 9-5 is highly specific to Nim.  "
Algorithms,"9.2 Backtracking and games      403 
 
Nim.cpp 
404     Backtracking Algorithms 
nim.cpp, p2 
 
9.2 Backtracking and games      405 
 
nim.cpp, p3 
406     Backtracking Algorithms 
nim.cpp, p4 
 
9.2 Backtracking and games      407 
 
A generalized program for two-player games 
The code in Figure 9-5 is highly specific to Nim.  "
Algorithms,"The extra 
408     Backtracking Algorithms 
complexity is unwarranted for a class whose only client is likely to be the class that 
implements the game.  "
Algorithms,"If there are, for 
example, three possible moves from this position, there will be three lines 
emanating downward from the current state to three new states that represent the 
results of these moves, as shown in the following diagram: 
 
410     Backtracking Algorithms 
 
 
From each of these new positions, your opponent also has options.  "
Algorithms,"The 
412     Backtracking Algorithms 
rating of the last move in the highlighted line of the game tree is +2 because it leads 
to a position with a –2 rating.  "
Algorithms,"414     Backtracking Algorithms 
minimax strategy 
 
Summary      415 
 
"
Algorithms,"416     Backtracking Algorithms 
• You can often find a winning strategy for two-player games by adopting a 
recursive-backtracking approach.  "
Algorithms,"The shortest path through the maze has a path length of 11: 
 
 
 
418     Backtracking Algorithms 
Write a function 
 
int shortestPathLength(Maze & maze, Point start); 
 
that returns the length of the shortest path in the maze from the specified 
position to any exit.  "
Algorithms,"In order to understand how this process works, it is important to understand 
that the screen of the computer is broken down into an array of tiny dots called 
420     Backtracking Algorithms 
pixels.  "
Algorithms,"an o. 
 
422     Backtracking Algorithms 
It turns out that a knight can visit all 64 squares on a chessboard without 
ever moving to the same square twice.  "
Algorithms,"For example, each of the following four rectangles represents a domino: 
 
 
 
424     Backtracking Algorithms 
Dominos can be connected end-to-end to form chains, subject to the condition 
that two dominos can be linked together only if the numbers match.  "
Algorithms,"426     Backtracking Algorithms 
14."
Algorithms,"Exercises      427 
 
tic-tac-toe sample run 
428     Backtracking Algorithms 
16."
C++,"As you know from several earlier chapters, C++ makes it possible to extend the 
standard operators so that they apply to new types.  "
C++,"In much the same way, C++ 
allows classes to redefine the selection by overriding the definition of operator[], 
which has the following prototype: 
 
ValueType & operator[](int index); 
 
As was true for the insertion operator, the selection operator must use return by 
reference so that it is possible to assign a new value to an element position. 
 
"
C++,"14.5 Integrating prototypes and code      657 
Unfortunately, C++ makes it difficult to maintain that level of separation as the 
interfaces become more sophisticated.  "
C++,"For template classes, the situation is even worse because 
C++ requires that the entire implementation be available whenever it expands a 
template.  "
C++,"Given that the implementation for a template class is going to be part of the .h 
file anyway, some professional C++ programmers give up on the notion of physical 
separation altogether and include the bodies of the methods directly within the class.  
"
C++,"Summary 
In this chapter, you have learned how to use the C++ template mechanism for 
generic container classes.  "
C++,"When designing generic containers, what advantages do C++ templates offer? 
 
"
C++,"The standard C++ header file <algorithm> (which you will learn more about 
in Chapter 20) includes a template function swap(x, y) that interchanges the 
values of x and y.  Write and test your own implementation of the swap 
function."
C++,"In exercise 9 from Chapter 12, you were asked to implement a class called 
MyString that duplicated as closely as possible the behavior of the string 
class in the C++ libraries.  "
C++,"Here, the declaration reads 
 
Cell **buckets; 
 
As in the earlier examples, buckets is a dynamic array and is represented in C++ 
as a pointer to the initial element in the array.  "
C++,"Representing family trees in C++ 
"
C++,"In order to represent a tree in C++, you need some way to model the hierarchical 
relationships among the data values.  "
C++,"If you store the 
child pointers in a vector, a node has the following form as a C++ structure: 
 
 
16.2 Binary search trees     693 
struct FamilyTreeNode { 
   string name; 
   Vector<FamilyTreeNode *> children; 
}; 
 
A family tree is simply a pointer to one of these nodes. 
 
"
C++,"The designers of C++ felt that the ability to 
process keys in order more than compensated for the modest additional cost. 
 
"
C++,"The Stanford C++ 
libraries implement this concept through the pqueue.h interface, which exports a 
class called PriorityQueue.  "
C++,"The division operator in the calculation of parentIndex is the standard integer 
division operator from C++.  "
C++,"Working from the definition of FamilyTreeNode given in the section entitled 
“Representing family trees in C++,” write a function 
 
FamilyTreeNode *readFamilyTree(string filename); 
 
that reads in a family tree from a data file whose name is supplied as the 
argument to the call.  "
C++,"and "" don’t appear on the standard 
keyboard suggests that it would be wise to use more conventional symbols for these 
operators, even if C++ allowed programmers to extend the operator set.  "
C++,"As it 
happens, C++ restricts operator overloading to the existing operators, which means 
that it is necessary to choose appropriate symbols from the operators C++ already 
defines.  "
C++,"As it 
happens, C++ restricts operator overloading to the existing operators, which means 
that it is necessary to choose appropriate symbols from the operators C++ already 
defines.  "
C++,"The good news is that both the TreeSet and HashSet models are easy to 
implement in C++, as long as you make use of the classes you already have.  "
C++,"In order to write code that works with arrays of bits stored in this tightly packed 
form, you need to learn how to use the low-level operators that C++ provides for 
manipulating the bits in a memory word.  "
C++,"760     Sets 
C++ allows you to define template classes in which you specify particular values 
for one or more of the template parameters of a more general type.  "
C++,"If you use the bitwise operators provided by 
C++, you can pack characteristic vectors into a small number of machine words 
and perform such set operations as union and intersection on many elements of 
the vector at a time. 
 
 "
C++,"Given the fact that C++ is an object-oriented language, you would expect that 
graphs, nodes, and arcs would be represented as objects, with a new class definition 
for each level of the hierarchy.  "
C++,"18.3  A low-level graph abstraction 
The goal of this section is to design the data structures for a low-level graph 
package in which the three levels of the hierarchy—the graph as a whole, the 
individual nodes, and the arcs that connect those nodes—are represented using C++ 
structure types.  "
C++,"Figure 18-3 also illustrates a new feature of C++ that deserves some explanation.  
"
C++,"This mutual recursion in the definition of the type makes it 
impossible to declare either type in terms of types that have already been defined, as 
C++ requires.  "
C++,"C++ gets around this problem by allowing you to declare that an identifier is a 
class or a structure name without specifying the actual contents.  "
C++,"The reason for this seemingly odd behavior is that most C++ runtime systems 
allocate heap memory in the order in which the requests appear.  "
C++,"In particular, the existing version of the interface uses low-level structures 
to represent a graph and consequently takes no advantage of the object-oriented 
features of C++.  "
C++,"For reasons that you will have a chance to explore more fully in the 
extended discussion of inheritance in Chapter 19, this approach is not ideal for C++.  
"
C++,"The fundamental problem is that dynamic memory allocation and inheritance don’t 
always work together in C++ as seamlessly as they do in other languages, to the 
point that it is worth adopting a different approach. 
 
"
C++,"Implementing Graph as a parameterized class 
Fortunately, C++ templates make it possible to design a Graph class that takes 
advantage of the power of object-oriented design while retaining the simplicity of 
the low-level, structure-based approach.  "
C++,"The Stanford C++ libraries export a PriorityQueue class through the 
pqueue.h interface. 
"
C++,"Create one by writing a C++ 
program that performs the following operations: 
 
"
C++,"— Henry Cabot Lodge, “League of Nations,” 1919 
824     Inheritance 
 
As you know from the discussion of the stream hierarchy in Chapter 4, one of the 
defining properties of object-oriented languages like C++ and Java is that they 
allow you to define hierarchical relationships among classes.  "
C++,"At the same time, it is important to recognize that using inheritance is more 
problematic in C++ than it is in many other programming languages.  "
C++,"In particular, 
if you have already had experience with Java, you will almost certainly have 
preconceptions about inheritance that don’t apply in the C++ world.  "
C++,"It is therefore 
equally important to learn the limitations of inheritance in C++ along with its 
strengths. 
 
 "
C++,"In its most basic form, the 
definition of a subclass in C++ looks like this: 
 
class subclass : public superclass { 
   new entries for the subclass 
}; 
 
In this pattern, subclass inherits all the public entries in superclass.  "
C++,"Specifying types in a template class 
In C++, it is possible to create useful subclasses that contain no code other than the 
class header, particularly if the superclass is a template class.  "
C++,"As with the C++ interfaces you have seen in 
this text, the implementation of the Employee class and its subclasses appear in a 
separate .cpp file.  "
C++,"The goal of the figure, however, is to illustrate the use of 
subclasses in C++, and the example is certainly sufficient for that purpose. 
 
"
C++,"The declaration of the abstract getPay 
method, however, looks a bit different: 
 
virtual double getPay() = 0; 
 
This declaration introduces two new features of C++.  "
C++,"C++ 
uses this syntax to mark the definition of a pure virtual method, which is one that 
 
19.1  Simple inheritance      827 
has no definition in the base class and can therefore come only from a subclass.  "
C++,"In most languages that support 
inheritance, all methods are virtual in the way that C++ uses that term.  "
C++,"This rule, however, is not applied automatically in C++.  
"
C++,"hourlyRate; 
} 
 
The limitations of subclassing in C++ 
One of the basic principles that underlies object-oriented design is that subclasses 
are instance of their superclass.  "
C++,"That fact, however, may lead you to make incorrect assumptions 
about the operations you can perform on instances of hierarchical data structures, 
particularly if you have had previous exposure to languages like Java that behave 
very differently in C++. 
 
"
C++,"Although the code is perfectly legal 
C++, the skull-and-crossbones icon is there to warn you that the code is unlikely to 
do what you expect or want. 
 
"
C++,"In C++, local variables are always allocated on the stack, even if they are 
instances of a class type.  "
C++,"Thus, the picture of the stack frame 
containing these two variables will look something like this: 
 
 
 
830     Inheritance 
In C++, assigning one object to another—in the absence of a new definition of 
assignment—is implemented by copying all the fields.  "
C++,"What C++ does in this situation is to copy only those parts of the object that fit 
into the smaller space, which are simply those fields that HourlyEmployee inherits 
from Employee.  "
C++,"The traditional way to get around these problems in C++ is to use pointers to 
objects rather than the objects themselves.  "
C++,"What’s more, if you dereference one of the elements of payroll and then 
call a virtual method in the Employee class, C++ invokes the version of the method 
appropriate to that object subtype.  "
C++,"Unfortunately, using pointers complicates the process of memory management, 
which is already a difficult challenge in C++.  "
C++,"When you design an abstraction in C++, it is important to keep this tradeoff in 
mind.  "
C++,"The designers of the C++ libraries made different choices in different situations.  
"
C++,"A hierarchy of graphical shapes      835 
shape.h, p3 
836     Inheritance 
The shape.h interface in Figure 19-4 introduces only one new feature of C++.  
"
C++,"As noted in the section entitled 
“The limitations of subclassing in C++” earlier in this chapter, any clients who try 
to use the Shape class in these ways can only get themselves into trouble.  "
C++,"C++ allows you to do so by 
including an additional specification in the code for the subclass constructor called 
an initializer list.  "
C++,"Both styles are used in professional C++ programming, but the examples in this 
book use only the first style. 
 
"
C++,"As it reads your programs, the 
C++ compiler must analyze expressions to figure out which operators apply to 
which operands and to determine the order in which those operators are evaluated.  
"
C++,"A class hierarchy for expressions      843 
As the sample run makes clear, the interpreter allows assignment to variables and 
adheres to C++’s precedence conventions by evaluating multiplication before 
addition. 
 
"
C++,"The interpreter program in Figure 19-9 does precisely that by relying on a new 
feature of C++ called exception handling, which allows programmers to respond to 
unusual conditions even when they occur in a function deeply nested within the one 
that has to respond.  "
C++,"The feature of C++ that allows this style of exception handling is the try 
statement, which looks like this in its most basic form: 
 
try { 
   code under the control of the try statement 
} catch (type var) { 
   code to respond to an exception with the specified value type 
} 
 
"
C++,"As is 
often the case when you are thinking about a programming abstraction, it helps to 
begin with the insights you have acquired about expressions from your experience 
as a C++ programmer.  "
C++,"x = x + 1 
 
 
19.3  A class hierarchy for expressions      845 
represent legal expressions in C++.  "
C++,"The 
parser therefore exits from the while loop, leading to the following configuration: 
 
 
 
When control returns to the first readE call, all the necessary information is now 
in place, as follows: 
 
 
 
All readE has to do is create the new compound and—after reading the empty 
token one more time—return the final version of the expression tree to parseExp: 
 
 
 
870     Inheritance 
 19.5 Multiple inheritance 
One of the features that sets C++ apart from most other object-oriented languages is 
that classes can inherit behavior from more than one superclass.  "
C++,"Although multiple inheritance can make hierarchies 
more difficult to understand, it appears in several classes in the C++ library and is 
therefore worth including in this book. 
 
"
C++,"Given that single inheritance is already hard to use effectively in C++, adding 
the complexity of multiple inheritance makes this feature even more problematic as 
a programming strategy.  "
C++,"Summary 
In this chapter, you have learned how to use inheritance in C++ and have seen 
several practical applications of the concept.  "
C++,C++ allows subclasses to inherit the public behavior of the superclasses.  
C++,"In its 
simplest form, the C++ syntax for defining a subclass looks like this: 
 
class subclass : public superclass { 
   new entries for the subclass 
}; 
 
•"
C++,"In contrast to most object-oriented languages, subclass objects in C++ cannot be 
freely assigned to variables of their superclass type.  "
C++,"In 
C++, only methods marked with the keyword virtual can be overridden in this 
way. 
"
C++,"
874     Inheritance 
• C++ classes include a protected section along with the public and private 
sections you have used all along.  "
C++,"In the absence of any other specification, C++ calls the default 
constructor although clients can supply an initializer list to call a different one. 
"
C++,"• C++ includes a try statement that lets programmers respond to exceptional 
conditions that occur during the execution of a program.  "
C++,"• C++ allows classes to inherit behavior from more than one superclass, which is 
called multiple inheritance.  "
C++,"Although multiple inheritance can be useful in 
certain contexts, it adds considerable complexity, both to the C++ language and 
to applications that use this feature. 
 
 
"
C++,"In C++, what header line would you use to define a class named Sub that 
inherited the public behavior from a class named Super? 
 
2. 
True or false: The superclass specification in a new class definition may not be 
a template class with specific instantiation of the template types. 
 
"
C++,"3. 
True or false: As in most object-oriented languages, a new definition of a 
method in a C++ subclass automatically overrides the definition of that 
method in its superclass. 
 
"
C++,"What syntactic marker does C++ use to indicate that a method is pure virtual? 
  
"
C++,"Where do initializer lists appear in a C++ program? 
 
"
C++,"In its simplest form that catches only one exception type, what is the syntax of 
the try statement in C++? 
 
"
C++,"True or false: Multiple inheritance proved so useful in C++ that the designers 
of Java incorporated it into their language design. 
 
 "
C++,"That feature, however, is new to 
C++ as of the 2011 standard.  "
C++,"Prior to the introduction of the extended version of 
for, looping though the elements of a C++ collection typically involved using an 
iterator, which is an object that refers to a particular element in a collection but can 
also step through additional elements one at a time. 
 
"
C++,"Given that the range-based for loop was unavailable for most of C++’s history, 
iterators are extremely common in existing code.  "
C++,"For these reasons, it is 
necessary to understand the use of iterators in order to program effectively in C++.  
"
C++,"Syntactically, iterators 
in C++ resemble pointers.  "
C++,"In C++, the operators used for iterators are the same as those for pointers.  "
C++,"Iterators support the various shorthand forms that C++ implements for pointers.  
"
C++,"The iterator hierarchy 
At a minimum, every iterator in C++ supports the * and ++ operators outlined in the 
preceding section, along with the relational operators == and !"
C++,"Iterators, however, are important in C++ for other reasons.  "
C++,"In contrast to those languages, 
C++ makes it possible for programmers to declare pointers to functions and then use 
those functions as data values in an application. 
 
"
C++,"A simple plotting application 
Before looking at the details of how C++ incorporates pointers to functions into its 
syntax, it helps to consider an example that shows how this technique is used in 
practice.  "
C++,"Thus, you 
can say that the second argument to plot must be chosen from the general class of 
functions that map one double into another double. 
 
 
20.2  Using functions as data values      893 
That argument, moreover, must be a data value that is part of the C++ type 
system.  "
C++,"When you first encounter it, the syntax for 
declaring a function pointer seems confusing, even though it is consistent with the 
declaration model used elsewhere in C++.  "
C++,"Thus, if you want to increase the efficiency of the 
code by eliminating the need to make copies of the key values, you can use the 
following prototype for listMapEntry: 
 
void listMapEntry(const string & key, const int & value); 
 
These two function types have different signatures in C++, and the mapAll function 
is designed to work with either type. 
 
"
C++,"Fortunately, C++ offers an elegant solution to 
this problem, as described in the following section. 
 
 "
C++,"C++ does not support 
that model.  "
C++,"To use closures in C++, you need to create the necessary data structures 
yourself.  "
C++,"Simulating closures using objects 
Before revealing the strategy that C++ programmers use to create the effect of 
closures, it’s worth noting that C++ already offers a mechanism for encapsulating 
data and code in a single entity.  "
C++,"Simulating closures using objects 
Before revealing the strategy that C++ programmers use to create the effect of 
closures, it’s worth noting that C++ already offers a mechanism for encapsulating 
data and code in a single entity.  "
C++,"In C++, classes that overload this operator are called function classes.  
"
C++,"Given any constant increment, that function is easy to write in 
C++.  "
C++,"endl; 
   return 0; 
} 
 
902     Strategies for Iteration 
Running this program with the definition of AddKFunction from Figure 20-6 
produces the following output on the console: 
 
 
 
Function objects are useful in C++ because clients can invoke them using the 
conventional syntax for function calls.  "
C++,"C++ offers a 
concise—if sometimes confusing—syntax for declaring the type of a function 
pointer.  "
C++,"C++ circumvents this problem by using template functions to implement any 
functions that take function objects as parameters.  "
C++,"Although iterators are certainly useful for their original purpose of stepping through 
the elements of a collection, they have even greater importance in C++ because so 
many of the functions in the Standard Template Library take iterators as parameters.  
"
C++,"Suppose, for example, that you need to sort the elements of a vector and want to 
take advantage of the extensive engineering work that the designers of the C++ 
library have invested in creating an efficient library implementation of a general 
sorting algorithm.  "
C++,"As an example, the code in Figure 20-8 implements 
the selection sort algorithm from Chapter 10 using several high-level functions from 
the <algorithm> library as tools. 
 
906     Strategies for Iteration 
<algorithm> table 
 
 
20.5  Functional programming in C++      907 
 20.5 Functional programming in C++ 
"
C++,"As an example, the code in Figure 20-8 implements 
the selection sort algorithm from Chapter 10 using several high-level functions from 
the <algorithm> library as tools. 
 
906     Strategies for Iteration 
<algorithm> table 
 
 
20.5  Functional programming in C++      907 
 20.5 Functional programming in C++ 
"
C++,"As you learned in Chapter 1, the developers of C++ added object-oriented features 
on top of the imperative programming language C.  Given that history, one expects 
C++ to include both object-oriented and imperative features.  "
C++,"As you learned in Chapter 1, the developers of C++ added object-oriented features 
on top of the imperative programming language C.  Given that history, one expects 
C++ to include both object-oriented and imperative features.  "
C++,"By contrast, C++ was 
not designed to support another popular paradigm called functional programming, 
which is characterized by the following properties: 
 
• Programs are expressed in the form of nested function calls that perform the 
necessary computation without performing any operations (such as assignment) 
that change the program state. 
"
C++,"Even though functional programming was not a goal of the language design, the fact 
that C++ includes both templates and function objects make it possible to adopt a 
programming style that is remarkably close to the functional programming model. 
 
"
C++,"The classes in the next three sections act as an object-oriented counterparts of the 
standard arithmetic, relational, and logical operators provided by C++.  "
C++,"For example, the expression 
 
bind2nd(plus<int>(), 1) 
 
908     Strategies for Iteration 
<functional> interface 
 
20.5  Functional programming in C++      909 
returns a unary function object that adds the constant 1 to its argument.  "
C++,"Understanding how to do so requires looking at the requirements for C++ iterators 
in a different way, as discussed in the following section. 
 
"
C++,"In C++, pointer types implement every one of those operators in just the 
right way, which means that you can use pointer values as iterators. 
 
"
C++,"One of the implications of this reinterpretation of iterators is that you can use 
traditional C++ arrays with the functions exported by the <algorithm> interface.  
"
C++,"The C++ compiler translates the range-based for loop 
 
for (type var : collection) { 
   body of the loop 
} 
 
into the following traditional for loop, where ctype represents the type of the 
collection and it is a private iteration variable not used elsewhere: 
 
 
20.6  "
C++,"Fortunately, C++ makes it possible to do just that, as described in the 
following section. 
 
"
C++,"The typedef keyword 
C++ includes a mechanism—inherited from its predecessor language C—that 
allows programmers to assign new names to existing types.  "
C++,"Summary 
This chapter uses the problem of iterating over the elements of a collection class as 
a framework for introducing a variety of interesting topics including iterators, 
function pointers, function objects, the STL <algorithm> library, and techniques 
for using the functional programming paradigm in C++.  "
C++,"In C++, the syntax for iterators is based on pointer arithmetic and uses the same 
set of operators.  "
C++,"The C++ compiler translates the range-based for loop 
 
for (type var : collection) { 
   body of the loop 
} 
 
into the following for loop, where ctype represents the type of the collection 
and it is a private iteration variable not used elsewhere: 
 
for (ctype::iterator it = collection.begin(); 
     ctype           it !"
C++,"In C++, pointers to functions 
are legitimate data values. 
"
C++,"To get around this problem, C++ supports function objects, 
which encapsulate the necessary data and operations in a class instance that 
implements the function-call operator. 
"
C++,"• Even though C++ was designed to use both the imperative and object-oriented 
paradigms, it can also be used—particularly with the help of the <functional> 
library—to support certain aspects of the functional programming model. 
"
C++,"• C++ includes the typedef keyword, which makes it possible to define new 
names for existing types.  "
C++,"True or false: Pointers in C++ act as iterators at the RandomAccessIterator 
level of service. 
 
 "
C++,"Your implementation should allow functions to be combined and nested just as 
in C++.  "
C++,"Given the 
arcane rules for declarations involving template classes in C++, the 
declarations of Map iterators inside the Set class need to be marked with the 
typename keyword, leading to declarations like this: 
 
typename Map<ValueType,bool>"
syntax,"678     Maps 
If you look at the declaration of the instance variable buckets in Figure 15-7, 
the syntax may initially seem confusing.  "
syntax,"The same syntax 
applies to the implementations of the methods for the specialized class.  "
syntax,"C++ 
uses this syntax to mark the definition of a pure virtual method, which is one that 
 
19.1  Simple inheritance      827 
has no definition in the base class and can therefore come only from a subclass.  "
syntax,"Like human languages, programming languages have 
rules of syntax that define the grammatical structure of the language.  "
syntax,"In its 
simplest form, the C++ syntax for defining a subclass looks like this: 
 
class subclass : public superclass { 
   new entries for the subclass 
}; 
 
•"
syntax,"In its simplest form that catches only one exception type, what is the syntax of 
the try statement in C++? 
 
"
syntax,"Once again, the syntax mirrors the 
programming model used for pointers, where the ++ operator increments the pointer 
value so that it refers to the next element in an array. 
 
"
syntax,"A simple plotting application 
Before looking at the details of how C++ incorporates pointers to functions into its 
syntax, it helps to consider an example that shows how this technique is used in 
practice.  "
syntax,"Declaring pointers to functions 
The only new language feature you need to learn before coding the plot function is 
the declaration syntax for the second argument, which you know is a pointer to a 
function taking and returning a double.  "
syntax,"When you first encounter it, the syntax for 
declaring a function pointer seems confusing, even though it is consistent with the 
declaration model used elsewhere in C++.  "
syntax,"endl; 
   return 0; 
} 
 
902     Strategies for Iteration 
Running this program with the definition of AddKFunction from Figure 20-6 
produces the following output on the console: 
 
 
 
Function objects are useful in C++ because clients can invoke them using the 
conventional syntax for function calls.  "
syntax,"C++ offers a 
concise—if sometimes confusing—syntax for declaring the type of a function 
pointer.  "
syntax,"In C++, the syntax for iterators is based on pointer arithmetic and uses the same 
set of operators.  "
recursion,"• Using recursion makes it easy to step through the nodes in a binary search tree, 
which is called traversing or walking the tree.  "
recursion,"This mutual recursion in the definition of the type makes it 
impossible to declare either type in terms of types that have already been defined, as 
C++ requires.  "
recursion,"3. 
Eliminate the recursion from the implementation of depthFirstSearch by 
using a stack to store the unexplored nodes.  "
recursion,"For the 
arithmetic operators (+, –, *, and /), eval uses recursion to evaluate the left and 
right subexpressions and then applies the appropriate operation.  "
recursion,"As the mutual recursion proceeds, the readE and readT functions build up the 
expression tree by calling the constructors for the appropriate expression class.  "
recursion,"When you implement this behavior using an iterator, 
however, you can no longer rely on the magic of recursion because the iterator 
needs to operate sequentially, one step at a time.  "
inheritance,"For reasons that you will have a chance to explore more fully in the 
extended discussion of inheritance in Chapter 19, this approach is not ideal for C++.  
"
inheritance,"The fundamental problem is that dynamic memory allocation and inheritance don’t 
always work together in C++ as seamlessly as they do in other languages, to the 
point that it is worth adopting a different approach. 
 
"
inheritance,"Chapter 19 
Inheritance 
 
 
 
 
 
 
 
 
Beware how you trifle with your marvelous inheritance. 
"
inheritance,"Chapter 19 
Inheritance 
 
 
 
 
 
 
 
 
Beware how you trifle with your marvelous inheritance. 
"
inheritance,"— Henry Cabot Lodge, “League of Nations,” 1919 
824     Inheritance 
 
As you know from the discussion of the stream hierarchy in Chapter 4, one of the 
defining properties of object-oriented languages like C++ and Java is that they 
allow you to define hierarchical relationships among classes.  "
inheritance,"Although you have seen inheritance used in the stream libraries, 
you have not yet had occasion to use inheritance in your own classes.  "
inheritance,"Although you have seen inheritance used in the stream libraries, 
you have not yet had occasion to use inheritance in your own classes.  "
inheritance,"This chapter 
gives you that opportunity by defining several class hierarchies in which inheritance 
plays a central role. 
 
"
inheritance,"At the same time, it is important to recognize that using inheritance is more 
problematic in C++ than it is in many other programming languages.  "
inheritance,"In particular, 
if you have already had experience with Java, you will almost certainly have 
preconceptions about inheritance that don’t apply in the C++ world.  "
inheritance,"It is therefore 
equally important to learn the limitations of inheritance in C++ along with its 
strengths. 
 
 "
inheritance,"19.1 Simple inheritance 
Before moving on to consider more sophisticated applications of inheritance, it 
makes sense to begin with a few simple examples.  "
inheritance,"19.1 Simple inheritance 
Before moving on to consider more sophisticated applications of inheritance, it 
makes sense to begin with a few simple examples.  "
inheritance,"19.1  Simple inheritance      825 
"
inheritance,"On the other 
826     Inheritance 
hand, it is almost certainly necessary to write separate getPay methods for each of 
the subclasses, because the computation is different in each case.  "
inheritance,"C++ 
uses this syntax to mark the definition of a pure virtual method, which is one that 
 
19.1  Simple inheritance      827 
has no definition in the base class and can therefore come only from a subclass.  "
inheritance,"828     Inheritance 
If you are used to inheritance in other languages, the idea of marking a method 
with the virtual keyword seems unnecessary.  "
inheritance,"828     Inheritance 
If you are used to inheritance in other languages, the idea of marking a method 
with the virtual keyword seems unnecessary.  "
inheritance,"In most languages that support 
inheritance, all methods are virtual in the way that C++ uses that term.  "
inheritance,"If a subclass 
overrides a method in its superclass, programmers used to the usual model of 
inheritance expect the new definition supplied by the subclass to be used on any 
object that has that type.  "
inheritance,"The class header indicates the inheritance relationship by adding a colon, the 
keyword public, and the superclass name after the name of the subclass.  "
inheritance,"Thus, in the Employee hierarchy introduced in the 
 
19.1  Simple inheritance      829 
preceding section, an HourlyEmployee is also an instance of the more general 
Employee class.  "
inheritance,"Thus, the picture of the stack frame 
containing these two variables will look something like this: 
 
 
 
830     Inheritance 
In C++, assigning one object to another—in the absence of a new definition of 
assignment—is implemented by copying all the fields.  "
inheritance,"19.1  Simple inheritance      831 
"
inheritance,"In most cases, the best approach is to avoid the use of inheritance and create 
independent classes that manage their own heap memory.  "
inheritance,"If you decide that you 
need inheritance, however, you face a difficult choice.  "
inheritance,"One approach is to define 
private versions of the copy constructor and assignment operator so that copying 
objects in that inheritance hierarchy is prohibited.  "
inheritance,"The collection classes are implemented as independent classes that do not form an 
inheritance hierarchy.  "
inheritance,"832     Inheritance 
 19.2"
inheritance,"A hierarchy of graphical shapes 
One of the contexts in which inheritance hierarchies are worth the added complexity 
is in the design of graphical interfaces.  "
inheritance,"Graphical user interfaces are ubiquitous in 
systems today and typically rely on inheritance hierarchies to define the associated 
application programming interface (or API for short) that implementers use to 
write the necessary code.  "
inheritance,"Within the context of a particular API, inheritance 
hierarchies come up at a variety of levels.  "
inheritance,"A hierarchy of graphical shapes      833 
shape.h, p1 
834     Inheritance 
shape.h-p2 
 
19.2  "
inheritance,"A hierarchy of graphical shapes      835 
shape.h, p3 
836     Inheritance 
The shape.h interface in Figure 19-4 introduces only one new feature of C++.  
"
inheritance,"A hierarchy of graphical shapes      837 
shape.cpp, p2 
838     Inheritance 
Calling superclass constructors 
Constructors are responsible for initializing the fields of an object to ensure that it is 
created in a consistent state.  "
inheritance,"To maintain this consistency through the entire 
inheritance hierarchy, each subclass constructor must invoke some constructor its 
superclass.  "
inheritance,Everything else comes for free given the structure of inheritance.
inheritance,"
 
840     Inheritance 
Storing shape pointers in a vector 
One of the advantages of defining a Shape class hierarchy is that doing so makes it 
possible to store shapes in collection classes, as long as you remember to use 
pointers to the Shape objects rather than the objects themselves.  "
inheritance,"The main program for a simple interpreter that incorporates these phases appears in 
Figure 19-9. 
 
842     Inheritance 
A sample run of this program might look like this: 
 
 
 
 
19.3  "
inheritance,"As it is implemented in the Stanford libraries, the error 
844     Inheritance 
function generates a signal that something is amiss, making it possible for other 
functions within the program—as long as they appear somewhere in the chain of 
function calls that preceded the error condition and therefore still have a frame on 
the control stack—to respond to that condition.  "
inheritance,"You can record this observation in the diagram by adding a new expression marker 
tied to the parts of the expression that match the rule, as shown: 
846     Inheritance 
 
 
 
The parenthesized quantity can now be identified as an expression according to rule 
#3, which results in the following diagram: 
 
 
 
"
inheritance,"Parentheses are useful in determining how to generate the parse tree but play no role 
848     Inheritance 
in the evaluation of an expression once its structure is known.  "
inheritance,"An inheritance hierarchy is an appropriate way to represent the different types of 
expression trees.  "
inheritance,"The superclass specifies the 
prototype, but each subclass is free to implement those methods in its own way. 
850     Inheritance 
exp.h, p1 
 
19.3  "
inheritance,"A class hierarchy for expressions      851 
exp.h, p2 
852     Inheritance 
exp.h, p3 
 
19.3  "
inheritance,"A class hierarchy for expressions      853 
exp.h, p4 
854     Inheritance 
exp.h, p5 
 
19.3  "
inheritance,"An IdentifierExp object stores a string representing a variable name, illustrated 
here for the variable x: 
 
 
 
A CompoundExp object stores the binary operator along with two pointers which 
indicate the left and right subexpressions: 
 
856     Inheritance 
 
 
Because compound nodes contain subexpressions that can themselves be 
compound nodes, expression trees can grow to an arbitrary level of complexity.  
"
inheritance,"A class hierarchy for expressions      857 
exp.cpp, p1 
858     Inheritance 
exp.cpp, p2 
 
19.3  "
inheritance,"A class hierarchy for expressions      859 
exp.cpp, p3 
860     Inheritance 
"
inheritance,"In the 
exp.h interface, the destructor is marked using the virtual keyword, as it should 
be in any inheritance hierarchy that involves dynamic memory allocation.  "
inheritance,"An expression in parentheses 
 
862     Inheritance 
"
inheritance,"864     Inheritance 
parser.cpp, p1 
 
19.4  Parsing an expression      865 
In my experience, it is nearly impossible to understand the code for readE 
without walking through at least one example.  "
inheritance,"866     Inheritance 
"
inheritance,"On this cycle, however, the 
868     Inheritance 
precedence of + is greater than the precedence in effect at this level set by the 
assignment operator.  "
inheritance,"The 
parser therefore exits from the while loop, leading to the following configuration: 
 
 
 
When control returns to the first readE call, all the necessary information is now 
in place, as follows: 
 
 
 
All readE has to do is create the new compound and—after reading the empty 
token one more time—return the final version of the expression tree to parseExp: 
 
 
 
870     Inheritance 
 19.5 Multiple inheritance 
One of the features that sets C++ apart from most other object-oriented languages is 
that classes can inherit behavior from more than one superclass.  "
inheritance,"The 
parser therefore exits from the while loop, leading to the following configuration: 
 
 
 
When control returns to the first readE call, all the necessary information is now 
in place, as follows: 
 
 
 
All readE has to do is create the new compound and—after reading the empty 
token one more time—return the final version of the expression tree to parseExp: 
 
 
 
870     Inheritance 
 19.5 Multiple inheritance 
One of the features that sets C++ apart from most other object-oriented languages is 
that classes can inherit behavior from more than one superclass.  "
inheritance,"This property is 
called multiple inheritance.  "
inheritance,"Although multiple inheritance can make hierarchies 
more difficult to understand, it appears in several classes in the C++ library and is 
therefore worth including in this book. 
 
"
inheritance,"Multiple inheritance in the stream libraries 
Chapter 4 introduces the stream class hierarchy, but stops short of describing those 
features that use multiple inheritance.  "
inheritance,"Multiple inheritance in the stream libraries 
Chapter 4 introduces the stream class hierarchy, but stops short of describing those 
features that use multiple inheritance.  "
inheritance,"The fstream class 
 
19.5  Multiple inheritance      871 
therefore inherits all the methods that pertain to istreams.  "
inheritance,"x; 
   return x; 
} 
 
Adding a FillableShape class to the Shape hierarchy 
As an example of how multiple inheritance might prove useful in your own code, it 
is worth returning to the Shape class hierarchy introduced in section 19.2.  "
inheritance,"Multiple inheritance offers a way out of this 
dilemma.  "
inheritance,"The UML diagram for the revised Shape 
hierarchy appears in Figure 19-16, and the code for FillableShape appears in 
Figure 19-17. 
872     Inheritance 
 
 
Summary      873 
"
inheritance,"The dangers of multiple inheritance 
Even though the concept of multiple inheritance is not difficult to understand in the 
abstract, making it part of a programming language introduces a variety of issues 
that can get extremely tricky.  "
inheritance,"The dangers of multiple inheritance 
Even though the concept of multiple inheritance is not difficult to understand in the 
abstract, making it part of a programming language introduces a variety of issues 
that can get extremely tricky.  "
inheritance,"These problems are sufficiently serious that the 
creators of Java made an explicit decision not to include multiple inheritance in the 
language design. 
 
"
inheritance,"Given that single inheritance is already hard to use effectively in C++, adding 
the complexity of multiple inheritance makes this feature even more problematic as 
a programming strategy.  "
inheritance,"Given that single inheritance is already hard to use effectively in C++, adding 
the complexity of multiple inheritance makes this feature even more problematic as 
a programming strategy.  "
inheritance,"Although it has some appealing applications, it is probably 
best to avoid multiple inheritance in your own programming but to understand 
what’s going on when you see it in existing code. 
 
 "
inheritance,"Summary 
In this chapter, you have learned how to use inheritance in C++ and have seen 
several practical applications of the concept.  "
inheritance,"In particular, sections 19.3 and 19.4 
offer a brief glimpse at how compiler writers can use inheritance hierarchies to 
represent arithmetic expressions. 
 
"
inheritance,"In practice, inheritance is 
most useful if you work with pointers to objects instead of with the objects 
themselves.  "
inheritance,"Unfortunately, exposing pointers forces clients to assume more 
responsibility for memory management, which often makes using inheritance 
more trouble than it is worth. 
"
inheritance,"
874     Inheritance 
• C++ classes include a protected section along with the public and private 
sections you have used all along.  "
inheritance,"Inheritance makes it easy to define a class hierarchy to represent the nodes of an 
expression tree. 
"
inheritance,"• C++ allows classes to inherit behavior from more than one superclass, which is 
called multiple inheritance.  "
inheritance,"Although multiple inheritance can be useful in 
certain contexts, it adds considerable complexity, both to the C++ language and 
to applications that use this feature. 
 
 
"
inheritance,"When you store values from an inheritance hierarchy in a collection, does it 
make more sense to store the values themselves or pointers to those values 
allocated elsewhere? 
 
"
inheritance,"876     Inheritance 
18."
inheritance,"What is multiple inheritance? 
 
35."
inheritance,"True or false: Multiple inheritance proved so useful in C++ that the designers 
of Java incorporated it into their language design. 
 
 "
inheritance,"You should use the version of the shape.h 
interface from exercise 3 so that you have access to the contains method. 
 
878     Inheritance 
shapelist.h 
 
Exercises      879 
6. 
"
inheritance,"The 
combination of templates and inheritance make it much easier to define a base 
class for two-player games that is easy to extend for particular games. 
 
"
inheritance,"+ y 
 
calling listVariables on the resulting expression should produce the 
following output: 
 
880     Inheritance 
 
 
10."
inheritance,"882     Inheritance 
14."
inheritance,"The most common rules for differentiating an expression involving 
the standard arithmetic operators are shown in Figure 19-20. 
 
884     Inheritance 
Write a recursive function differentiate(exp, var) that uses the rules 
from Figure 19-20 to find the derivative of exp with respect to the variable 
var.  "
inheritance,"The varying levels at which iterators support extended operations follows the 
inheritance hierarchy shown in Figure 20-1.  "
polymorphism,"At the 
same time, Vector resembles the Stack and Queue classes by implementing deep 
copying and by using templates to support polymorphism. 
 
"
templates,"Important points in this chapter include: 
 
• Templates are used to define generic container classes. 
"
iterators,"Iterators for tree-structured classes like 
Map, however, turn out to be enormously tricky, mostly because the implementation 
has to translate the recursive structure of the data into an iterative form.  "
algorithms,"Algorithms for maintaining balance in a binary tree have been studied 
extensively in computer science.  "
algorithms,"18.7 Algorithms for searching the web 
As noted in the introduction to this chapter, the web is a graph in which the nodes 
are the individual pages and the arcs are the hyperlinks that take you from one page 
to another.  "
algorithms,"18.7 Algorithms for searching the web      809 
"
algorithms,"The probability of reaching node A after following one 
random link is therefore one-half times the chance of being at C plus one-third times 
the chance of being at D.  If you express this calculation as a formula using primed 
letters to indicating probabilities on the next cycle, the result looks like this: 
 
 
 
 
18.7 Algorithms for searching the web      811 
A similar analysis yields the following formulas for the other pages in the graph: 
 
 
 
Each iteration of the PageRank algorithm replaces the probabilities for the pages 
A, B, C, D, and E with the values A!, B!, C!, D!, and E! computed by these formulae.  
"
debugging,"Although the toString method is not used 
in the interpreter, it is a useful method to have around, particularly during 
debugging.  "
debugging,"Using an implementation that performs little or no error checking makes the 
debugging process much more difficult. 
 
"
encapsulation,"An alternative strategy that supports better encapsulation is to 
declare these fields in the private section of a class, but to give the Graph class 
access to these fields using a friend declaration. 
 
"
encapsulation,"For the most 
part, providing that encapsulation is precisely what objects are for.  "
vector,"Thus, if you were to enqueue 
the customer A into an empty queue, the internal structure of the pointers at the end 
of the enqueue operation would look like this: 
 
 
14.4 Implementing vectors      649 
 
 
If you make another call to enqueue, the head pointer is no longer NULL, which 
means that the implementation no longer has to perform the special-case action for 
the empty queue.  "
vector,"For 
example, if you enqueue the customer B after customer A, the resulting structure 
looks like this: 
 
 
 
 14.4 Implementing vectors 
The Vector class introduced in Chapter 5 is another example of a linear structure.  
"
vector,"For 
example, if you enqueue the customer B after customer A, the resulting structure 
looks like this: 
 
 
 
 14.4 Implementing vectors 
The Vector class introduced in Chapter 5 is another example of a linear structure.  
"
vector,"In many respects, the implementation of the Vector class is a combination of the 
editor buffer from Chapter 13 and the stack and queue abstractions you have seen in 
this chapter.  "
vector,"The Vector class resembles the EditorBuffer class in that it allows 
clients to insert and remove elements at any point in the sequence of values.  "
vector,"At the 
same time, Vector resembles the Stack and Queue classes by implementing deep 
copying and by using templates to support polymorphism. 
 
"
vector,"The fact that Vector resembles classes you have already seen means that the 
code requires less in the way of explanation.  "
vector,"The only method in the Vector class 
that doesn’t appear in the earlier models is the use of square brackets for selection.  
"
vector,"The complete text of the polymorphic vector.h interface, including the private 
section and the implementation section, appears in Figure 14-11. 
650     Linear Structures 
vector.h, p1 
 
14.4 Implementing vectors      651 
vector.h, p2 
652     Linear Structures 
vector.h, p3 
 
14.4 Implementing vectors      653 
vector.h, p4 
654     Linear Structures 
vector.h, p5 
 
14.4 Implementing vectors      655 
vector.h, p6 
656     Linear Structures 
 
 14.5 Integrating prototypes and code 
One of the primary reasons for using interfaces is to hide the complexity of the 
implementation from the eyes of the client.  "
vector,"The complete text of the polymorphic vector.h interface, including the private 
section and the implementation section, appears in Figure 14-11. 
650     Linear Structures 
vector.h, p1 
 
14.4 Implementing vectors      651 
vector.h, p2 
652     Linear Structures 
vector.h, p3 
 
14.4 Implementing vectors      653 
vector.h, p4 
654     Linear Structures 
vector.h, p5 
 
14.4 Implementing vectors      655 
vector.h, p6 
656     Linear Structures 
 
 14.5 Integrating prototypes and code 
One of the primary reasons for using interfaces is to hide the complexity of the 
implementation from the eyes of the client.  "
vector,"The complete text of the polymorphic vector.h interface, including the private 
section and the implementation section, appears in Figure 14-11. 
650     Linear Structures 
vector.h, p1 
 
14.4 Implementing vectors      651 
vector.h, p2 
652     Linear Structures 
vector.h, p3 
 
14.4 Implementing vectors      653 
vector.h, p4 
654     Linear Structures 
vector.h, p5 
 
14.4 Implementing vectors      655 
vector.h, p6 
656     Linear Structures 
 
 14.5 Integrating prototypes and code 
One of the primary reasons for using interfaces is to hide the complexity of the 
implementation from the eyes of the client.  "
vector,"You have 
also had the chance to see array- and list-based implementations of the Stack and 
Queue classes, along with the public interface for a polymorphic Vector class. 
 
"
vector,• Vectors can easily be represented using dynamic arrays.  
vector,"9. 
Design a unit test for the Vector class that tests it with several different value 
types. 
 
"
vector,"11. Use the techniques from the Vector implementation in section 12.4 to 
implement the Grid class, with the exception of bracket selection, which is 
much trickier to code for a two-dimensional structure. 
 
12."
vector,"The public 
interface for the StringMap class appears in Figure 15-1. 
 
 15.1 Implementing maps using vectors 
Before moving on to consider more efficient strategies, it is useful to start with a 
simple vector-based implementation just to make sure that you understand how the 
StringMap class works.  "
vector,"The public 
interface for the StringMap class appears in Figure 15-1. 
 
 15.1 Implementing maps using vectors 
Before moving on to consider more efficient strategies, it is useful to start with a 
simple vector-based implementation just to make sure that you understand how the 
StringMap class works.  "
vector,"One particularly straightforward approach is to keep track 
of the key-value pairs in a vector, each of whose elements is a structure with the 
following definition: 
 
struct KeyValuePair { 
   string key; 
   string value; 
}; 
 
Given that this type is part of the StringMap class, both the key and value fields 
of the structure have type string.  "
vector,"15.1 Implementing maps using vectors      665 
stringmap.h 
666     Maps 
"
vector,"The private section for the vector-based version of the StringMap class appears 
in Figure 15-2.  "
vector,"The bindings for the keys are kept in a vector of KeyValuePairs 
called bindings, which is stored as an instance variable for the class. 
 
"
vector,"This implementation of the vector-based version of StringMap appears in 
Figure 15-3.  "
vector,"The 
constructor and destructor contain no code because the Vector class performs its 
own storage management.  "
vector,"Given that both the get and put methods must search 
for an existing key, it makes sense for those methods to delegate the process of 
searching the vector to a private method called findKey, which looks like this: 
 
int findKey(string key) { 
   for (int i = 0;"
vector,"i < bindings.size(); i++) { 
      if (bindings.get(i).key == key) return i; 
   } 
   return -1; 
} 
 
This method returns the index at which a particular key appears in the list of keys 
already included in the bindings vector; if the key does not appear, findKey 
returns !"
vector,"15.1 Implementing maps using vectors      667 
stringmap.cpp 
668     Maps 
It is possible to improve the performance of the get method by keeping the keys 
in sorted order and applying the binary-search algorithm, which was introduced in 
section 7.5.  "
vector,"The implementation 
strategy described in the preceding section—storing the key-value pairs in sorted 
order in a vector—offers O(log N) performance for the get operation and O(N) 
performance for the put operation.  "
vector,"In this example, the important question to ask is 
whether the fact that the keys are two-letter strings makes it possible to implement 
this association more efficiently than was possible using the vector-based strategy. 
 
"
vector,"The grid used in the getStateName function is an example of a lookup table, 
which is a programming structure that makes it possible to obtain a desired value 
simply by computing the appropriate index in a table, which is typically a vector or 
a grid.  "
vector,"If you were to apply the vector-based map strategy 
to the dictionary-lookup problem, you would start at the first entry, go on to the 
second, and then the third, until you found the word.  "
vector,"It is possible to implement the basic map operations by storing key-value pairs in 
a vector.  "
vector,"Keeping the vector in sorted order makes it possible for get to run in 
O(log N) time, even though put remains O(N). 
"
vector,"For the vector-based implementation of maps, what algorithmic strategy does 
the chapter suggest for reducing the cost of the get method to O(log N) time? 
 
"
vector,"Those definitions are missing 
from the earlier version of stringmap.h that uses a vector as its underlying 
representation.  "
vector,"What happens if you copy a vector-based StringMap? 
 
"
vector,"2. 
Rewrite the vector-based implementation of the StringMap class so that it 
uses a dynamic array of KeyValuePairs, thereby ensuring that StringMap 
no longer depends on the Vector class from the Stanford libraries. 
 
"
vector,"2. 
Rewrite the vector-based implementation of the StringMap class so that it 
uses a dynamic array of KeyValuePairs, thereby ensuring that StringMap 
no longer depends on the Vector class from the Stanford libraries. 
 
"
vector,"If you store the 
child pointers in a vector, a node has the following form as a C++ structure: 
 
 
16.2 Binary search trees     693 
struct FamilyTreeNode { 
   string name; 
   Vector<FamilyTreeNode *> children; 
}; 
 
A family tree is simply a pointer to one of these nodes. 
 
"
vector,"If you store the 
child pointers in a vector, a node has the following form as a C++ structure: 
 
 
16.2 Binary search trees     693 
struct FamilyTreeNode { 
   string name; 
   Vector<FamilyTreeNode *> children; 
}; 
 
A family tree is simply a pointer to one of these nodes. 
 
"
vector,"To keep the figure neat and orderly, Figure 16-2 represents the 
children as if they were stored in a five-element array; in fact, the children field is 
a vector that grows to accommodate any number of children.  "
vector,"You will have a 
chance to explore other strategies for storing the children, such as keeping them in a 
linked list rather than a vector, in the exercises at the end of this chapter. 
 
 "
vector,"The motivation behind binary search trees 
In Chapter 15, one of the strategies proposed for representing maps—before the 
hashing algorithm made other options seem far less attractive—was to store the 
key-value pairs in a vector.  "
vector,"As defined in the chapter, the FamilyTreeNode structure uses a vector to store 
the children.  "
vector,"Such an 
interface appears in Figure 16-10.  Write the corresponding implementation 
using a vector to store the list of children. 
 
730     Trees 
5. 
Using the familytree.h interface defined in Figure 16-10, write a function 
 
FamilyTreeNode *commonAncestor(FamilyTreeNode *p1, 
                               FamilyTreeNode *p2); 
 
that returns the closest ancestor shared by p1 and p2. 
 
"
vector,"To eliminate some of the 
complexity, feel free to use a vector instead of a dynamic array. 
 
"
vector,"Characteristic vectors 
Suppose for the moment that you are working with a set whose elements always lie 
between 0 and RANGE_SIZE – 1, where RANGE_SIZE is a constant that specifies the 
size of the range to which element values are restricted.  "
vector,"Boolean arrays in which the elements indicate whether the corresponding index 
is a member of some set are called characteristic vectors.  "
vector,"The following examples 
illustrate how the characteristic-vector strategy can be used to represent the 
indicated sets, assuming that RANGE_SIZE has the value 10: 
 
 
 
 
 
 
 
The advantage of using characteristic vectors is that doing so makes it possible 
to implement the operations add, remove, and contains in constant time.  "
vector,"The following examples 
illustrate how the characteristic-vector strategy can be used to represent the 
indicated sets, assuming that RANGE_SIZE has the value 10: 
 
 
 
 
 
 
 
The advantage of using characteristic vectors is that doing so makes it possible 
to implement the operations add, remove, and contains in constant time.  "
vector,"For 
example, to add the element k to a set, all you have to do is set the element at index 
position k in the characteristic vector to true.  "
vector,"Packed arrays of bits 
Even though characteristic vectors allow highly efficient implementations in terms 
of their running time, storing characteristic vectors as explicit arrays can require a 
large amount of memory, particularly if RANGE_SIZE is large.  "
vector,"Packed arrays of bits 
Even though characteristic vectors allow highly efficient implementations in terms 
of their running time, storing characteristic vectors as explicit arrays can require a 
large amount of memory, particularly if RANGE_SIZE is large.  "
vector,"To reduce the 
storage requirements, you can pack the elements of the characteristic vector into 
754     Sets 
machine words so that the representation uses every bit in the underlying 
representation.  "
vector,"You can then store 32 elements of a 
characteristic vector in a single value of type unsigned long, since each element 
of the characteristic vector requires only one bit of information.  "
vector,"You can then store 32 elements of a 
characteristic vector in a single value of type unsigned long, since each element 
of the characteristic vector requires only one bit of information.  "
vector,"Moreover, if 
RANGE_SIZE is 256, you can store all 256 bits needed for a characteristic vector in 
an array of eight unsigned long values. 
 
"
vector,"To understand how characteristic vectors can be packed into an array of machine 
words, imagine that you want to represent the integer set consisting of the ASCII 
code for the alphabetic characters.  "
vector,"That set, which consists of the 26 uppercase 
letters with codes between 65 and 90 and the 26 lowercase letters with codes 
between 97 and 122, can be encoded as the following characteristic vector: 
 
 
 
If you want to find the bit that corresponds to a particular integer value, the simplest 
approach is to use integer division and modular arithmetic.  "
vector,"Thus, the bit in the characteristic vector 
corresponding to the character 'X' is the one highlighted in this diagram: 
 
 
 
The fact that the highlighted bit is a 1 indicates that 'X' is a member of the set. 
 
 
18.4 Optimizing sets of small integers     755 
Bitwise operators 
"
vector,"18.4 Optimizing sets of small integers     757 
Implementing characteristic vectors 
"
vector,"The bitwise operators introduced in the preceding section make it possible to 
implement operations on characteristic vectors in an extremely efficient way.  "
vector,"If you 
want to test the state of an individual bit in a characteristic vector, all you have to do 
is create a value that has a 1 bit in the desired position and 0 bits everywhere else.  
"
vector,"If you apply the & operator to the word in the characteristic vector that 
contains the bit you’re trying to find and the mask that corresponds to the correct bit 
position, all the other bits in that word will be stripped away, leaving you with a 
value that reflects the state of the desired bit. 
 
"
vector,"To make this strategy more concrete, it helps to consider the underlying 
representation of a characteristic vector in more detail.  "
vector,"struct CharacteristicVector { 
   unsigned long words[CVEC_WORDS]; 
}; 
 
where CVEC_WORDS is a constant defined as follows: 
 
const int BITS_PER_BYTE = 8; 
const int BITS_PER_LONG = BITS_PER_BYTE * sizeof(long); 
const int CVEC_WORDS = (RANGE_SIZE + BITS_PER_LONG - 1) 
                         / BITS_PER_LONG; 
 
Given this structure, you can test a specific bit in a characteristic vector using the 
function testBit, which has the following implementation: 
 
bool testBit(CharacteristicVector & cv, int k)"
vector,"<< k % BITS_PER_LONG; 
} 
 
Suppose, for example, that you call testBit(cv, 'X'), where cv is bound to 
the characteristic vector corresponding to the set of all alphabetic characters.  "
vector,"As 
758     Sets 
discussed in the section on “Packed arrays of bits” earlier in the chapter, that 
characteristic vector looks like this: 
 
 
 
The function testBit begins by choosing the appropriate word in the characteristic 
vector by evaluating the expression 
 
cv.words[k / BITS_PER_LONG]; 
 
The subscript expression k / BITS_PER_LONG determines the index of the word in 
the characteristic vector that contains the kth bit in the entire structure.  "
vector,"As 
758     Sets 
discussed in the section on “Packed arrays of bits” earlier in the chapter, that 
characteristic vector looks like this: 
 
 
 
The function testBit begins by choosing the appropriate word in the characteristic 
vector by evaluating the expression 
 
cv.words[k / BITS_PER_LONG]; 
 
The subscript expression k / BITS_PER_LONG determines the index of the word in 
the characteristic vector that contains the kth bit in the entire structure.  "
vector,"As 
758     Sets 
discussed in the section on “Packed arrays of bits” earlier in the chapter, that 
characteristic vector looks like this: 
 
 
 
The function testBit begins by choosing the appropriate word in the characteristic 
vector by evaluating the expression 
 
cv.words[k / BITS_PER_LONG]; 
 
The subscript expression k / BITS_PER_LONG determines the index of the word in 
the characteristic vector that contains the kth bit in the entire structure.  "
vector,"If k, for example, has the value 88, k % BITS_PER_LONG is 
24, which means that the mask value consists of the value 1 shifted left 24 bit 
positions, as follows: 
 
 
 
Because the mask has only a single 1 bit, the & operation in the code for testBit 
will return a nonzero value only if the corresponding bit in the characteristic vector 
is a 1.  "
vector,"If the characteristic vector contained a 0 in that bit position, there would be 
no bits common to both the vector and the mask, which means that the & operation 
would return a word containing only 0 bits.  "
vector,"If the characteristic vector contained a 0 in that bit position, there would be 
no bits common to both the vector and the mask, which means that the & operation 
would return a word containing only 0 bits.  "
vector,"The strategy of using a mask also makes it easy to manipulate the state of 
individual bits in the characteristic vector.  "
vector,"Packing characteristic vectors into the bits in a word saves a large amount of space.  
"
vector,"The trick is to compute each 
word in the new characteristic vector using a single application of the appropriate 
bitwise operator. 
 
"
vector,"If you translate this idea into the realm of characteristic 
vectors, it is easy to see that any word in the characteristic vector of the set A !"
vector,"If you translate this idea into the realm of characteristic 
vectors, it is easy to see that any word in the characteristic vector of the set A !"
vector,"B 
can be computed by applying the logical OR operation to the corresponding words in 
the characteristic vectors for those sets.  "
vector,"Template specialization 
The characteristic vector model allows sets of characters to be implemented much 
more efficiently than more general sets in terms of both space and time.  "
vector,"As an example, suppose that you wanted to define—as you will have a chance to 
do in exercise 8—a specialized implementation for the class Set<char> that uses a 
characteristic vector to store the data.  "
vector,"This fact makes it 
easy to use a characteristic vector as the underlying representation because that 
vector will require only 256 bits of storage.  "
vector,"This fact makes it 
easy to use a characteristic vector as the underlying representation because that 
vector will require only 256 bits of storage.  "
vector,"On a machine that uses 
32-bit integers, the characteristic vector will require 232 bits, which requires an 
unworkable amount of storage. 
 
"
vector,"Even if characteristic vectors cannot represent all sets of integers, they can still 
be useful as long as the actual values in the set fall into a limited range.  "
vector,"All you 
have to do is design a data structure that uses characteristic vectors as long as the 
integers stay small but then reverts to the more general binary-tree implementation 
if the client tries to store a value that is out of range.  "
vector,"As a result, clients who only 
 
Summary     761 
use integers in the restricted range get the enhanced performance associated with the 
characteristic vector strategy.  "
vector,"762     Sets 
• Sets of integers can be implemented very efficiently using arrays of Boolean 
data called characteristic vectors.  "
vector,"If you use the bitwise operators provided by 
C++, you can pack characteristic vectors into a small number of machine words 
and perform such set operations as union and intersection on many elements of 
the vector at a time. 
 
 "
vector,"If you use the bitwise operators provided by 
C++, you can pack characteristic vectors into a small number of machine words 
and perform such set operations as union and intersection on many elements of 
the vector at a time. 
 
 "
vector,"What is a characteristic vector? 
 
17."
vector,"What restrictions must be placed on a set in order to use characteristic vectors 
as an implementation strategy? 
 
"
vector,"Assuming that RANGE_SIZE has the value 10, diagram the characteristic vector 
for the set {1, 4, 9}. 
 
"
vector,"What set is represented by the following characteristic vector: 
 
 
 
By consulting the ASCII chart in Table 1-2, identify the function in <cctype> 
to which this set corresponds. 
 
"
vector,"In the diagrams used to represent characteristic vectors, an unsigned long is 
shown as taking 32 bits.  "
vector,"8. 
Implement a template specialization of the Set<char> class that uses a 
characteristic vector instead of the usual binary tree. 
 
"
vector,"9. 
Implement a template specialization of the Set<int> class that uses a 
characteristic vector as long as the elements are in the range 0 to 255 but that 
switches to the traditional representation if the client adds elements outside this 
range. 
 
 
 
 
 
 
 
 
"
vector,"The variable path keeps track of the minimum path and consists of a vector of 
arcs.  "
vector,"The first arc in the vector will start at the origin and proceed to the first 
intermediate stop.  "
vector,"If there is no 
path between the requested nodes, findShortestPath indicates that fact by 
returning an empty vector. 
 
"
vector,"You might, for example, want to store a list of 
employees in a vector.  "
vector,"Unfortunately, you can’t make any headway if you try to 
use a declaration of the following form: 
 
Vector<Employee> payroll;
   
 
 
As in the assignment example, the elements of the payroll vector only have space 
to fit an object of the Employee class.  "
vector,"Unfortunately, you can’t make any headway if you try to 
use a declaration of the following form: 
 
Vector<Employee> payroll;
   
 
 
As in the assignment example, the elements of the payroll vector only have space 
to fit an object of the Employee class.  "
vector,"It is, for example, perfectly appropriate 
to declare the payroll vector as follows: 
 
Vector<Employee *> payroll; 
 
All pointers to Employee objects are the same size and therefore fit in the same 
vector.  "
vector,"It is, for example, perfectly appropriate 
to declare the payroll vector as follows: 
 
Vector<Employee *> payroll; 
 
All pointers to Employee objects are the same size and therefore fit in the same 
vector.  "
vector,"It is, for example, perfectly appropriate 
to declare the payroll vector as follows: 
 
Vector<Employee *> payroll; 
 
All pointers to Employee objects are the same size and therefore fit in the same 
vector.  "
vector,"Thus, if you execute the code 
 
for (Employee *ep : payroll) { 
   cout << ep->getName() << "": "" << ep->getPay() << endl; 
} 
 
you get a list of all the employees in the payroll vector along with the pay that 
employee should receive.  "
vector,"
 
840     Inheritance 
Storing shape pointers in a vector 
One of the advantages of defining a Shape class hierarchy is that doing so makes it 
possible to store shapes in collection classes, as long as you remember to use 
pointers to the Shape objects rather than the objects themselves.  "
vector,"Figure 19-8 shows 
a program that assembles a collection of shapes into a vector and then draws those 
shapes on the graphics window, thereby creating a copy of the image produced by 
the first graphics program in Chapter 2.  "
vector,"The TestShapeClass program in Figure 19-8 uses a vector of shapes to hold 
the list of shapes on the graphics window.  "
vector,"That technique is useful enough 
that it probably makes sense to define a new ShapeList class that extends 
Vector<Shape *> so that it can store a vector of shape pointers but also 
provides additional methods that are useful in working with shapes on the 
screen. 
 
"
vector,"That technique is useful enough 
that it probably makes sense to define a new ShapeList class that extends 
Vector<Shape *> so that it can store a vector of shape pointers but also 
provides additional methods that are useful in working with shapes on the 
screen. 
 
"
vector,"Similarly, the 
iterator for the class Vector<int> is called Vector<int>::iterator. 
 
"
vector,"Similarly, the 
iterator for the class Vector<int> is called Vector<int>::iterator. 
 
"
vector,"By contrast, 
the iterator for the Vector class is a RandomAccessIterator.  "
vector,"As a consequence, 
it is possible to iterate backwards through the elements of the vector v using the 
following code, which prints the elements on the console in reverse order: 
 
Vector<int>::iterator it = v.end(); 
while (it !"
vector,"As a consequence, 
it is possible to iterate backwards through the elements of the vector v using the 
following code, which prints the elements on the console in reverse order: 
 
Vector<int>::iterator it = v.end(); 
while (it !"
vector,"The initial value of it refers to the nonexistent element that follows the end of 
the vector.  "
vector,"Similarly, you can print every other 
element of v using the following code: 
 
for (Vector<int>::iterator it = v.begin(); 
                           it < v.end(); it += 2) { 
   cout << *it << endl; 
} 
 
Using iterators in such unusual ways often ends up making programs difficult to 
maintain, much like code that tries to be too clever with its pointer manipulation.  
"
vector,"Thus, mapAll invokes the callback 
function in index order for a Vector, in row-major order for a Grid, in alphabetical 
order for a Lexicon, in ascending key order for a Map, and in ascending value order 
for a Set. 
 
"
vector,"Assuming that 
you are using the array-based implementation of Vector from Figure 14-11, you 
can implement mapAll as shown in Figure 20-4.  As long as you define a recursive 
helper method, implementing mapAll for the Map class is almost as simple.  "
vector,"Suppose, for example, that you need to sort the elements of a vector and want to 
take advantage of the extensive engineering work that the designers of the C++ 
library have invested in creating an efficient library implementation of a general 
sorting algorithm.  "
vector,"That function, however, does not take a Vector argument as you might 
expect, especially after seeing the various implementations of a sort function in 
Chapter 10.  "
vector,"The library version of the sort function instead takes two iterators that 
define the subrange of the vector you want to sort.  "
vector,"To sort all the elements of a 
vector v, you call 
 
sort(v.begin(), v.end()); 
 
If you wanted to sort only the first k elements of v, you could call 
 
sort(v.begin(), v.begin() + k); 
 
"
vector,"The iterator class for Vector implements the RandomAccessIterator model, 
which means that adding k to an iterator produces an iterator pointing to the value k 
elements further along. 
 
 
"
vector,"For example, you 
can randomly shuffle the elements of the vector v by calling 
 
random_shuffle(v.begin(), v.end()); 
 
The functions grouped at the bottom of Table 20-2 take functional arguments 
that operate on the value type of a collection.  "
vector,"As an example, you can count 
the number of negative values in an integer vector v by making the following call: 
 
count_if(v.begin(), v.end(), bind2nd(less<int>(), 0)) 
 
"
vector,"As a simple example, you can arrange the integer vector vec in reverse order by 
making the following call: 
 
sort(vec.begin(), vec.end(), greater<int>()); 
 
In this call, the comparison function is an instance of greater<int> instead of the 
default less<int>, which means that the order is reversed. 
 
"
vector,"For example, if you define the function 
 
bool lessIgnoringCase(string s1, string s2) { 
   return toLowerCase(s1) < toLowerCase(s2); 
} 
 
you can sort the string vector names without regard to case by calling 
 
sort(names.begin(), names.end(), lessIgnoringCase()); 
 
In much the same way, you can sort the string vector words from shortest to longest 
by defining the function 
 
bool isShorter(string s1, string s2) { 
   return s1.length() < s2.length(); 
} 
 
and then calling 
 
sort(words.begin(), names.end(), isShorter()); 
 
You can also pass a comparison function to the constructors for the Map and Set 
classes to define the order in which elements appear.  "
vector,"For example, if you define the function 
 
bool lessIgnoringCase(string s1, string s2) { 
   return toLowerCase(s1) < toLowerCase(s2); 
} 
 
you can sort the string vector names without regard to case by calling 
 
sort(names.begin(), names.end(), lessIgnoringCase()); 
 
In much the same way, you can sort the string vector words from shortest to longest 
by defining the function 
 
bool isShorter(string s1, string s2) { 
   return s1.length() < s2.length(); 
} 
 
and then calling 
 
sort(words.begin(), names.end(), isShorter()); 
 
You can also pass a comparison function to the constructors for the Map and Set 
classes to define the order in which elements appear.  "
vector,"Implementing an iterator for the Vector class 
Implementing iterator for the Vector class presents a relatively straightforward 
challenge.  "
vector,"Implementing an iterator for the Vector class 
Implementing iterator for the Vector class presents a relatively straightforward 
challenge.  "
vector,"The underlying structure of the vector is defined in terms of a simple 
dynamic array, and the only state information the iterator needs to maintain is the 
current index value, along with a pointer back to the Vector object itself.  "
vector,"The underlying structure of the vector is defined in terms of a simple 
dynamic array, and the only state information the iterator needs to maintain is the 
current index value, along with a pointer back to the Vector object itself.  "
vector,"The 
private instance variables of the iterator class can therefore be declared like this: 
 
const Vector *vp; 
int index; 
 
The variable vp is declared here as a pointer to a const Vector to let the compiler 
know that the operations of the iterator don’t change the vector itself.  "
vector,"The 
private instance variables of the iterator class can therefore be declared like this: 
 
const Vector *vp; 
int index; 
 
The variable vp is declared here as a pointer to a const Vector to let the compiler 
know that the operations of the iterator don’t change the vector itself.  "
vector,"The 
private instance variables of the iterator class can therefore be declared like this: 
 
const Vector *vp; 
int index; 
 
The variable vp is declared here as a pointer to a const Vector to let the compiler 
know that the operations of the iterator don’t change the vector itself.  "
vector,"The begin 
function in the Vector class needs to return an iterator in which the variable vp 
points to the vector itself and the variable index is set to 0.  "
vector,"The begin 
function in the Vector class needs to return an iterator in which the variable vp 
points to the vector itself and the variable index is set to 0.  "
vector,"The end function must 
return an iterator in which vp is initialized in the same way and the variable index 
is set to the number of elements in the vector, which is stored in the variable count.  
"
vector,"Both of these functions can be implemented easily if the iterator class includes a 
constructor that takes these two values and uses them to initialize the corresponding 
instance variables, like this: 
 
iterator(const Vector *vp, int index) { 
   this->vp = vp; 
   this->index = index; 
} 
 
The Vector class needs access to this constructor, but it should not be available to 
clients.  "
vector,"Both of these functions can be implemented easily if the iterator class includes a 
constructor that takes these two values and uses them to initialize the corresponding 
instance variables, like this: 
 
iterator(const Vector *vp, int index) { 
   this->vp = vp; 
   this->index = index; 
} 
 
The Vector class needs access to this constructor, but it should not be available to 
clients.  "
vector,"The easiest way to accomplish this goal is to have the iterator class 
declare Vector as a friend.  "
vector,"The complete 
code for the Vector implementation of the iterator class appears in Figure 20-9. 
912     Strategies for Iteration 
vector iterator, p1 
 
20.6  "
vector,"The complete 
code for the Vector implementation of the iterator class appears in Figure 20-9. 
912     Strategies for Iteration 
vector iterator, p1 
 
20.6  "
vector,"Implementing iterators      913 
vector iterator, p2 
914     Strategies for Iteration 
vector iterator, p3 
 
20.6  "
vector,"Implementing iterators      913 
vector iterator, p2 
914     Strategies for Iteration 
vector iterator, p3 
 
20.6  "
vector,"If a client tries to use an uninitialized iterator, to 
dereference an iterator that is out of range, or to compare iterators from different 
vectors, the implementation calls error to report the problem.  "
vector,"On the other hand, if you are willing to give up some amount of error checking 
to simplify the code, you can implement iterator for the Vector class using only 
a few lines of code in contrast to the four pages taken up by Figure 20-9.  
"
vector,"The fact that iterators can be pointers offers another strategy for implementing 
iterator for the Vector class.  "
vector,"There is, however, one additional definition you have to include in the definition 
in order to make the range-based for statement work in conjunction with the 
Vector class.  "
vector,"= collection.end(); it++) { 
   type var = *it; 
   body of the loop 
} 
 
To make this translation work, there has to be a nested type within the Vector class 
named iterator.  "
vector,"The typedef keyword is also just what you need to complete the streamlined 
implementation of the iterator type for the Vector class.  "
vector,"All you need to do is 
export the following definition from the public section of Vector: 
 
typedef ValueType *iterator; 
 
Implementing iterators for the other collection classes 
Even though it implements the most sophisticated level of iterator functionality, 
iterators are considerably easier to implement for Vector than they are for most of 
the other collection classes.  "
vector,"All you need to do is 
export the following definition from the public section of Vector: 
 
typedef ValueType *iterator; 
 
Implementing iterators for the other collection classes 
Even though it implements the most sophisticated level of iterator functionality, 
iterators are considerably easier to implement for Vector than they are for most of 
the other collection classes.  "
vector,"18. Use the capabilities of the <functional> library to write a single call to 
count_if that returns the number of even values in the integer vector vec. 
 
19."
list,"640     Linear Structures 
array queuepriv.h 
 
14.3 Implementing queues      641 
array queue-impl, p1 
642     Linear Structures 
array queue-impl, p2 
 
14.3 Implementing queues      643 
array queue-impl, p3 
644     Linear Structures 
Linked-list representation of queues 
The queue class also has a simple representation using list structure.  "
list,"640     Linear Structures 
array queuepriv.h 
 
14.3 Implementing queues      641 
array queue-impl, p1 
642     Linear Structures 
array queue-impl, p2 
 
14.3 Implementing queues      643 
array queue-impl, p3 
644     Linear Structures 
Linked-list representation of queues 
The queue class also has a simple representation using list structure.  "
list,"To illustrate 
the basic approach, the elements of the queue are stored in a list beginning at the 
head of the queue and ending at the tail.  "
list,"The code for the linked-list implementation of queues appears in Figure 14-10.  
"
list,"On the whole, the code is reasonably straightforward, particularly if you use the 
linked-list implementation of stacks as a model.  "
list,"The enqueue operation, for example, adds a new cell 
after the one marked by the tail pointer and then updates the tail pointer so that 
it continues to indicate the end of the list.  "
list,"14.3 Implementing queues      645 
list queuepriv.h 
646     Linear Structures 
list-impl, p1 
 
14.3 Implementing queues      647 
list-impl, p2 
648     Linear Structures 
"
list,"14.3 Implementing queues      645 
list queuepriv.h 
646     Linear Structures 
list-impl, p1 
 
14.3 Implementing queues      647 
list-impl, p2 
648     Linear Structures 
"
list,"14.3 Implementing queues      645 
list queuepriv.h 
646     Linear Structures 
list-impl, p1 
 
14.3 Implementing queues      647 
list-impl, p2 
648     Linear Structures 
"
list,"Instead, the enqueue implementation uses the tail pointer to 
find the end of the linked-list chain and adds the new cell at that point.  "
list,"You have 
also had the chance to see array- and list-based implementations of the Stack and 
Queue classes, along with the public interface for a polymorphic Vector class. 
 
"
list,"658     Linear Structures 
• Stacks can be implemented using a linked-list structure in addition to the more 
traditional array-based representation. 
"
list,"• Queues can also be represented using a linked list marked by two pointers, one 
to the head of the queue and another to the tail. 
"
list,"3. 
Using the linked-list implementation, draw a diagram of the cells used to 
represent myStack after the following operations have been performed: 
 
Stack<char> myStack; 
myStack.push('A'); 
myStack.push('B'); 
myStack.push('C'); 
 
4. 
"
list,"Draw a diagram showing the internal structure of a linked-list queue after the 
computer finishes the set of operations in question 7. 
 
11."
list,"How can you tell if a linked-list queue is empty? 
 
12."
list,"Use your unit test program to validate both the array- and 
list-based implementations of the Stack class. 
 
"
list,"For both the array- and 
 
Exercises      661 
list-based implementations of the queue, make all the changes necessary to 
export the method 
 
void reverse(); 
 
that reverses the elements in the queue.  "
list,"When an item is enqueued in a priority queue, it is inserted in the list 
ahead of any lower priority items.  "
list,"Using the linked-list implementation of queues as a model, design and 
implement a pqueue.h interface that exports a class called PriorityQueue, 
which exports the same methods as the traditional Queue class with the 
exception of the enqueue method, which now takes an additional argument, 
as follows: 
 
void enqueue(ValueType value, double priority); 
 
"
list,"Rewrite vector.h so that it uses a linked list as its underlying representation.  
"
list,"For this exercise, reimplement MyString so that it 
uses a linked list of characters instead of a dynamic array as its underlying 
representation. 
 
"
list,"Although there are more efficient techniques for doing so, one strategy for 
implementing extended-precision arithmetic is to store the individual digits in 
a linked list.  "
list,"In such representations, it is conventional—mostly because 
doing so makes the arithmetic operators easier to implement—to arrange the 
list so that the units digit comes first, followed by the tens digit, then the 
hundreds digit, and so on.  "
list,"Thus, to represent the number 1729 as a linked list, 
you would arrange the cells in the following order: 
 
 
 
Design and implement a class called BigInt that uses this representation 
to implement extended-precision arithmetic, at least for nonnegative values.  
"
list,"i < bindings.size(); i++) { 
      if (bindings.get(i).key == key) return i; 
   } 
   return -1; 
} 
 
This method returns the index at which a particular key appears in the list of keys 
already included in the bindings vector; if the key does not appear, findKey 
returns !"
list,"Thus, put requires O(N) time even in a sorted list. 
 
 "
list,"If you want to 
simulate the strategy of using thumb tabs for every possible first character, you can 
divide the map into 256 independent lists of key-value pairs—one for each starting 
character.  "
list,"Whenever the client calls put or get with some key, the code can 
choose the appropriate list on the basis of the first character.  "
list,"As a result, some of the lists will 
remain empty, while others become quite long.  "
list,"Although other representations are possible, a common strategy is to 
use the hash code to compute an index into an array of linked lists, each of which 
holds all the key-value pairs corresponding to that hash code.  "
list,"Each of those linked 
lists is traditionally called a bucket.  "
list,"To find the key you’re looking for, all you need 
to do is search through the list of key-value pairs in that bucket. 
 
"
list,"% nBuckets; 
 
A bucket number represents an index into an array, each of whose elements is a 
pointer to the first cell in a list of key-value pairs.  "
list,"Thus, the common property 
that links all the keys in a single linked list is that they all hash to the same bucket.  
"
list,"If commonly used keys return the same hash code, the linked lists 
for those buckets will become longer and take more time to search. 
 
"
list,"Each of the elements in buckets is a linked list of the key-value pairs 
that hash to the bucket at that index.  "
list,"The cells in each chain are similar to those you 
have seen in the earlier examples of linked lists except for the fact that each cell 
contains both a key and a value.  "
list,"Each element, moreover, is a pointer 
to the first cell in the linked-list chain of key-value pairs.  "
list,"The constructor creates the dynamic array and sets 
each element of the buckets array to NULL, which indicates an empty list.  "
list,"The put method therefore links the key ""AK"" into the list in bucket #0, which 
was initially empty.  "
list,"The result is therefore a linked list containing only the cell for 
Alaska, which looks like this: 
 
 
 
By much the same process, you can figure out that ""AL"" goes in bucket #1. 
 
 
 
Eventually—particularly in a hash table with 13 buckets—a collision will occur.  
"
list,"By distributing the keys among 
the buckets, the get and put functions have a much shorter list to search.  "
list,"To achieve this goal, it is important that the linked-list chains emerging from each 
bucket remain short.  "
list,"A common implementation of the hashing algorithm is to allocate a dynamic 
array of buckets, each of which contains a linked list of the keys that hash to that 
bucket.  "
list,"Because the get and put methods always find the first entry in the linked list, 
you can ensure that add hides the previous definitions simply by adding each 
new entry at the beginning of the list for a particular hash bucket.  "
list,"Because the get and put methods always find the first entry in the linked list, 
you can ensure that add hides the previous definitions simply by adding each 
new entry at the beginning of the list for a particular hash bucket.  "
list,"— Willa Cather, O Pioneers!, 1913 
690     Trees 
 
As you have seen in several earlier chapters, linked lists make it possible to 
represent an ordered collection of values without using arrays.  "
list,"Although linked lists require more memory space than arrays and are less efficient 
for operations such as selecting a value at a particular index position, they have the 
advantage that insertion and deletion operations can be performed in constant time. 
 
"
list,"The use of pointers to define the ordering relationship among a set of values is 
considerably more powerful than the linked-list example suggests and is by no 
means limited to creating linear structures.  "
list,"You will have a 
chance to explore other strategies for storing the children, such as keeping them in a 
linked list rather than a vector, in the exercises at the end of this chapter. 
 
 "
list,"In that case, the solution was to replace the array with a 
linked list.  "
list,"After all, inserting a new element into a linked list—as long as 
you have a pointer to the cell prior to the insertion point—is a constant-time 
operation. 
 
"
list,"The trouble with linked lists is that they do not support the binary search 
algorithm in any efficient way.  "
list,"In 
a linked list, the only way to do so is to iterate through all the link pointers in the 
first half of the list. 
 
"
list,"In 
a linked list, the only way to do so is to iterate through all the link pointers in the 
first half of the list. 
 
"
list,"To get a more concrete sense of why linked lists have this limitation, suppose 
that you have a linked list containing the names of Walt Disney’s seven dwarves: 
 
 
 
The elements in this list appear in lexicographic order, which is the order imposed 
by their internal character codes. 
 
"
list,"To get a more concrete sense of why linked lists have this limitation, suppose 
that you have a linked list containing the names of Walt Disney’s seven dwarves: 
 
 
 
The elements in this list appear in lexicographic order, which is the order imposed 
by their internal character codes. 
 
"
list,"To get a more concrete sense of why linked lists have this limitation, suppose 
that you have a linked list containing the names of Walt Disney’s seven dwarves: 
 
 
 
The elements in this list appear in lexicographic order, which is the order imposed 
by their internal character codes. 
 
"
list,"Given a linked list of this sort, you can easily find the first element, because the 
initial pointer gives you its address.  "
list,"696     Trees 
Although it might at first seem silly, it is useful to consider what happens if you 
simply point at the middle of the list instead of the beginning: 
 
 
 
In this diagram, you have no problem at all finding the middle element.  "
list,"It’s 
immediately accessible through the list pointer.  "
list,"The problem, however, is that 
you’ve thrown away the first half of the list.  "
list,"In the conceptual 
diagram, all you need to do is reverse the arrows: 
 
 
 
Each of the strings is now accessible, and you can easily divide the entire list in 
half. 
 
"
list,"The binary search 
algorithm requires you to find the middle of not only the original list but its sublists 
as well.  "
list,"You therefore need to restructure the lists that precede and follow Grumpy, 
using the same decomposition strategy.  "
list,"Every cell points in two directions: to the 
midpoint of the list that precedes it and to the midpoint of the list that follows it.  
"
list,"Every cell points in two directions: to the 
midpoint of the list that precedes it and to the midpoint of the list that follows it.  
"
list,"Applying this process transforms the original list into the following binary tree: 
 
 
 
The most important feature about this particular style of binary tree is that it is 
ordered.  "
list,"The resulting figure, which is shown in Figure 16-4, looks more like a linked list 
than a tree.  "
list,"Another possibility is to include an extra pointer in these nodes 
that will allow them to form a linked list of the children."
list,"Such an 
interface appears in Figure 16-10.  Write the corresponding implementation 
using a vector to store the list of children. 
 
730     Trees 
5. 
Using the familytree.h interface defined in Figure 16-10, write a function 
 
FamilyTreeNode *commonAncestor(FamilyTreeNode *p1, 
                               FamilyTreeNode *p2); 
 
that returns the closest ancestor shared by p1 and p2. 
 
"
list,Trees have many applications beyond those listed in this chapter.  
list,"The 
root of the tree corresponds to the empty string, and each successive level of the 
tree corresponds to the subset of the entire word list formed by adding one 
more letter to the string represented by its parent.  "
list,"Defining a set by enumeration is simply a matter of listing its 
elements.  "
list,"By convention, the elements in the list are enclosed in curly braces 
and separated by commas.  "
list,"Figure 17-1, for example, verifies 
the first of De Morgan’s laws listed in Table 17-1.  "
list,"These operators, which are listed in 
Table 17-2, are called bitwise operators.  "
list,"In practice, the most common strategies are: 
 
• Storing the connections for each node in an adjacency list. 
"
list,"
 
 
18.2 Representation strategies      773 
Representing connections using an adjacency list 
The simplest way to represent connections in a graph is to store within the data 
structure for each node a list of the nodes to which it is connected.  "
list,"
 
 
18.2 Representation strategies      773 
Representing connections using an adjacency list 
The simplest way to represent connections in a graph is to store within the data 
structure for each node a list of the nodes to which it is connected.  "
list,"This structure is 
called an adjacency list.  "
list,"For example, in the now-familiar airline graph 
 
 
 
the adjacency lists for each node look like this: 
 
Atlanta 
!"
list,"Although lists provide a convenient way to represent the connections in a graph, 
they can be inefficient when an operation requires searching through the list of arcs 
associated with a node.  "
list,"Although lists provide a convenient way to represent the connections in a graph, 
they can be inefficient when an operation requires searching through the list of arcs 
associated with a node.  "
list,"For example, if you use the adjacency list representation, 
determining whether two nodes are connected requires O(D) time, where D 
represents the degree of the originating node.  "
list,"If the nodes in a graph all have a 
small number of neighbors, the cost of searching through this list is small.  "
list,"In terms of execution time, using an adjacency matrix is considerably faster than 
using an adjacency list.  "
list,"For most graphs, the adjacency list representation 
tends to be more efficient in terms of space, although some graphs will violate this 
principle.  "
list,"In the adjacency list representation, each node has a list of connections, 
which, in the worst case, will be Dmax entries long, where Dmax is the maximum 
degree of any node in the graph, which is therefore the maximum number of arcs 
emanating from a single node.  "
list,"In the adjacency list representation, each node has a list of connections, 
which, in the worst case, will be Dmax entries long, where Dmax is the maximum 
degree of any node in the graph, which is therefore the maximum number of arcs 
emanating from a single node.  "
list,"The space cost for adjacency lists is therefore 
O(N "" Dmax).  "
list,"If, on the other hand, the graph contains many 
nodes but relatively few interconnections, the adjacency list representation can save 
considerable space. 
 
"
list,"The analysis in the preceding paragraph, for example, shows that 
the list representation is likely to be more appropriate for sparse graphs; if you are 
working with dense graphs, the matrix representation may well be a better choice. 
 
"
list,"From the Atlanta node, the process will continue to follow 
the path by choosing the starting point that appears first in the alphabetical list of 
neighbors.  "
list,"In order to find something useful in that vast collection of pages, most people 
use a search engine to produce a list of those pages most likely to be of interest.  
"
list,"Unless the query terms are extremely specific, the list of all pages containing those 
terms will be unmanageably long.  "
list,"Search engines must therefore sort their results 
so that the pages appear early in the list are the ones most likely to be of interest.  
"
list,"One common approach is to construct an adjacency list, in which the data 
structure for each node contains a list of the connected nodes.  "
list,"One common approach is to construct an adjacency list, in which the data 
structure for each node contains a list of the connected nodes.  "
list,"Draw a diagram showing the adjacency list representation of the graph in the 
preceding question. 
 
"
list,"If you were asked to choose the underlying representation of a graph for a 
particular application, what factors would you consider in deciding whether to 
use adjacency lists or adjacency matrices in the implementation? 
 
"
list,"You might, for example, want to store a list of 
employees in a vector.  "
list,"Thus, if you execute the code 
 
for (Employee *ep : payroll) { 
   cout << ep->getName() << "": "" << ep->getPay() << endl; 
} 
 
you get a list of all the employees in the payroll vector along with the pay that 
employee should receive.  "
list,"C++ allows you to do so by 
including an additional specification in the code for the subclass constructor called 
an initializer list.  "
list,"The initializer list appears just before the brace that begins the 
body of the constructor and is set off from the parameter list by a colon.  "
list,"The initializer list appears just before the brace that begins the 
body of the constructor and is set off from the parameter list by a colon.  "
list,"The 
elements of the initializer list should be in one of the following forms: 
 
•"
list,"The name of the superclass, followed by a parenthesized list of arguments that 
match the prototype for some variant of the superclass constructor. 
"
list,"The concept of an initializer list is easier to demonstrate by example than it is to 
explain.  "
list,"Fortunately, these arguments are easy to 
calculate from the values x, y, and r.  The code for the Circle constructor appears 
in Figure 19-7, which shows that the only code for the Circle class appears in its 
initializer list.  "
list,"In the absence of any other specification, C++ calls the default 
constructor although clients can supply an initializer list to call a different one. 
"
list,What is an initializer list?  
list,"Where do initializer lists appear in a C++ program? 
 
"
list,"The TestShapeClass program in Figure 19-8 uses a vector of shapes to hold 
the list of shapes on the graphics window.  "
list,"The first example of the range-based for loop back in 
 
20.1  Using iterators      887 
Chapter 5 used the following code to list the two-letter words from the lexicon 
stored in EnglishWords.dat: 
 
int main() { 
   Lexicon english(""EnglishWords.dat""); 
   for (string word : english) { 
      if (word.length() == 2) { 
         cout << word << endl; 
      } 
   } 
   return 0; 
} 
 
Using iterators, the TwoLetterWords program looks like this: 
 
int main() { 
   Lexicon english(""EnglishWords.dat""); 
   for (Lexicon::iterator it = english.begin(); 
                          it !"
list,"For example, you can use the listMap function in Figure 20-3 to list all key-value 
pairs in a Map<string,int>. 
 
"
list,"To illustrate this problem, it helps to generalize the TwoLetterWords problem 
so that the program lists all the words of a specified length that is not necessarily 
two.  "
list,"More specifically, the goal in this example is to write a function 
 
void listWordsOfLengthK(const Lexicon & lex, int k) 
 
which, as its name implies, lists the words in the lexicon whose length is k. 
 
 
20.3  Encapsulating data with functions      899 
If you use the range-based for loop, this function is straightforward to code: 
 
void listWordsOfLengthK(const Lexicon & lex, int k) { 
   for (string word : lex) { 
      if (word.length() == k) { 
         cout << word << endl; 
      } 
   } 
} 
 
If you try to use the mapAll method instead, you run into a bit of a problem.  
"
list,"To make sure that the callback function has 
the information in needs, the client must somehow pass k to the mapping function, 
which must then turn around and pass that same value back to the function that lists 
the words.  "
list,"900     Strategies for Iteration 
To solve the problem of listing all words with k letters, all you need to do is 
define a new class that stores k in an instance variable, but also exports a method 
that prints out the current word from the lexicon if its length matches the stored 
value of k.  "
list,"Although the capabilities 
available through this interface are quite extensive, you can make considerable 
headway using the functions listed in Table 20-2.  "
list,"You can, for example, list all two-letter words in a lexicon called lex by calling 
 
for_each(lex.begin(), lex.end(), printTwoLetterWords); 
 
where printTwoLetterWords is the callback function defined in the section on 
“Mapping functions” earlier in this chapter.  "
list,"The callback function can also be a 
function object, which means that you can list the k-letter words by calling 
 
for_each(lex.begin(), lex.end(), ListKLetterWords(k)); 
 
You can use the functions in the <algorithm> interface as building blocks for 
more sophisticated operations.  "
list,"5. 
In the UML diagram for the iterator hierarchy is Figure 20-1, the list of 
methods in the ForwardIterator box is empty.  "
list,"List the complete set of operators implemented by an iterator offering the 
RandomAccessIterator level of service. 
 
"
map,"Chapter 15 
Maps 
 
 
 
 
 
 
 
 
A map was a fine thing to study when you were disposed to think 
of something else . . . 
"
map,"Chapter 15 
Maps 
 
 
 
 
 
 
 
 
A map was a fine thing to study when you were disposed to think 
of something else . . . 
"
map,"— George Eliot, Middlemarch, 1874 
664     Maps 
 
One of the most useful data structures you have encountered in this book is the map, 
which implements an association between keys and values.  "
map,"— George Eliot, Middlemarch, 1874 
664     Maps 
 
One of the most useful data structures you have encountered in this book is the map, 
which implements an association between keys and values.  "
map,"Chapter 5 introduces 
two classes—Map and HashMap—that implement the map idea.  "
map,"Chapter 5 introduces 
two classes—Map and HashMap—that implement the map idea.  "
map,"The Map class is slightly less 
efficient but has the advantage of iterating through the keys in their natural order. 
 
"
map,"Chapter 16 then introduces 
the concept of a tree, which provides the necessary framework for building the Map 
class, which provides logarithmic-time operations while retaining the capability of 
processing the keys in order. 
 
"
map,"Although templates are essential in the library versions of 
the collection classes, the additional complexity they require can easily get in the 
way of understanding the structure of the algorithms used to implement the map 
idea.  "
map,"As a further 
simplification, the public section of the StringMap class exports only those 
methods that are essential to the map abstraction: put and get.  "
map,"The public 
interface for the StringMap class appears in Figure 15-1. 
 
 15.1 Implementing maps using vectors 
Before moving on to consider more efficient strategies, it is useful to start with a 
simple vector-based implementation just to make sure that you understand how the 
StringMap class works.  "
map,"15.1 Implementing maps using vectors      665 
stringmap.h 
666     Maps 
"
map,"15.1 Implementing maps using vectors      665 
stringmap.h 
666     Maps 
"
map,"15.1 Implementing maps using vectors      667 
stringmap.cpp 
668     Maps 
It is possible to improve the performance of the get method by keeping the keys 
in sorted order and applying the binary-search algorithm, which was introduced in 
section 7.5.  "
map,"15.1 Implementing maps using vectors      667 
stringmap.cpp 
668     Maps 
It is possible to improve the performance of the get method by keeping the keys 
in sorted order and applying the binary-search algorithm, which was introduced in 
section 7.5.  "
map,"Although it is certainly possible to check whether the key already exists in the 
map—and even to determine exactly where a new key needs to be added—in 
O(log N) time, inserting the new key-value pair at that position requires shifting 
every subsequent entry forward.  "
map,"15.2 Lookup tables 
The map abstraction comes up so frequently in programming that it is worth 
investing significant effort into improving its performance.  "
map,"The data structure that you choose must therefore 
be able to represent a map from two-letter abbreviations to state names. 
 
 
"
map,"You could, of course, encode the translation table in a StringMap or, more 
generally, a Map<string,string>.  "
map,"In this chapter, the goal is to identify new implementation strategies for 
maps that operate more efficiently.  "
map,"There are no loops in 
the implementation or any code that depends at all on the number of keys in the 
map.  "
map,"If the keys could be arbitrary strings—as they are in the library 
version of the Map class—the lookup-table strategy no longer applies, at least in its 
current form.  "
map,"670     Maps 
 
If you think about how this question applies to real-life applications, you may 
discover that you in fact use something akin to the lookup-table strategy when you 
search for words in a dictionary.  "
map,"If you were to apply the vector-based map strategy 
to the dictionary-lookup problem, you would start at the first entry, go on to the 
second, and then the third, until you found the word.  "
map,"At least for maps like StringMap that use strings as their key type, it is possible 
to apply the same strategy.  "
map,"In this type of map, each key begins with some 
character value, although that character is not necessarily a letter.  "
map,"If you want to 
simulate the strategy of using thumb tabs for every possible first character, you can 
divide the map into 256 independent lists of key-value pairs—one for each starting 
character.  "
map,"Unfortunately, keys in a map—like words in a dictionary—are not uniformly 
distributed.  "
map,"If you use a map in an application, it is likely that most of the 256 
possible first characters never appear at all.  "
map,"On the other hand, there is no reason that you have to use only the first character 
of the key as you try to optimize the performance of the map.  "
map,"15.3 Hashing 
The best way to improve the efficiency of the map implementation is to come up 
with a way of using the key to determine, at least fairly closely, where to look for 
the corresponding value.  "
map,"672     Maps 
"
map,"An implementation of the map 
abstraction that uses this strategy is conventionally called a hash table. 
"
map,"In this 
implementation, the code iterates through each character in the key, updating a 
value stored in the local variable hash, which is declared as an unsigned integer 
674     Maps 
and initialized to the seemingly random constant 5381.  "
map,"678     Maps 
If you look at the declaration of the instance variable buckets in Figure 15-7, 
the syntax may initially seem confusing.  "
map,"680     Maps 
state map 
 
15.3 Hashing      681 
"
map,"Although the mathematical details are beyond the scope of this text, maintaining a 
load factor of 0.7 or less means that the average cost of looking up a key in a map is 
O(1).  "
map,"If a client keeps entering more and more 
entries into a map, the performance will eventually decline.  "
map,"Unfortunately, if you increase the number of buckets, the bucket 
numbers all change, which means that the code to expand the table must reenter 
682     Maps 
every key from the old table into the new one.  "
map,"In addition to the put and get methods supported 
by the minimal StringMap class, the HashMap class exports the methods size, 
isEmpty, containsKey, remove, and clear, along with bracket selection that 
make it possible to use maps as associative arrays and the necessary definitions 
for the copy constructor and assignment operator to support deep copying. 
"
map,"The Map class 
itself—which makes it possible to iterate through the keys in ascending order—
requires a more complex data structure called a tree, which is the subject of 
Chapter 16. 
 
"
map,"It is possible to implement the basic map operations by storing key-value pairs in 
a vector.  "
map,"• Specific applications may make it possible to implement map operations using a 
lookup table in which both get and put run in O(1) time. 
"
map,"• Maps can be implemented very efficiently using a strategy called hashing, in 
which keys are converted to an integer that determines where the implementation 
should look for the result. 
"
map,"As long as the ratio of the number of entries to the number of buckets 
does not exceed about 0.7, the get and put methods operate in O(1) time on 
684     Maps 
average.  "
map,"For the vector-based implementation of maps, what algorithmic strategy does 
the chapter suggest for reducing the cost of the get method to O(log N) time? 
 
"
map,"In tracing through the code that enters the state abbreviation into a map with 
13 buckets, the text notes that the entries for ""AK"" and ""KS"" collide in 
bucket #0.  "
map,"The 
characters used to encode Roman numerals have the following values: 
 
686     Maps 
I 
! 
"
map,"The simplest approach to 
688     Maps 
dealing with collisions of this sort is to store each new key in the first free cell 
at or after its expected hash position.  "
map,"The motivation behind binary search trees 
In Chapter 15, one of the strategies proposed for representing maps—before the 
hashing algorithm made other options seem far less attractive—was to store the 
key-value pairs in a vector.  "
map,"Is it possible that a similar strategy would improve the performance of 
put for the map?  "
map,"714     Trees 
insertNode, p1 
 
16.3 Balanced trees     715 
insertNode, p2 
716     Trees 
insertNode, p3 
 
16.4 Implementing maps using BSTs     717 
2. 
"
map,"16.4 Implementing maps using BSTs 
As noted in Chapter 15, the Standard Template Library uses binary search trees to 
implement the map abstraction.  "
map,"16.4 Implementing maps using BSTs 
As noted in Chapter 15, the Standard Template Library uses binary search trees to 
implement the map abstraction.  "
map,"The hard parts of implementing the map abstraction using binary search trees are 
almost entirely in the code for binary search trees themselves, which you have 
already seen in this chapter.  "
map,"To apply this idea to the Map class, there are just a few 
tasks left to perform: 
 
•"
map,"The code for manipulating the tree must be embedded in the Map class. 
 
"
map,"That 
exercise encouraged you to use a map to store the translation tables, but there 
are other ways to approach the problem.  "
map,"Reimplement the Map class so that it uses a red-black tree as its underlying 
representation.  "
map,"Given the implementations of Map and HashMap, the 
corresponding Set classes turn out to be relatively easy to write.  "
map,"These operators, 
moreover, take either a set or a single element as their right hand side, which makes 
it possible, for example, to add the value v to a set s by writing 
 
s += v; 
 
 17.3 Implementation strategies for sets 
As was the case for maps, there are two common strategies for implementing the 
Set class.  "
map,"The 
fundamental insight you need to develop a simple implementation is that sets and 
maps are essentially the same.  "
map,"You can easily build the Set class using the Map 
class.  "
map,"If you adopt this strategy, the private section of the Set class needs nothing 
beyond a single instance variable containing a map, as shown in Figure 17-3.  "
map,"The 
value field in the map is ignored; membership is determined by checking whether a 
key exists in the map.  "
map,"The 
value field in the map is ignored; membership is determined by checking whether a 
key exists in the map.  "
map,"The Map class, however, requires a value field.  "
map,"When you define one abstraction in terms of another—as in the current proposal 
to implement sets by using maps—the resulting abstractions are said to be layered.  
"
map,"This strategy of layering the implementation of sets on top of the implementation 
of maps is not in itself sufficient to write the code for the Set class, which exports 
the various high-level operations that are not part of the Map class.  "
map,"This strategy of layering the implementation of sets on top of the implementation 
of maps is not in itself sufficient to write the code for the Set class, which exports 
the various high-level operations that are not part of the Map class.  "
map,"The high-level operations, moreover, can easily be 
implemented by exploiting the existing capabilities of the Map class.  "
map,"The set class is straightforward to implement because much of it can be layered 
on top of the Map class, using either the tree-based or hash-based representation. 
"
map,"Complete the Set class by supplying the private section that defines the 
structure of a set and the code that implements the Set class as a layered 
abstraction on top of the tree-based version of maps. 
 
"
map,"For example, if your airline operates a plane from 
San Francisco to Dallas but has the plane stop in Denver on the return flight, that 
piece of the route map would look like this in a directed graph: 
 
 
 
The diagrams in this text represent directed graphs only if the arcs include an arrow 
indicating their direction.  "
map,"Moreover, 
since nodes in this formulation have names, it is useful for the SimpleGraph 
structure to include a map that allows clients to translate from names into the 
corresponding node structure. 
 
"
map,"The private section of the Graph class requires the sets of nodes and arcs, along 
with a map to translate node names into the corresponding node structures.  "
map,"The implementation for the 
Graph class is simpler than that of the other collection classes, given that much of 
the complexity has been shifted to the Set and Map classes on which Graph is 
based.  "
map,"With graphs as simple as the route map of this tiny airline, it is easy to compute 
the answer just by adding up the length of the arcs along all possible paths.  "
map,"The variable fixed is a map that associates each city name with the minimum 
distance to that city, as soon as that distance becomes known.  "
map,"Thus, whenever you dequeue a path from the 
priority queue, you can note that its distance is now known by storing the 
minimum distance in the map fixed. 
 
"
map,"For example, you can 
define a StringMap class that maps strings to strings by writing the following 
definition: 
 
class StringMap : public Map<string,string> { }; 
 
Using the simple type name StringMap makes programs shorter and more readable 
because it is no longer necessary to write out the template arguments everywhere 
the type name appears. 
 
 
"
map,"For example, you can 
define a StringMap class that maps strings to strings by writing the following 
definition: 
 
class StringMap : public Map<string,string> { }; 
 
Using the simple type name StringMap makes programs shorter and more readable 
because it is no longer necessary to write out the template arguments everywhere 
the type name appears. 
 
 
"
map,"This parameter contains a symbol table, which maps each variable name to its 
corresponding value.  "
map,"If the symbol 
table were the only shared information, it would be sufficient to pass a Map to the 
eval method.  "
map,"Thus, you 
can say that the second argument to plot must be chosen from the general class of 
functions that map one double into another double. 
 
 
20.2  Using functions as data values      893 
That argument, moreover, must be a data value that is part of the C++ type 
system.  "
map,"Thus, mapAll invokes the callback 
function in index order for a Vector, in row-major order for a Grid, in alphabetical 
order for a Lexicon, in ascending key order for a Map, and in ascending value order 
for a Set. 
 
"
map,"The exceptions to this rule are the classes that 
map keys into values.  "
map,"For both the Map class and the HashMap class, the callback 
function takes two arguments, which represent a key and its corresponding value.  
"
map,"For example, you can use the listMap function in Figure 20-3 to list all key-value 
pairs in a Map<string,int>. 
 
"
map,"Assuming that 
you are using the array-based implementation of Vector from Figure 14-11, you 
can implement mapAll as shown in Figure 20-4.  As long as you define a recursive 
helper method, implementing mapAll for the Map class is almost as simple.  "
map,"The 
898     Strategies for Iteration 
code in Figure 20-5 makes only the following assumptions about the 
implementation of the Map class: that it is based on binary search trees as described 
in Chapter 16, that the root of the binary search tree is stored in the instance variable 
root, and that the BSTNode type includes fields for the key and the value. 
 
"
map,"For example, if you define the function 
 
bool lessIgnoringCase(string s1, string s2) { 
   return toLowerCase(s1) < toLowerCase(s2); 
} 
 
you can sort the string vector names without regard to case by calling 
 
sort(names.begin(), names.end(), lessIgnoringCase()); 
 
In much the same way, you can sort the string vector words from shortest to longest 
by defining the function 
 
bool isShorter(string s1, string s2) { 
   return s1.length() < s2.length(); 
} 
 
and then calling 
 
sort(words.begin(), names.end(), isShorter()); 
 
You can also pass a comparison function to the constructors for the Map and Set 
classes to define the order in which elements appear.  "
map,"mapCallback so it is a synonym for the type 
“pointer to a function taking arguments of type KeyType and ValueType and 
returning no result” by including the following line in the definition of the Map 
class: 
 
typedef void (*mapCallback)(KeyType, ValueType); 
 
The prototype for the mapAll function then becomes 
 
void mapAll(mapCallback fn) 
 
918     Strategies for Iteration 
instead of the following longer—although arguably more informative—version: 
 
void mapAll(void (*fn)(KeyType, ValueType)) 
 
"
map,"Iterators for tree-structured classes like 
Map, however, turn out to be enormously tricky, mostly because the implementation 
has to translate the recursive structure of the data into an iterative form.  "
map,"• Comparison functions make it possible to specify new ordering relationships for 
the functions in the <algorithm> library and for collection classes like Map and 
Set, which need to determine the relative order of elements. 
"
map,"4. 
You can use function pointers to maintain a map of mathematical functions by 
name.  "
map,"For example, if you start with the declarations 
 
typedef double (*doubleFn)(double); 
Map<string,doubleFn> functionTable; 
 
you can then store functions under their conventional names simply by adding 
entries to functionTable.  "
map,"Starting with the extended version of the Expression class you implemented 
in exercise 4, create a function class called ExpressionFunction that turns 
an expression string into a function object that maps one double representing 
the value of the variable x into its evaluated result.  "
map,"That 
implementation, however, is layered on top of the Map class from the Stanford 
libraries, which does export an iterator class.  "
map,"You can therefore create the 
necessary iterators from the map instance variable in each set.  "
map,"Given the 
arcane rules for declarations involving template classes in C++, the 
declarations of Map iterators inside the Set class need to be marked with the 
typename keyword, leading to declarations like this: 
 
typename Map<ValueType,bool>"
map,"Given the 
arcane rules for declarations involving template classes in C++, the 
declarations of Map iterators inside the Set class need to be marked with the 
typename keyword, leading to declarations like this: 
 
typename Map<ValueType,bool>"
map,"To give yourself an even bigger challenge, implement an iterator for the Map 
class from Chapter 16, which is based on binary search trees.  "
map,"The Map iterator 
guarantees to process elements in ascending order, which corresponds to an 
inorder walk of the tree.  "
map,"The code for the Map iterator 
must therefore perform all the bookkeeping that occurs automatically as part 
when you implement the inorder walk recursively.  "
set,"For convenience, the usual 
strategy is to set the head field to 0 as well.  "
set,"If 
the head pointer is NULL, enqueue must set both the head and tail pointers so 
that they point to the cell containing the new element.  "
set,"Draw a diagram showing the internal structure of a linked-list queue after the 
computer finishes the set of operations in question 7. 
 
11."
set,"In 1963, the United States Postal Service introduced a set of two-letter codes for 
the individual states, districts, and territories of the United States.  "
set,"The point of all the complexity is to ensure that 
the results of the hashCode function are as unpredictable as possible given a 
particular set of keys.  "
set,"The constructor creates the dynamic array and sets 
each element of the buckets array to NULL, which indicates an empty list.  "
set,"Before the first cycle of the for loop, the variable hash is set to the value of the 
constant HASH_SEED, which has the value 5381. 
 
"
set,"The use of pointers to define the ordering relationship among a set of values is 
considerably more powerful than the linked-list example suggests and is by no 
means limited to creating linear structures.  "
set,"If you think about trees from a 
recursive perspective, a tree is simply a node and a set—possibly empty in the case 
of a leaf node—of attached subtrees.  "
set,"Each node 
consists of a name of a person and a set of pointers to its children.  "
set,"The stack at the beginning of this call therefore looks like 
this: 
 
 
 
  The first step in the code checks if t is set to NULL, which is true is this case, so it 
executes the body of the if statement, which begins with the line 
 
t = new BSTNode; 
 
700     Trees 
This line allocates a new node on the heap and assigns it to the reference parameter 
t, therefore changing the pointer cell in the caller, as follows: 
 
 
 
The remaining statements initialize the fields in the new node, copying the key 
Grumpy and initializing each of the subtree pointers to NULL.  "
set,"For this set of nodes, 
there is only one balanced configuration in which the nodes are correctly ordered 
with respect to each other.  "
set,"Thus, a tree consists of a node together with its set of children, 
each of which is a tree.  "
set,"Depending on the order in which nodes are inserted, given the same set of keys, 
binary search trees can have radically different structures.  "
set,"Chapter 17 
Sets 
 
 
 
 
 
 
 
 
We are an ambitious set, aren’t we? 
"
set,"Chapter 17 
Sets 
 
 
 
 
 
 
 
 
We are an ambitious set, aren’t we? 
"
set,"— Louisa May Alcott, Little Women, 1868 
738     Sets 
The Set and HashSet classes both made their appearance in Chapter 5.  "
set,"— Louisa May Alcott, Little Women, 1868 
738     Sets 
The Set and HashSet classes both made their appearance in Chapter 5.  "
set,"Given the implementations of Map and HashMap, the 
corresponding Set classes turn out to be relatively easy to write.  "
set,"This chapter 
therefore takes on the additional challenge of defining sets in a more theoretically 
precise way.  "
set,"Sets are central to both the theory and practice of computer science.  
"
set,"Understanding the theory makes it much easier for you to use sets effectively in 
your programs. 
 
 "
set,"17.1 Sets as a mathematical abstraction 
In all likelihood, you have already encountered sets at some point in your study of 
mathematics.  "
set,"17.1 Sets as a mathematical abstraction 
In all likelihood, you have already encountered sets at some point in your study of 
mathematics.  "
set,"Although the definition is not entirely precise, it is best to think of a 
set as an unordered collection of distinct elements.  "
set,"For example, the days of the 
week form a set of seven elements that can be written down as follows: 
 
{ Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } 
 
"
set,"If 
you wrote these same names down in some other order, you would still have the 
same set.  "
set,"A set, however, never contains multiple copies of the same element. 
 
"
set,"The set of weekdays is a finite set because it contains a finite number of 
elements.  "
set,"The set of weekdays is a finite set because it contains a finite number of 
elements.  "
set,"In mathematics, there are also infinite sets, such as the set of all integers.  
"
set,"In mathematics, there are also infinite sets, such as the set of all integers.  
"
set,"In a computer system, sets are usually finite, even if they correspond to infinite sets 
in mathematics.  "
set,"In a computer system, sets are usually finite, even if they correspond to infinite sets 
in mathematics.  "
set,"For example, the set of integers that a computer can represent in a 
variable of type int is finite because the hardware imposes a limit on the range of 
integer values. 
 
"
set,"To illustrate the fundamental operations on sets, it is important to have a few sets 
to use as a foundation.  "
set,"To illustrate the fundamental operations on sets, it is important to have a few sets 
to use as a foundation.  "
set,"In keeping with mathematical convention, this text uses the 
following symbols to refer to the indicated sets: 
 
! 
"
set,"The empty set, which contains no elements 
Z 
The set of all integers 
N 
The set of natural numbers, ordinarily defined in CS as 0, 1, 2, 3, . . . 
"
set,"The empty set, which contains no elements 
Z 
The set of all integers 
N 
The set of natural numbers, ordinarily defined in CS as 0, 1, 2, 3, . . . 
"
set,"The empty set, which contains no elements 
Z 
The set of all integers 
N 
The set of natural numbers, ordinarily defined in CS as 0, 1, 2, 3, . . . 
"
set,"R 
The set of all real numbers 
 
Following mathematical convention, this text uses uppercase letters to refer to sets.  
"
set,"R 
The set of all real numbers 
 
Following mathematical convention, this text uses uppercase letters to refer to sets.  
"
set,"Sets whose membership is defined—like N, Z, and R—are denoted using boldface 
letters.  "
set,"Names that refer to some unspecified set are written using italic letters, such 
as S and T. 
 
 
17.1 Sets as a mathematical abstraction     739 
Membership 
The fundamental property that defines a set is that of membership, which has the 
same intuitive meaning in mathematics that it does in English.  "
set,"Names that refer to some unspecified set are written using italic letters, such 
as S and T. 
 
 
17.1 Sets as a mathematical abstraction     739 
Membership 
The fundamental property that defines a set is that of membership, which has the 
same intuitive meaning in mathematics that it does in English.  "
set,"Names that refer to some unspecified set are written using italic letters, such 
as S and T. 
 
 
17.1 Sets as a mathematical abstraction     739 
Membership 
The fundamental property that defines a set is that of membership, which has the 
same intuitive meaning in mathematics that it does in English.  "
set,"S, which indicates that the 
value x is an element of the set S.  For example, given the sets defined in the 
preceding section, the following statements are true: 
 
 
17 !"
set,"S, which indicates that the 
value x is an element of the set S.  For example, given the sets defined in the 
preceding section, the following statements are true: 
 
 
17 !"
set,"For example, 
–4 "" N, because the set of natural numbers does not include the negative integers. 
 
"
set,"The membership of a set is typically specified in one of the two following ways: 
 
• Enumeration.  "
set,"Defining a set by enumeration is simply a matter of listing its 
elements.  "
set,"For example, the set D of single-digit natural 
numbers can be defined by enumeration as follows: 
 
D = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 
 
• Rule.  "
set,"You can also define a set by specifying a rule that distinguishes the 
members of that set.  "
set,"You can also define a set by specifying a rule that distinguishes the 
members of that set.  "
set,"In most cases, the rule is expressed in two parts: a larger set 
that provides the potential candidates and some conditional expression that 
identifies the elements that should be selected for inclusion.  "
set,"For example, the set 
D from the preceding example can also be defined like this: 
 
"
set,"N and x < 10} 
 
 
If you read this definition aloud, it comes out sounding like this: “D is defined to 
be the set of all elements x such that x is a natural number and x is less than 10.” 
 
"
set,"Set operations 
Mathematical set theory defines several operations on sets, of which the following 
are the most important: 
 
• Union.  "
set,"Set operations 
Mathematical set theory defines several operations on sets, of which the following 
are the most important: 
 
• Union.  "
set,"Set operations 
Mathematical set theory defines several operations on sets, of which the following 
are the most important: 
 
• Union.  "
set,"The union of two sets, which is written as A # B, is the set of all 
elements belonging to the set A, the set B, or both. 
 
"
set,"The union of two sets, which is written as A # B, is the set of all 
elements belonging to the set A, the set B, or both. 
 
"
set,"The union of two sets, which is written as A # B, is the set of all 
elements belonging to the set A, the set B, or both. 
 
"
set,"The union of two sets, which is written as A # B, is the set of all 
elements belonging to the set A, the set B, or both. 
 
"
set,"The intersection of two sets is written as A $ B and consists of the 
elements belonging to both A and B. 
740     Sets 
 
{1, 3, 5, 7, 9} !"
set,"The intersection of two sets is written as A $ B and consists of the 
elements belonging to both A and B. 
740     Sets 
 
{1, 3, 5, 7, 9} !"
set,"{1, 2, 3, 4}  =  {2, 3} 
 
• Set difference.  "
set,"The difference of two sets is written as A – B and consists of the 
elements belonging to A except for those that are also contained in B. 
 
{1, 3, 5, 7, 9} – {2, 4, 6, 8}  =  {1, 3, 5, 7, 9} 
{1, 2, 4, 8} – {2, 3, 5, 7}  =  {1, 4, 8} 
{2, 3} – {1, 2, 3, 4}  =  "" 
 
"
set,"In addition to set-producing operations like union and intersection, the 
mathematical theory of sets also defines several operations that determine whether 
some property holds between two sets.  "
set,"In addition to set-producing operations like union and intersection, the 
mathematical theory of sets also defines several operations that determine whether 
some property holds between two sets.  "
set,"In addition to set-producing operations like union and intersection, the 
mathematical theory of sets also defines several operations that determine whether 
some property holds between two sets.  "
set,"The most important relations on sets are the following: 
 
• Equality.  "
set,The sets A and B are equal if they have the same elements.  
set,"The 
equality relation for sets is indicated by the standard equal sign used to denote 
equality in other mathematical contexts.  "
set,"Thus, the notation A = B indicates that 
the sets A and B contain the same elements. 
"
set,"For example, the set {2, 3, 5, 7} is a subset of the set 
{1, 2, 3, 4, 5, 6, 7, 8, 9}.  "
set,"For example, the set {2, 3, 5, 7} is a subset of the set 
{1, 2, 3, 4, 5, 6, 7, 8, 9}.  "
set,"Similarly, the set N of natural numbers is a subset of 
the set Z of integers.  "
set,"Similarly, the set N of natural numbers is a subset of 
the set Z of integers.  "
set,"From the definition, it is clear that every set is a subset of 
itself.  "
set,"Mathematicians use the notation A $ B to indicate that A is a 
proper subset of B, which means that the subset relation holds but that the sets 
are not equal. 
 
"
set,"Set operations are often illustrated by drawing Venn diagrams, which are named 
for the British logician John Venn (1834–1923).  "
set,"In a Venn diagram, the individual 
sets are represented as geometric figures that overlap to indicate regions in which 
they share elements.  "
set,"For example, the results of the set operations union, 
intersection, and set difference are indicated by the shaded regions in the following 
Venn diagrams: 
 
A % B 
A !"
set,"For example, the results of the set operations union, 
intersection, and set difference are indicated by the shaded regions in the following 
Venn diagrams: 
 
A % B 
A !"
set,"B 
A – B 
 
 
 
 
 
17.1 Sets as a mathematical abstraction     741 
Identities on sets 
One of the useful bits of knowledge you can derive from mathematical set theory is 
that the union, intersection, and difference operations are related to each other in 
various ways.  "
set,"B 
A – B 
 
 
 
 
 
17.1 Sets as a mathematical abstraction     741 
Identities on sets 
One of the useful bits of knowledge you can derive from mathematical set theory is 
that the union, intersection, and difference operations are related to each other in 
various ways.  "
set,"B 
A – B 
 
 
 
 
 
17.1 Sets as a mathematical abstraction     741 
Identities on sets 
One of the useful bits of knowledge you can derive from mathematical set theory is 
that the union, intersection, and difference operations are related to each other in 
various ways.  "
set,"rhs 
 
which means that the set expressions lhs and rhs are equal by definition and can 
therefore be substituted for one another.  "
set,"The most common set identities are shown 
in Table 17-1. 
 
"
set,"The fact that the Venn diagrams along 
the right edge of Figure 17-1 have the same shaded region demonstrates that the set 
A – (B "" C) is the same as the set (A – B) # (A – C). 
 
"
set,"The fact that the Venn diagrams along 
the right edge of Figure 17-1 have the same shaded region demonstrates that the set 
A – (B "" C) is the same as the set (A – B) # (A – C). 
 
"
set,"By 
relying on data structures whose mathematical properties are well established, you 
742     Sets 
can use the theoretical underpinnings of those structures to your advantage.  "
set,"For 
example, if you write a program that uses sets as an abstract type, you may be able 
to simplify your code by applying one of the standard set identities shown in 
Table 17-1.  "
set,"For 
example, if you write a program that uses sets as an abstract type, you may be able 
to simplify your code by applying one of the standard set identities shown in 
Table 17-1.  "
set,"The justification for making that simplification comes from the abstract 
theory of sets.  "
set,"Choosing to use sets as a programming abstraction, as opposed to 
designing some less formal structure of your own, makes it easier for you to apply 
theory to practice. 
 
 "
set,"17.2 Expanding the set interface 
Although you have already encountered the Set class in the discussion of collection 
classes, the set.h interface in the Stanford libraries exports a richer set of methods 
and operators extending beyond the description in Chapter 5.  "
set,"17.2 Expanding the set interface 
Although you have already encountered the Set class in the discussion of collection 
classes, the set.h interface in the Stanford libraries exports a richer set of methods 
and operators extending beyond the description in Chapter 5.  "
set,"17.2 Expanding the set interface 
Although you have already encountered the Set class in the discussion of collection 
classes, the set.h interface in the Stanford libraries exports a richer set of methods 
and operators extending beyond the description in Chapter 5.  "
set,"Perhaps more 
importantly, the library implementation of the Set class includes several methods 
that are not included in the Standard Template Library that implement such 
high-level set operations as subset, equality, union, intersection, and set difference.  
"
set,"Perhaps more 
importantly, the library implementation of the Set class includes several methods 
that are not included in the Standard Template Library that implement such 
high-level set operations as subset, equality, union, intersection, and set difference.  
"
set,"Perhaps more 
importantly, the library implementation of the Set class includes several methods 
that are not included in the Standard Template Library that implement such 
high-level set operations as subset, equality, union, intersection, and set difference.  
"
set,"The expanded version of the interface appears in Figure 17-2. 
 
17.2 Expanding the set interface     743 
set.h, p1 
744     Sets 
set.h, p2 
 
17.2 Expanding the set interface     745 
set.h, p1 
746     Sets 
Including high-level methods and operators as part of the Set class makes it 
easier to understand set-based algorithms, largely because the implementations of 
those algorithms end up looking very much like their mathematical formulations.  
"
set,"The expanded version of the interface appears in Figure 17-2. 
 
17.2 Expanding the set interface     743 
set.h, p1 
744     Sets 
set.h, p2 
 
17.2 Expanding the set interface     745 
set.h, p1 
746     Sets 
Including high-level methods and operators as part of the Set class makes it 
easier to understand set-based algorithms, largely because the implementations of 
those algorithms end up looking very much like their mathematical formulations.  
"
set,"The expanded version of the interface appears in Figure 17-2. 
 
17.2 Expanding the set interface     743 
set.h, p1 
744     Sets 
set.h, p2 
 
17.2 Expanding the set interface     745 
set.h, p1 
746     Sets 
Including high-level methods and operators as part of the Set class makes it 
easier to understand set-based algorithms, largely because the implementations of 
those algorithms end up looking very much like their mathematical formulations.  
"
set,"The expanded version of the interface appears in Figure 17-2. 
 
17.2 Expanding the set interface     743 
set.h, p1 
744     Sets 
set.h, p2 
 
17.2 Expanding the set interface     745 
set.h, p1 
746     Sets 
Including high-level methods and operators as part of the Set class makes it 
easier to understand set-based algorithms, largely because the implementations of 
those algorithms end up looking very much like their mathematical formulations.  
"
set,"The expanded version of the interface appears in Figure 17-2. 
 
17.2 Expanding the set interface     743 
set.h, p1 
744     Sets 
set.h, p2 
 
17.2 Expanding the set interface     745 
set.h, p1 
746     Sets 
Including high-level methods and operators as part of the Set class makes it 
easier to understand set-based algorithms, largely because the implementations of 
those algorithms end up looking very much like their mathematical formulations.  
"
set,"The expanded version of the interface appears in Figure 17-2. 
 
17.2 Expanding the set interface     743 
set.h, p1 
744     Sets 
set.h, p2 
 
17.2 Expanding the set interface     745 
set.h, p1 
746     Sets 
Including high-level methods and operators as part of the Set class makes it 
easier to understand set-based algorithms, largely because the implementations of 
those algorithms end up looking very much like their mathematical formulations.  
"
set,"Our experience at Stanford 
shows that you will learn these algorithms much more easily if the code uses the 
high-level operators that the expanded Set class provides. 
 
 
"
set,"17.2 Expanding the set interface     747 
Adding operators for union, intersection, and set difference requires investing 
some thought in the design.  "
set,"17.2 Expanding the set interface     747 
Adding operators for union, intersection, and set difference requires investing 
some thought in the design.  "
set,"and "" don’t appear on the standard 
keyboard suggests that it would be wise to use more conventional symbols for these 
operators, even if C++ allowed programmers to extend the operator set.  "
set,"Although union and set difference have intuitive representations as the 
operators + and -, choosing an operator to represent intersection is a bit harder. 
 
"
set,"Although we consider other possibilities when we designed the set.h interface, 
the library implementation of the Set class uses the * operator to represent 
intersection.  "
set,"In a similar way, an element is in the 
intersection of two sets only if it is a member of both. 
 
"
set,"These operators, 
moreover, take either a set or a single element as their right hand side, which makes 
it possible, for example, to add the value v to a set s by writing 
 
s += v; 
 
 17.3 Implementation strategies for sets 
As was the case for maps, there are two common strategies for implementing the 
Set class.  "
set,"These operators, 
moreover, take either a set or a single element as their right hand side, which makes 
it possible, for example, to add the value v to a set s by writing 
 
s += v; 
 
 17.3 Implementation strategies for sets 
As was the case for maps, there are two common strategies for implementing the 
Set class.  "
set,"These operators, 
moreover, take either a set or a single element as their right hand side, which makes 
it possible, for example, to add the value v to a set s by writing 
 
s += v; 
 
 17.3 Implementation strategies for sets 
As was the case for maps, there are two common strategies for implementing the 
Set class.  "
set,"These operators, 
moreover, take either a set or a single element as their right hand side, which makes 
it possible, for example, to add the value v to a set s by writing 
 
s += v; 
 
 17.3 Implementation strategies for sets 
As was the case for maps, there are two common strategies for implementing the 
Set class.  "
set,"Other languages, 
however, typically implement sets using a hashing strategy, which is somewhat 
more efficient.  "
set,"The primary advantage of using a balanced binary tree is that doing 
so makes it easy to iterate through the elements of the set in sorted order. 
 
"
set,"The Set class in the Stanford libraries, like its 
counterpart in the STL, corresponds to the TreeSet approach, although the 
748     Sets 
libraries also export a HashSet class, which you will have a chance to implement in 
exercise 5. 
 
"
set,"The Set class in the Stanford libraries, like its 
counterpart in the STL, corresponds to the TreeSet approach, although the 
748     Sets 
libraries also export a HashSet class, which you will have a chance to implement in 
exercise 5. 
 
"
set,"The 
fundamental insight you need to develop a simple implementation is that sets and 
maps are essentially the same.  "
set,"You can easily build the Set class using the Map 
class.  "
set,"If you adopt this strategy, the private section of the Set class needs nothing 
beyond a single instance variable containing a map, as shown in Figure 17-3.  "
set,"As the 
comments in Figure 17-3 indicate, this implementation uses bool as the value type 
to suggest the idea that a particular element is either present or absent from the set. 
 
"
set,"When you define one abstraction in terms of another—as in the current proposal 
to implement sets by using maps—the resulting abstractions are said to be layered.  
"
set,"This strategy of layering the implementation of sets on top of the implementation 
of maps is not in itself sufficient to write the code for the Set class, which exports 
the various high-level operations that are not part of the Map class.  "
set,"This strategy of layering the implementation of sets on top of the implementation 
of maps is not in itself sufficient to write the code for the Set class, which exports 
the various high-level operations that are not part of the Map class.  "
set,"The code for 
these operators appears in Figure 17-4. 
 
 
18.3 Implementation strategies for sets     749 
set.cpp, p1 
750     Sets 
set.cpp, p2 
 
18.3 Implementation strategies for sets     751 
set.cpp, p3 
752     Sets 
set.cpp, p4 
 
 
18.4 Optimizing sets of small integers     753 
 17.4 Optimizing sets of small integers 
"
set,"The code for 
these operators appears in Figure 17-4. 
 
 
18.3 Implementation strategies for sets     749 
set.cpp, p1 
750     Sets 
set.cpp, p2 
 
18.3 Implementation strategies for sets     751 
set.cpp, p3 
752     Sets 
set.cpp, p4 
 
 
18.4 Optimizing sets of small integers     753 
 17.4 Optimizing sets of small integers 
"
set,"The code for 
these operators appears in Figure 17-4. 
 
 
18.3 Implementation strategies for sets     749 
set.cpp, p1 
750     Sets 
set.cpp, p2 
 
18.3 Implementation strategies for sets     751 
set.cpp, p3 
752     Sets 
set.cpp, p4 
 
 
18.4 Optimizing sets of small integers     753 
 17.4 Optimizing sets of small integers 
"
set,"The code for 
these operators appears in Figure 17-4. 
 
 
18.3 Implementation strategies for sets     749 
set.cpp, p1 
750     Sets 
set.cpp, p2 
 
18.3 Implementation strategies for sets     751 
set.cpp, p3 
752     Sets 
set.cpp, p4 
 
 
18.4 Optimizing sets of small integers     753 
 17.4 Optimizing sets of small integers 
"
set,"The code for 
these operators appears in Figure 17-4. 
 
 
18.3 Implementation strategies for sets     749 
set.cpp, p1 
750     Sets 
set.cpp, p2 
 
18.3 Implementation strategies for sets     751 
set.cpp, p3 
752     Sets 
set.cpp, p4 
 
 
18.4 Optimizing sets of small integers     753 
 17.4 Optimizing sets of small integers 
"
set,"The code for 
these operators appears in Figure 17-4. 
 
 
18.3 Implementation strategies for sets     749 
set.cpp, p1 
750     Sets 
set.cpp, p2 
 
18.3 Implementation strategies for sets     751 
set.cpp, p3 
752     Sets 
set.cpp, p4 
 
 
18.4 Optimizing sets of small integers     753 
 17.4 Optimizing sets of small integers 
"
set,"That implementation, however, can be improved substantially for sets whose values 
are represented internally as small integers, such as enumeration types or characters. 
 
"
set,"Characteristic vectors 
Suppose for the moment that you are working with a set whose elements always lie 
between 0 and RANGE_SIZE – 1, where RANGE_SIZE is a constant that specifies the 
size of the range to which element values are restricted.  "
set,"You can represent such sets 
efficiently using an array of Boolean values.  "
set,"The value at index position k in the 
array indicates whether the integer k is in the set.  "
set,"For example, if elements[4] 
has the value true, then 4 is in the set represented by the Boolean array elements.  
"
set,"Similarly, if elements[5] is false, then 5 is not an element of that set. 
 
"
set,"Boolean arrays in which the elements indicate whether the corresponding index 
is a member of some set are called characteristic vectors.  "
set,"The following examples 
illustrate how the characteristic-vector strategy can be used to represent the 
indicated sets, assuming that RANGE_SIZE has the value 10: 
 
 
 
 
 
 
 
The advantage of using characteristic vectors is that doing so makes it possible 
to implement the operations add, remove, and contains in constant time.  "
set,"For 
example, to add the element k to a set, all you have to do is set the element at index 
position k in the characteristic vector to true.  "
set,"For 
example, to add the element k to a set, all you have to do is set the element at index 
position k in the characteristic vector to true.  "
set,"To reduce the 
storage requirements, you can pack the elements of the characteristic vector into 
754     Sets 
machine words so that the representation uses every bit in the underlying 
representation.  "
set,"To understand how characteristic vectors can be packed into an array of machine 
words, imagine that you want to represent the integer set consisting of the ASCII 
code for the alphabetic characters.  "
set,"That set, which consists of the 26 uppercase 
letters with codes between 65 and 90 and the 26 lowercase letters with codes 
between 97 and 122, can be encoded as the following characteristic vector: 
 
 
 
If you want to find the bit that corresponds to a particular integer value, the simplest 
approach is to use integer division and modular arithmetic.  "
set,"Thus, the bit in the characteristic vector 
corresponding to the character 'X' is the one highlighted in this diagram: 
 
 
 
The fact that the highlighted bit is a 1 indicates that 'X' is a member of the set. 
 
 
18.4 Optimizing sets of small integers     755 
Bitwise operators 
"
set,"Thus, the bit in the characteristic vector 
corresponding to the character 'X' is the one highlighted in this diagram: 
 
 
 
The fact that the highlighted bit is a 1 indicates that 'X' is a member of the set. 
 
 
18.4 Optimizing sets of small integers     755 
Bitwise operators 
"
set,"Thus, if 
you apply the & operator to the bit patterns in x and y, you get this result: 
 
 
 
756     Sets 
The | and ^ operators produce the following results: 
 
 
 
 
 
"
set,"18.4 Optimizing sets of small integers     757 
Implementing characteristic vectors 
"
set,"<< k % BITS_PER_LONG; 
} 
 
Suppose, for example, that you call testBit(cv, 'X'), where cv is bound to 
the characteristic vector corresponding to the set of all alphabetic characters.  "
set,"As 
758     Sets 
discussed in the section on “Packed arrays of bits” earlier in the chapter, that 
characteristic vector looks like this: 
 
 
 
The function testBit begins by choosing the appropriate word in the characteristic 
vector by evaluating the expression 
 
cv.words[k / BITS_PER_LONG]; 
 
The subscript expression k / BITS_PER_LONG determines the index of the word in 
the characteristic vector that contains the kth bit in the entire structure.  "
set,"By convention, assigning the value 1 to a 
specific bit is called setting that bit; assigning the value 0 is called clearing that bit.  
"
set,"You can set a particular bit in a word by applying the logical OR operation to the old 
 
18.4 Optimizing sets of small integers     759 
value of that word and a mask containing the desired bit.  "
set,"You can set a particular bit in a word by applying the logical OR operation to the old 
 
18.4 Optimizing sets of small integers     759 
value of that word and a mask containing the desired bit.  "
set,"k >= RANGE_SIZE) { 
      error(""setBit: Bit index is out of range""); 
   } 
   cv.words[k / BITS_PER_LONG] &= ~createMask(k); 
} 
 
Implementing the high-level set operations 
"
set,"As it happens, this same strategy also improves the efficiency of the high-level set 
operations of union, intersection, and set difference.  "
set,"As it happens, this same strategy also improves the efficiency of the high-level set 
operations of union, intersection, and set difference.  "
set,"As an example, the union of two sets consists of all elements that belong to 
either of its arguments.  "
set,"If you translate this idea into the realm of characteristic 
vectors, it is easy to see that any word in the characteristic vector of the set A !"
set,"B 
can be computed by applying the logical OR operation to the corresponding words in 
the characteristic vectors for those sets.  "
set,"Template specialization 
The characteristic vector model allows sets of characters to be implemented much 
more efficiently than more general sets in terms of both space and time.  "
set,"Template specialization 
The characteristic vector model allows sets of characters to be implemented much 
more efficiently than more general sets in terms of both space and time.  "
set,"At the 
same time, it doesn’t make sense for the client to learn two different models for sets: 
one for characters and one for everything else.  "
set,"760     Sets 
C++ allows you to define template classes in which you specify particular values 
for one or more of the template parameters of a more general type.  "
set,"As an example, suppose that you wanted to define—as you will have a chance to 
do in exercise 8—a specialized implementation for the class Set<char> that uses a 
characteristic vector to store the data.  "
set,"The interface version of that class would look 
like this: 
 
template <> 
class Set<char> { 
   class body for character sets 
}; 
 
The empty template brackets tell the compiler that this version of the Set class is 
still defined as a template, but that there is no type variable for a client-specified 
type.  "
set,"The interface version of that class would look 
like this: 
 
template <> 
class Set<char> { 
   class body for character sets 
}; 
 
The empty template brackets tell the compiler that this version of the Set class is 
still defined as a template, but that there is no type variable for a client-specified 
type.  "
set,"The interface version of that class would look 
like this: 
 
template <> 
class Set<char> { 
   class body for character sets 
}; 
 
The empty template brackets tell the compiler that this version of the Set class is 
still defined as a template, but that there is no type variable for a client-specified 
type.  "
set,The value type for this version of Set is always char.  
set,"The 
constructor for the Set<char> class will therefore have the following stucture: 
 
template <> 
Set<char>::Set { 
   implementation of the character set constructor 
}; 
 
The private section and the implementation of the Set<char> class and the 
more general Set<ValueType> will certainly be different because those classes 
use different data models.  "
set,"The 
constructor for the Set<char> class will therefore have the following stucture: 
 
template <> 
Set<char>::Set { 
   implementation of the character set constructor 
}; 
 
The private section and the implementation of the Set<char> class and the 
more general Set<ValueType> will certainly be different because those classes 
use different data models.  "
set,"The 
constructor for the Set<char> class will therefore have the following stucture: 
 
template <> 
Set<char>::Set { 
   implementation of the character set constructor 
}; 
 
The private section and the implementation of the Set<char> class and the 
more general Set<ValueType> will certainly be different because those classes 
use different data models.  "
set,"The 
constructor for the Set<char> class will therefore have the following stucture: 
 
template <> 
Set<char>::Set { 
   implementation of the character set constructor 
}; 
 
The private section and the implementation of the Set<char> class and the 
more general Set<ValueType> will certainly be different because those classes 
use different data models.  "
set,"The 
constructor for the Set<char> class will therefore have the following stucture: 
 
template <> 
Set<char>::Set { 
   implementation of the character set constructor 
}; 
 
The private section and the implementation of the Set<char> class and the 
more general Set<ValueType> will certainly be different because those classes 
use different data models.  "
set,"But what would happen if you wanted 
to use this technique to streamline the class Set<int>?  "
set,"Even if characteristic vectors cannot represent all sets of integers, they can still 
be useful as long as the actual values in the set fall into a limited range.  "
set,"Even if characteristic vectors cannot represent all sets of integers, they can still 
be useful as long as the actual values in the set fall into a limited range.  "
set,"Clients who need to define sets containing integers 
outside the optimal range can nonetheless use the same interface. 
 
 "
set,"Summary 
In this chapter, you have learned about sets, which are important to computer 
science as both a theoretical and a practical abstraction.  "
set,"The fact that sets have a 
well-developed mathematical foundation—far from making them too abstract to be 
useful—increases their utility as a programming tool.  "
set,"Because of that theoretical 
foundation, you can count on sets to exhibit certain properties and obey specific 
rules.  "
set,"By coding your algorithms in terms of sets, you can build on that same 
theoretical base to write programs that are easier to understand. 
 
"
set,"Important points in this chapter include: 
 
• A set is an unordered collection of distinct elements.  "
set,"The set operations used in 
this book appear in Table 17-3, along with their mathematical symbols. 
"
set,"The interactions among the various set operators are often easier to understand if 
you keep in mind certain identities that indicate that two set expressions are 
invariably equal.  "
set,"The interactions among the various set operators are often easier to understand if 
you keep in mind certain identities that indicate that two set expressions are 
invariably equal.  "
set,"Using these identities can also improve your programming 
practice, because they provide you with tools to simplify set operations 
appearing in your code. 
"
set,"The set class is straightforward to implement because much of it can be layered 
on top of the Map class, using either the tree-based or hash-based representation. 
"
set,"762     Sets 
• Sets of integers can be implemented very efficiently using arrays of Boolean 
data called characteristic vectors.  "
set,"762     Sets 
• Sets of integers can be implemented very efficiently using arrays of Boolean 
data called characteristic vectors.  "
set,"If you use the bitwise operators provided by 
C++, you can pack characteristic vectors into a small number of machine words 
and perform such set operations as union and intersection on many elements of 
the vector at a time. 
 
 "
set,"True or false: The elements of a set are unordered, so the set {3, 2, 1} and the 
set {1, 2, 3} represent the same set. 
 
"
set,"True or false: The elements of a set are unordered, so the set {3, 2, 1} and the 
set {1, 2, 3} represent the same set. 
 
"
set,"True or false: The elements of a set are unordered, so the set {3, 2, 1} and the 
set {1, 2, 3} represent the same set. 
 
"
set,"True or false: The elements of a set are unordered, so the set {3, 2, 1} and the 
set {1, 2, 3} represent the same set. 
 
"
set,"2. 
True or false: A set can contain multiple copies of the same element. 
 
"
set,"What sets are denoted by each of the following symbols: !, Z, N, and R? 
 
4. 
"
set,"5. 
Use an enumeration to specify the elements of the following set: 
 
{x | x "" N  and  x ! 100  and
 "" N} 
 
6. 
Write a rule-based definition for the following set: 
 
{0, 9, 18, 27, 36, 45, 54, 63, 72, 81} 
 
7. 
"
set,"5. 
Use an enumeration to specify the elements of the following set: 
 
{x | x "" N  and  x ! 100  and
 "" N} 
 
6. 
Write a rule-based definition for the following set: 
 
{0, 9, 18, 27, 36, 45, 54, 63, 72, 81} 
 
7. 
"
set,"What are the mathematical symbols for the operations union, intersection, and 
set difference? 
 
"
set,"8. 
Evaluate the following set expressions: 
 
a. 
{a, b, c} $ {a, c, e} 
b. 
{a, b, c} % {a, c, e} 
c. 
{a, b, c} – {a, c, e} 
d. 
({a, b, c} – {a, c, e}) $ ({a, b, c} – {a, c, e}) 
 
9. 
"
set,"Give an example of an infinite set that is a proper subset of some other infinite 
set. 
 
11."
set,"Give an example of an infinite set that is a proper subset of some other infinite 
set. 
 
11."
set,"For each of the following set operations, draw Venn diagrams whose shaded 
regions illustrate the contents of the specified set expression: 
 
a. 
"
set,"For each of the following set operations, draw Venn diagrams whose shaded 
regions illustrate the contents of the specified set expression: 
 
a. 
"
set,"Write set expressions that describe the shaded region in each of the following 
Venn diagrams: 
 
a. 
 
b. 
 
 
13."
set,"What is the cardinality of a set? 
 
15."
set,"The general implementation of the Set class uses a data structure from an 
earlier chapter to represent the elements of a set.  "
set,"The general implementation of the Set class uses a data structure from an 
earlier chapter to represent the elements of a set.  "
set,"What restrictions must be placed on a set in order to use characteristic vectors 
as an implementation strategy? 
 
"
set,"Assuming that RANGE_SIZE has the value 10, diagram the characteristic vector 
for the set {1, 4, 9}. 
 
"
set,"What set is represented by the following characteristic vector: 
 
 
 
By consulting the ASCII chart in Table 1-2, identify the function in <cctype> 
to which this set corresponds. 
 
"
set,"What set is represented by the following characteristic vector: 
 
 
 
By consulting the ASCII chart in Table 1-2, identify the function in <cctype> 
to which this set corresponds. 
 
"
set,"764     Sets 
21."
set,"b. Set the bit in x corresponding to the bit in mask. 
"
set,"To make it easier to write programs that use the Set class, it would be useful 
for the set.h interface to export an overloaded version of the >> operator to 
read sets from an input stream.  "
set,"To make it easier to write programs that use the Set class, it would be useful 
for the set.h interface to export an overloaded version of the >> operator to 
read sets from an input stream.  "
set,"In particular, 
the >> operator should require the elements of the set to be enclosed in curly 
braces and separated by commas. 
 
 
"
set,"Exercises     765 
2. 
Write a simple test program that uses the >> operator from the preceding 
exercise to read in two sets of strings and then display the result of calling the 
union, intersection, and set difference operators on those sets.  "
set,"Exercises     765 
2. 
Write a simple test program that uses the >> operator from the preceding 
exercise to read in two sets of strings and then display the result of calling the 
union, intersection, and set difference operators on those sets.  "
set,"Exercises     765 
2. 
Write a simple test program that uses the >> operator from the preceding 
exercise to read in two sets of strings and then display the result of calling the 
union, intersection, and set difference operators on those sets.  "
set,"Write a function 
 
Set<int> createPrimeSet(int max) 
 
that returns a set of the prime numbers between 2 and max.  "
set,"Write a function 
 
Set<int> createPrimeSet(int max) 
 
that returns a set of the prime numbers between 2 and max.  "
set,"The only numbers you need to check are the prime numbers between 2 
and the square root of N.  As it tests whether a number is prime, your code 
should make use of the fact that all potential factors must be in the set of primes 
you have already constructed. 
 
"
set,"The discussion in the chapter only sketches the implementation of the Set 
class.  "
set,"Complete the Set class by supplying the private section that defines the 
structure of a set and the code that implements the Set class as a layered 
abstraction on top of the tree-based version of maps. 
 
"
set,"Complete the Set class by supplying the private section that defines the 
structure of a set and the code that implements the Set class as a layered 
abstraction on top of the tree-based version of maps. 
 
"
set,"Complete the Set class by supplying the private section that defines the 
structure of a set and the code that implements the Set class as a layered 
abstraction on top of the tree-based version of maps. 
 
"
set,"As discussed in the chapter, the library implementation of sets uses balanced 
binary search trees to ensure that iterating over the set produces the keys in 
sorted order.  "
set,"As discussed in the chapter, the library implementation of sets uses balanced 
binary search trees to ensure that iterating over the set produces the keys in 
sorted order.  "
set,"766     Sets 
The operation of this program is illustrated by the following sample run: 
 
 
 
7. 
"
set,"8. 
Implement a template specialization of the Set<char> class that uses a 
characteristic vector instead of the usual binary tree. 
 
"
set,"9. 
Implement a template specialization of the Set<int> class that uses a 
characteristic vector as long as the elements are in the range 0 to 255 but that 
switches to the traditional representation if the client adds elements outside this 
range. 
 
 
 
 
 
 
 
 
"
set,"Yea, from Delos up to Limerick and back! 
— Rudyard Kipling, “The Song of the Banjo,” 1894 
768     Graphs 
Many structures in the real world consist of a set of values connected by a set of 
links.  "
set,"Yea, from Delos up to Limerick and back! 
— Rudyard Kipling, “The Song of the Banjo,” 1894 
768     Graphs 
Many structures in the real world consist of a set of values connected by a set of 
links.  "
set,"Because they consist of nodes connected by a set of links, graphs are clearly 
similar to trees, which were introduced in Chapter 16.  "
set,"Mathematicians, for example, use the tools of set theory to define a 
graph as the combination of two sets, which are typically called V and E after the 
mathematical terms vertex and edge.  "
set,"Mathematicians, for example, use the tools of set theory to define a 
graph as the combination of two sets, which are typically called V and E after the 
mathematical terms vertex and edge.  "
set,"Using this convention, the airline graph 
consists of the following sets: 
 
"
set,"V = { Atlanta, Boston, Chicago, Dallas, Denver, Los Angeles, 
New York, Portland, San Francisco, Seattle } 
E = { Atlanta!Chicago, Atlanta!Dallas, Atlanta!New York, 
Boston!New York, Boston!Seattle, Chicago!Denver, 
Dallas!Denver, Dallas!Los Angeles, Dallas!San Francisco, 
Denver!San Francisco, Portland!San Francisco, 
Portland!Seattle } 
 
Beyond its theoretical significance as a mathematical formalism, defining a 
graph in terms of sets also simplifies the implementation, because the Set class 
already implements many of the necessary operations."
set,"V = { Atlanta, Boston, Chicago, Dallas, Denver, Los Angeles, 
New York, Portland, San Francisco, Seattle } 
E = { Atlanta!Chicago, Atlanta!Dallas, Atlanta!New York, 
Boston!New York, Boston!Seattle, Chicago!Denver, 
Dallas!Denver, Dallas!Los Angeles, Dallas!San Francisco, 
Denver!San Francisco, Portland!San Francisco, 
Portland!Seattle } 
 
Beyond its theoretical significance as a mathematical formalism, defining a 
graph in terms of sets also simplifies the implementation, because the Set class 
already implements many of the necessary operations."
set,Portland in the set of arcs.  
set,"Given any unconnected graph, you can always decompose it into a unique set of 
subgraphs in which each subgraph is connected, but no arcs lead from one subgraph 
to another.  "
set,"• Storing the connections for each node as a set of arcs. 
 
"
set,"Representing connections using a set of arcs 
"
set,"The motivation behind the third strategy for representing connections in a graph 
comes from the mathematical formulation of a graph as a set of nodes coupled with 
a set of arcs.  "
set,"The motivation behind the third strategy for representing connections in a graph 
comes from the mathematical formulation of a graph as a set of nodes coupled with 
a set of arcs.  "
set,"If you were content to store no information with each node other than 
its name, you could define a graph as a pair of sets, as follows: 
 
struct StringBasedGraph { 
   Set<string> nodes; 
   Set<string> arcs; 
}; 
 
The set of nodes contains the names of every node in the graph.  "
set,"If you were content to store no information with each node other than 
its name, you could define a graph as a pair of sets, as follows: 
 
struct StringBasedGraph { 
   Set<string> nodes; 
   Set<string> arcs; 
}; 
 
The set of nodes contains the names of every node in the graph.  "
set,"If you were content to store no information with each node other than 
its name, you could define a graph as a pair of sets, as follows: 
 
struct StringBasedGraph { 
   Set<string> nodes; 
   Set<string> arcs; 
}; 
 
The set of nodes contains the names of every node in the graph.  "
set,"If you were content to store no information with each node other than 
its name, you could define a graph as a pair of sets, as follows: 
 
struct StringBasedGraph { 
   Set<string> nodes; 
   Set<string> arcs; 
}; 
 
The set of nodes contains the names of every node in the graph.  "
set,"The set of arcs 
contains pairs of node names connected in some way that makes it easy to separate 
the node names representing the beginning and end of each arc. 
 
"
set,"As 
in the mathematical definition of a graph, a SimpleGraph contains two sets: one 
that specifies the nodes in the graph and one that specifies the arcs.  "
set,"18.3 A low-level graph abstraction      777 
• A structure type called Node that contains the name of the node and a set that 
indicates which arcs extend from that node to other nodes in the graph. 
"
set,"The SimpleGraph structure 
conceptually “contains” Node values not only as part of its set of nodes but also as 
components of the elements in the set of arcs.  "
set,"The SimpleGraph structure 
conceptually “contains” Node values not only as part of its set of nodes but also as 
components of the elements in the set of arcs.  "
set,"Similarly, Arc values appear in two 
places because both the SimpleGraph and Node structure specify a set of arcs.  "
set,"For 
example, the Node corresponding to Atlanta must be the same Node no matter 
whether it appears in the top-level set of nodes or in one of the internal arcs.  "
set,"The critical implication of this observation is that the sets and structures used to 
represent the graph cannot contain Node and Arc values directly.  "
set,"The sets in the SimpleGraph structure, 
therefore, must use Node * and Arc * as their element type and not the underlying 
structure types themselves.  "
set,"The same is true for the set of arcs in the Node structure 
and the references to nodes in the Arc structure.  "
set,Defining graphs in terms of sets has many advantages.  
set,"In particular, this 
strategy means that the data structure closely parallels the mathematical formulation 
of a graph, which is defined in terms of sets.  "
set,"For example, 
defining graphs in terms of set seliminates the need to define a separate iteration 
facility for graphs, because sets already support iteration.  "
set,"For example, 
defining graphs in terms of set seliminates the need to define a separate iteration 
facility for graphs, because sets already support iteration.  "
set,"In addition to simplifying the process of iteration, defining graphs in terms of sets 
makes it possible to apply higher-level set operations like union and intersection.  
"
set,"In addition to simplifying the process of iteration, defining graphs in terms of sets 
makes it possible to apply higher-level set operations like union and intersection.  
"
set,"The sets on 
which the graph is built are, at least in their mathematical form, unordered 
collections.  "
set,"As you will see in 
Chapter 20, it is possible to extend the definition of the Set class so that its 
clients—like the Graph class in this example—can redefine the order in which 
elements appear. 
 
 
"
set,"18.4 Graph traversals      783 
 18.4  Graph traversals 
As you saw in the preceding example, it is easy to cycle through the nodes in a 
graph, as long as you are content to process the nodes in the order imposed by the 
set abstraction.  "
set,"To do so, the 
implementations in the next two sections define a set of nodes called visited to 
keep track of the nodes that have already been processed. 
 
"
set,"In this implementation, depthFirstSearch is a wrapper function whose only 
purpose is to introduce the visited set used to keep track of nodes that have 
already been processed.  "
set,"The call to the depthFirstSearch function itself creates an empty visited set 
and then hands control off to the recursive visitUsingDFS function.  "
set,"18.4 Graph traversals      787 
That marking process is analogous to the visited set in the depth-first search 
implementation. 
 
"
set,"To 
understand why, it is important to note that graphs are typically used in a way that 
differs from the more familiar container classes such as arrays, stacks, queues, and 
sets.  "
set,"In this text, for example, you have seen programs that declare variables of 
type Stack<double> and Set<string>.  "
set,"Nodes, for example, 
must keep track of the set of arcs to other nodes; arcs need to keep track of their 
endpoints.  "
set,"Thus, the type the client chooses to represent a node must contain 
 
• A string field called name that specifies the name of the node 
• A field called arcs that specifies the set of arcs that begin at this node 
 
The type chosen to represent an arc must contain 
 
• Fields called start and finish that indicate the endpoints of the arc 
 
Beyond the required fields, the types used to represent nodes and arcs may contain 
additional information required for the client’s application. 
 
"
set,"Thus, the 
elements in the set of arcs contained in each node must be pointers to the client’s arc 
type.  "
set,"The private section of the Graph class requires the sets of nodes and arcs, along 
with a map to translate node names into the corresponding node structures.  "
set,"The implementation for the 
Graph class is simpler than that of the other collection classes, given that much of 
the complexity has been shifted to the Set and Map classes on which Graph is 
based.  "
set,"Summary 
This chapter has introduced you to the idea of a graph, which is defined as a set of 
nodes linked together by a set of arcs that connect individual pairs of nodes.  "
set,"Summary 
This chapter has introduced you to the idea of a graph, which is defined as a set of 
nodes linked together by a set of arcs that connect individual pairs of nodes.  "
set,"Like 
sets, graphs are not only important as a theoretical abstraction, but also as a tool for 
solving practical problems that arise in many application domains.  "
set,"The graph.h interface can be implemented easily by layering it on top of the set 
package.  "
set,"Suppose that the computer science offerings at some university consisted of 
eight courses with the following prerequisite structure: 
 
 
 
Using the mathematical formulation for graphs described in this chapter, 
define this graph as a pair of sets. 
 
"
set,"Why do the sets used in either version of the graph.h interface use pointers 
to arcs and nodes as their element types? 
 
"
set,"Several important graph algorithms operate on a special class of graphs in 
which the nodes can be divided into two sets in such a way that all the arcs 
connect nodes in different sets, with none of the arcs running between nodes in 
the same set.  "
set,"Several important graph algorithms operate on a special class of graphs in 
which the nodes can be divided into two sets in such a way that all the arcs 
connect nodes in different sets, with none of the arcs running between nodes in 
the same set.  "
set,"Several important graph algorithms operate on a special class of graphs in 
which the nodes can be divided into two sets in such a way that all the arcs 
connect nodes in different sets, with none of the arcs running between nodes in 
the same set.  "
set,"If your goal is to 
find a set of arcs that connects the nodes of a graph at a minimum cost, you 
might as well leave such edges out.  "
set,"A dominating set of a graph is a subset of the nodes such that those nodes 
along with their immediate neighbors constitute all graph nodes.  "
set,"That is, 
every node in the graph is either in the dominating set or is a neighbor of a 
node in the dominating set.  "
set,"That is, 
every node in the graph is either in the dominating set or is a neighbor of a 
node in the dominating set.  "
set,"In the graph diagrammed below—in which each 
node is labeled with the number of neighbors to facilitate tracing the 
algorithm—the filled-in nodes constitute a dominating set for the graph.  "
set,"Other 
dominating sets are also possible. 
 
 
 
 
"
set,"Exercises      821 
Ideally, you would like to be able to find the smallest possible dominating set, 
but that is known to be a computationally difficult task—too expensive for 
most graphs.  "
set,"The following algorithm usually finds a relatively small 
dominating set, even though it does not always produce the optimal result: 
 
1. 
"
set,"Start with an empty set S. 
2. 
Consider each graph node in order of decreasing degree.  "
set,"Write a template function 
 
template <NodeType,ArcType> 
Set<NodeType *> 
   findDominatingSet(Graph<NodeType,ArcType> & g); 
 
that uses this algorithm to find a small dominating set for the graph g. 
 
15."
set,"Write a template function 
 
template <NodeType,ArcType> 
Set<NodeType *> 
   findDominatingSet(Graph<NodeType,ArcType> & g); 
 
that uses this algorithm to find a small dominating set for the graph g. 
 
15."
set,"Figure 19-2 shows the basic skeleton for a set of class definitions based on the 
classes in the Employee hierarchy.  "
set,"That level exports methods that apply to all 
shapes, such as setting their location in the window or changing their color.  "
set,"The initializer list appears just before the brace that begins the 
body of the constructor and is set off from the parameter list by a colon.  "
set,"By applying rule #4 two more times to take care of the remaining operators, you can 
show that the entire set of characters is indeed an expression, as follows: 
 
 
 
As you can see, this diagram forms a tree.  "
set,A set of getter methods that return parts of the expression structure.  
set,"In the context of a programming 
language, a grammar consists of a set of rules that show how a particular language 
construct can be derived from simpler ones. 
 
"
set,"On this cycle, however, the 
868     Inheritance 
precedence of + is greater than the precedence in effect at this level set by the 
assignment operator.  "
set,"The 
parser therefore exits from the while loop, leading to the following configuration: 
 
 
 
When control returns to the first readE call, all the necessary information is now 
in place, as follows: 
 
 
 
All readE has to do is create the new compound and—after reading the empty 
token one more time—return the final version of the expression tree to parseExp: 
 
 
 
870     Inheritance 
 19.5 Multiple inheritance 
One of the features that sets C++ apart from most other object-oriented languages is 
that classes can inherit behavior from more than one superclass.  "
set,"All you need to do is 
write the value of x to an output stream after setting the precision to the desired 
number of digits and then read that same value back to convert it to its numeric 
form.  "
set,"Parsing consists of translating the 
collection of tokens returned from the lexical analysis phase into its internal 
representation, following a set of syntactic rules called a grammar. 
"
set,"In a recursive-descent parser, the rules of the grammar 
are encoded as a set of mutually recursive functions. 
"
set,"Thus, mapAll invokes the callback 
function in index order for a Vector, in row-major order for a Grid, in alphabetical 
order for a Lexicon, in ascending key order for a Map, and in ascending value order 
for a Set. 
 
"
set,"For example, if you define the function 
 
bool lessIgnoringCase(string s1, string s2) { 
   return toLowerCase(s1) < toLowerCase(s2); 
} 
 
you can sort the string vector names without regard to case by calling 
 
sort(names.begin(), names.end(), lessIgnoringCase()); 
 
In much the same way, you can sort the string vector words from shortest to longest 
by defining the function 
 
bool isShorter(string s1, string s2) { 
   return s1.length() < s2.length(); 
} 
 
and then calling 
 
sort(words.begin(), names.end(), isShorter()); 
 
You can also pass a comparison function to the constructors for the Map and Set 
classes to define the order in which elements appear.  "
set,"The begin 
function in the Vector class needs to return an iterator in which the variable vp 
points to the vector itself and the variable index is set to 0.  "
set,"The end function must 
return an iterator in which vp is initialized in the same way and the variable index 
is set to the number of elements in the vector, which is stored in the variable count.  
"
set,"In C++, the syntax for iterators is based on pointer arithmetic and uses the same 
set of operators.  "
set,"Not all iterators, however, support the full set of operators that 
apply to pointers.  "
set,"• Comparison functions make it possible to specify new ordering relationships for 
the functions in the <algorithm> library and for collection classes like Map and 
Set, which need to determine the relative order of elements. 
"
set,"920     Strategies for Iteration 
 Review questions 
1. 
Suppose that you have a Set<int> variable called primes.  "
set,"List the complete set of operators implemented by an iterator offering the 
RandomAccessIterator level of service. 
 
"
set,"In the implementation of the Set class presented in Figure 17-4, the code for 
the == operator for sets uses the mathematical principle that two sets are equal 
if and only if each set is a subset of the other.  "
set,"In the implementation of the Set class presented in Figure 17-4, the code for 
the == operator for sets uses the mathematical principle that two sets are equal 
if and only if each set is a subset of the other.  "
set,"In the implementation of the Set class presented in Figure 17-4, the code for 
the == operator for sets uses the mathematical principle that two sets are equal 
if and only if each set is a subset of the other.  "
set,"In the implementation of the Set class presented in Figure 17-4, the code for 
the == operator for sets uses the mathematical principle that two sets are equal 
if and only if each set is a subset of the other.  "
set,"A 
faster way to test whether two sets are equal is to check whether you get 
exactly the same values if you iterate through both sets. 
 
"
set,"A 
faster way to test whether two sets are equal is to check whether you get 
exactly the same values if you iterate through both sets. 
 
"
set,"The only problem you have to tackle before you try to solve this problem is 
that the Set implementation from Chapter 17 doesn’t include an iterator.  "
set,"You can therefore create the 
necessary iterators from the map instance variable in each set.  "
set,"Given the 
arcane rules for declarations involving template classes in C++, the 
declarations of Map iterators inside the Set class need to be marked with the 
typename keyword, leading to declarations like this: 
 
typename Map<ValueType,bool>"
queue," implementation of queues 
"
queue,"In light of the fact that actions in a queue are no longer confined to one end of an 
array, you need two indices to keep track of the head and tail positions in the queue.  
"
queue,"In light of the fact that actions in a queue are no longer confined to one end of an 
array, you need two indices to keep track of the head and tail positions in the queue.  
"
queue,"The private instance variables therefore look like this: 
 
ValueType *array; 
int capacity; 
int head; 
int tail; 
 
In this representation, the head field holds the index of the next element to come 
out of the queue, and the tail field holds the index of the next free slot.  "
queue,"In an 
empty queue, it is clear that the tail field should be 0 to indicate the initial 
position in the array, but what about the head field?  "
queue,"When queues are defined in this way, 
having the head and tail fields be equal indicates that the queue is empty. 
 
 
"
queue,"When queues are defined in this way, 
having the head and tail fields be equal indicates that the queue is empty. 
 
 
"
queue,"Implementing queues      635 
queue.h, p1 
636     Linear Structures 
queue.h, p2 
 
14.3 Implementing queues      637 
Given this representation strategy, the Queue constructor looks like this: 
 
template <typename ValueType> 
Queue<ValueType>::Queue() { 
    head = tail = 0; 
} 
"
queue,"Implementing queues      635 
queue.h, p1 
636     Linear Structures 
queue.h, p2 
 
14.3 Implementing queues      637 
Given this representation strategy, the Queue constructor looks like this: 
 
template <typename ValueType> 
Queue<ValueType>::Queue() { 
    head = tail = 0; 
} 
"
queue,"Implementing queues      635 
queue.h, p1 
636     Linear Structures 
queue.h, p2 
 
14.3 Implementing queues      637 
Given this representation strategy, the Queue constructor looks like this: 
 
template <typename ValueType> 
Queue<ValueType>::Queue() { 
    head = tail = 0; 
} 
"
queue,"Implementing queues      635 
queue.h, p1 
636     Linear Structures 
queue.h, p2 
 
14.3 Implementing queues      637 
Given this representation strategy, the Queue constructor looks like this: 
 
template <typename ValueType> 
Queue<ValueType>::Queue() { 
    head = tail = 0; 
} 
"
queue,"As is often the 
case in programming, it makes more sense to begin by drawing diagrams to make 
sure you understand exactly how the queue should operate before you turn to the 
implementation. 
 
"
queue,"To get a sense of how this representation of a queue works, imagine that the 
queue represents a waiting line, similar to one in the simulation from Chapter 5.  
From time to time, a new customer arrives and is added to the queue.  "
queue,"To get a sense of how this representation of a queue works, imagine that the 
queue represents a waiting line, similar to one in the simulation from Chapter 5.  
From time to time, a new customer arrives and is added to the queue.  "
queue,"To get a sense of how this representation of a queue works, imagine that the 
queue represents a waiting line, similar to one in the simulation from Chapter 5.  
From time to time, a new customer arrives and is added to the queue.  "
queue,"Customers 
waiting in line are periodically served at the head end of the queue, after which they 
leave the waiting line entirely.  "
queue,"How does the queue data structure respond to each 
of these operations? 
 
"
queue,"Assuming that the queue is empty at the beginning, its internal structure looks 
like this: 
 
 
 
Suppose now that five customers arrive, indicated by the letters A through E.  Those 
customers are enqueued in order, which gives rise to the following configuration: 
 
 
 
The value 0 in the head field indicates that the first customer in the queue is stored 
in position 0 of the array; the value 5 in tail indicates that the next customer will 
be placed in position 5.  "
queue,"Assuming that the queue is empty at the beginning, its internal structure looks 
like this: 
 
 
 
Suppose now that five customers arrive, indicated by the letters A through E.  Those 
customers are enqueued in order, which gives rise to the following configuration: 
 
 
 
The value 0 in the head field indicates that the first customer in the queue is stored 
in position 0 of the array; the value 5 in tail indicates that the next customer will 
be placed in position 5.  "
queue,"At this point, suppose that you alternately 
serve a customer at the beginning of the queue and then add a new customer to the 
end.  "
queue,"The internal structure 
of the queue then looks like this: 
 
 
 
At this point, you’ve got a bit of a problem.  "
queue,"There are only five customers in the 
queue, but you have used up all the available space.  "
queue,"Thus, instead of incrementing tail so that it indicates the 
nonexistent position 10, you can “wrap around” from the end of the array back to 
position 0, as follows: 
 
 
 
From this position, you have space to enqueue customer K in position 0, which 
leads to the following configuration: 
 
 
 
If you allow the elements in the queue to wrap around from the end of the array to 
the beginning, the active elements always extend from the head index up to the 
position immediately preceding the tail index, as illustrated in this diagram: 
 
 
 
 
14.3 Implementing queues      639 
Because the ends of the array act as if they were joined together, programmers call 
this representation a ring buffer. 
 
"
queue,"Thus, instead of incrementing tail so that it indicates the 
nonexistent position 10, you can “wrap around” from the end of the array back to 
position 0, as follows: 
 
 
 
From this position, you have space to enqueue customer K in position 0, which 
leads to the following configuration: 
 
 
 
If you allow the elements in the queue to wrap around from the end of the array to 
the beginning, the active elements always extend from the head index up to the 
position immediately preceding the tail index, as illustrated in this diagram: 
 
 
 
 
14.3 Implementing queues      639 
Because the ends of the array act as if they were joined together, programmers call 
this representation a ring buffer. 
 
"
queue,"The only remaining issue you need to consider before you can write the code for 
enqueue and dequeue is how to check whether the queue is completely full.  
"
queue,Testing for a full queue is trickier than you might expect.  
queue,The queue array is now completely full.  
queue,"Unfortunately, whenever the head and 
tail fields have the same value, as they do in this diagram, the queue is considered 
to be empty.  "
queue,"There is no way to tell from the contents of the queue structure itself 
which of the two conditions—empty or full—actually applies, because the data 
values look the same in each case.  "
queue,"Although you can fix this problem by adopting a 
different definition for the empty queue and writing some special-case code, the 
simplest approach is to limit the number of elements in the queue to one less than 
the capacity and to expand the array whenever that limit is reached. 
 
"
queue,"Although you can fix this problem by adopting a 
different definition for the empty queue and writing some special-case code, the 
simplest approach is to limit the number of elements in the queue to one less than 
the capacity and to expand the array whenever that limit is reached. 
 
"
queue,"The code for the ring-buffer implementation of the Queue class template appears 
in Figures 14-7 and 14-8.  "
queue,"640     Linear Structures 
array queuepriv.h 
 
14.3 Implementing queues      641 
array queue-impl, p1 
642     Linear Structures 
array queue-impl, p2 
 
14.3 Implementing queues      643 
array queue-impl, p3 
644     Linear Structures 
Linked-list representation of queues 
The queue class also has a simple representation using list structure.  "
queue,"640     Linear Structures 
array queuepriv.h 
 
14.3 Implementing queues      641 
array queue-impl, p1 
642     Linear Structures 
array queue-impl, p2 
 
14.3 Implementing queues      643 
array queue-impl, p3 
644     Linear Structures 
Linked-list representation of queues 
The queue class also has a simple representation using list structure.  "
queue,"640     Linear Structures 
array queuepriv.h 
 
14.3 Implementing queues      641 
array queue-impl, p1 
642     Linear Structures 
array queue-impl, p2 
 
14.3 Implementing queues      643 
array queue-impl, p3 
644     Linear Structures 
Linked-list representation of queues 
The queue class also has a simple representation using list structure.  "
queue,"640     Linear Structures 
array queuepriv.h 
 
14.3 Implementing queues      641 
array queue-impl, p1 
642     Linear Structures 
array queue-impl, p2 
 
14.3 Implementing queues      643 
array queue-impl, p3 
644     Linear Structures 
Linked-list representation of queues 
The queue class also has a simple representation using list structure.  "
queue,"640     Linear Structures 
array queuepriv.h 
 
14.3 Implementing queues      641 
array queue-impl, p1 
642     Linear Structures 
array queue-impl, p2 
 
14.3 Implementing queues      643 
array queue-impl, p3 
644     Linear Structures 
Linked-list representation of queues 
The queue class also has a simple representation using list structure.  "
queue,"640     Linear Structures 
array queuepriv.h 
 
14.3 Implementing queues      641 
array queue-impl, p1 
642     Linear Structures 
array queue-impl, p2 
 
14.3 Implementing queues      643 
array queue-impl, p3 
644     Linear Structures 
Linked-list representation of queues 
The queue class also has a simple representation using list structure.  "
queue,"640     Linear Structures 
array queuepriv.h 
 
14.3 Implementing queues      641 
array queue-impl, p1 
642     Linear Structures 
array queue-impl, p2 
 
14.3 Implementing queues      643 
array queue-impl, p3 
644     Linear Structures 
Linked-list representation of queues 
The queue class also has a simple representation using list structure.  "
queue,"To illustrate 
the basic approach, the elements of the queue are stored in a list beginning at the 
head of the queue and ending at the tail.  "
queue,"To illustrate 
the basic approach, the elements of the queue are stored in a list beginning at the 
head of the queue and ending at the tail.  "
queue,"To allow both enqueue and dequeue to 
run in constant time, the Queue object must keep a pointer to both ends of the 
queue.  "
queue,"To allow both enqueue and dequeue to 
run in constant time, the Queue object must keep a pointer to both ends of the 
queue.  "
queue,"Here, for example, is a 
somewhat more readable picture of a queue containing the customers A, B, and C: 
 
 
 
"
queue,"The code for the linked-list implementation of queues appears in Figure 14-10.  
"
queue,"The diagram of the internal 
structure provides the essential insights you need to understand how to implement 
each of the queue operations.  "
queue,"The only place where the implementation gets tricky is in the representation of 
the empty queue.  "
queue,"The most straightforward approach is to indicate an empty queue 
by storing NULL in the head pointer, as follows: 
 
 
 
 
"
queue,"14.3 Implementing queues      645 
list queuepriv.h 
646     Linear Structures 
list-impl, p1 
 
14.3 Implementing queues      647 
list-impl, p2 
648     Linear Structures 
"
queue,"14.3 Implementing queues      645 
list queuepriv.h 
646     Linear Structures 
list-impl, p1 
 
14.3 Implementing queues      647 
list-impl, p2 
648     Linear Structures 
"
queue,The enqueue implementation must check for the empty queue as a special case.  
queue,"Thus, if you were to enqueue 
the customer A into an empty queue, the internal structure of the pointers at the end 
of the enqueue operation would look like this: 
 
 
14.4 Implementing vectors      649 
 
 
If you make another call to enqueue, the head pointer is no longer NULL, which 
means that the implementation no longer has to perform the special-case action for 
the empty queue.  "
queue,"Thus, if you were to enqueue 
the customer A into an empty queue, the internal structure of the pointers at the end 
of the enqueue operation would look like this: 
 
 
14.4 Implementing vectors      649 
 
 
If you make another call to enqueue, the head pointer is no longer NULL, which 
means that the implementation no longer has to perform the special-case action for 
the empty queue.  "
queue,"In many respects, the implementation of the Vector class is a combination of the 
editor buffer from Chapter 13 and the stack and queue abstractions you have seen in 
this chapter.  "
queue,"At the 
same time, Vector resembles the Stack and Queue classes by implementing deep 
copying and by using templates to support polymorphism. 
 
"
queue,"You have 
also had the chance to see array- and list-based implementations of the Stack and 
Queue classes, along with the public interface for a polymorphic Vector class. 
 
"
queue,"The array-based implementation of queues is somewhat more complex than its 
stack counterpart.  "
queue,"In the ring-buffer implementation used in this chapter, a queue is considered 
empty when its head and tail indices are the same.  "
queue,"This representation strategy 
means that the maximum capacity of the queue is one element less than the 
allocated size of the array.  "
queue,"Attempting to fill all the elements in the array makes 
a full queue indistinguishable from an empty one. 
"
queue,"• Queues can also be represented using a linked list marked by two pointers, one 
to the head of the queue and another to the tail. 
"
queue,"• Queues can also be represented using a linked list marked by two pointers, one 
to the head of the queue and another to the tail. 
"
queue,"If you use an array to store the underlying elements in a queue, what are the 
Queue class private instance variables? 
 
5. 
"
queue,"If you use an array to store the underlying elements in a queue, what are the 
Queue class private instance variables? 
 
5. 
"
queue,"How does the ring-buffer concept apply to queues? 
 
 
"
queue,How can you tell if an array-based queue is empty?  
queue,"7. 
Assuming that INITIAL_CAPACITY has the artificially small value of 3, draw 
a diagram showing the underlying representation of the array-based queue 
myQueue after the following sequence of operations: 
 
Queue<char> myQueue; 
myQueue.enqueue('A'); 
myQueue.enqueue('B'); 
myQueue.enqueue('C'); 
myQueue.dequeue(); 
myQueue.dequeue(); 
myQueue.enqueue('D'); 
myQueue.enqueue('E'); 
myQueue.dequeue(); 
myQueue.enqueue('F'); 
 
8. 
Explain how modular arithmetic is useful in the array-based implementation of 
queues. 
 
"
queue,"7. 
Assuming that INITIAL_CAPACITY has the artificially small value of 3, draw 
a diagram showing the underlying representation of the array-based queue 
myQueue after the following sequence of operations: 
 
Queue<char> myQueue; 
myQueue.enqueue('A'); 
myQueue.enqueue('B'); 
myQueue.enqueue('C'); 
myQueue.dequeue(); 
myQueue.dequeue(); 
myQueue.enqueue('D'); 
myQueue.enqueue('E'); 
myQueue.dequeue(); 
myQueue.enqueue('F'); 
 
8. 
Explain how modular arithmetic is useful in the array-based implementation of 
queues. 
 
"
queue,"7. 
Assuming that INITIAL_CAPACITY has the artificially small value of 3, draw 
a diagram showing the underlying representation of the array-based queue 
myQueue after the following sequence of operations: 
 
Queue<char> myQueue; 
myQueue.enqueue('A'); 
myQueue.enqueue('B'); 
myQueue.enqueue('C'); 
myQueue.dequeue(); 
myQueue.dequeue(); 
myQueue.enqueue('D'); 
myQueue.enqueue('E'); 
myQueue.dequeue(); 
myQueue.enqueue('F'); 
 
8. 
Explain how modular arithmetic is useful in the array-based implementation of 
queues. 
 
"
queue,"9. 
Describe what is wrong with the following implementation of size for the 
array-based representation of queues: 
 
template <typename ValueType> 
int Queue<ValueType>::size() const { 
    return (tail - head) % capacity; 
} 
 
 
10."
queue,"9. 
Describe what is wrong with the following implementation of size for the 
array-based representation of queues: 
 
template <typename ValueType> 
int Queue<ValueType>::size() const { 
    return (tail - head) % capacity; 
} 
 
 
10."
queue,"Draw a diagram showing the internal structure of a linked-list queue after the 
computer finishes the set of operations in question 7. 
 
11."
queue,"How can you tell if a linked-list queue is empty? 
 
12."
queue,"Because the ring-buffer implementation of queues makes it impossible to tell 
the difference between an empty queue and one that is completely full, the 
capacity of the queue is one less than the allocated size of the array.  "
queue,"Because the ring-buffer implementation of queues makes it impossible to tell 
the difference between an empty queue and one that is completely full, the 
capacity of the queue is one less than the allocated size of the array.  "
queue,"Because the ring-buffer implementation of queues makes it impossible to tell 
the difference between an empty queue and one that is completely full, the 
capacity of the queue is one less than the allocated size of the array.  "
queue,"You can 
avoid this restriction by changing the internal representation so that the 
concrete structure of the queue keeps track of the number of elements in the 
queue instead of the index of the tail element.  "
queue,"You can 
avoid this restriction by changing the internal representation so that the 
concrete structure of the queue keeps track of the number of elements in the 
queue instead of the index of the tail element.  "
queue,"Given the index of the head 
element and the number of data values in the queue, you can easily calculate 
the tail index, which means that you don’t need to store this value explicitly.  
"
queue,"Rewrite the array-based queue representation so that it uses this representation. 
 
"
queue,"In exercise 13 from Chapter 5, you had the opportunity to write a function 
 
void reverseQueue(Queue<string> & queue); 
 
that reverses the elements in the queue, working entirely from the client side.  
"
queue,"In exercise 13 from Chapter 5, you had the opportunity to write a function 
 
void reverseQueue(Queue<string> & queue); 
 
that reverses the elements in the queue, working entirely from the client side.  
"
queue,"For both the array- and 
 
Exercises      661 
list-based implementations of the queue, make all the changes necessary to 
export the method 
 
void reverse(); 
 
that reverses the elements in the queue.  "
queue,"For both the array- and 
 
Exercises      661 
list-based implementations of the queue, make all the changes necessary to 
export the method 
 
void reverse(); 
 
that reverses the elements in the queue.  "
queue,"In the queue abstraction presented in this chapter, new items are always added 
at the end of the queue and wait their turn in line.  "
queue,"In the queue abstraction presented in this chapter, new items are always added 
at the end of the queue and wait their turn in line.  "
queue,"For some programming 
applications, it is useful to extend the simple queue abstraction into a priority 
queue, in which the order of the items is determined by a numeric priority 
value.  "
queue,"For some programming 
applications, it is useful to extend the simple queue abstraction into a priority 
queue, in which the order of the items is determined by a numeric priority 
value.  "
queue,"When an item is enqueued in a priority queue, it is inserted in the list 
ahead of any lower priority items.  "
queue,"If two items in a queue have the same 
priority, they are processed in the standard first-in/first-out order. 
 
"
queue,"Using the linked-list implementation of queues as a model, design and 
implement a pqueue.h interface that exports a class called PriorityQueue, 
which exports the same methods as the traditional Queue class with the 
exception of the enqueue method, which now takes an additional argument, 
as follows: 
 
void enqueue(ValueType value, double priority); 
 
"
queue,"Using the linked-list implementation of queues as a model, design and 
implement a pqueue.h interface that exports a class called PriorityQueue, 
which exports the same methods as the traditional Queue class with the 
exception of the enqueue method, which now takes an additional argument, 
as follows: 
 
void enqueue(ValueType value, double priority); 
 
"
queue,"As in the ring-buffer implementation of queues in 
Chapter 14, if the index advances past the end of the array, it should wrap 
around back to the beginning.  "
queue,"One particularly useful 
application arises in the implementation of priority queues, in which the order in 
which elements are dequeued depends on a numeric priority.  "
queue,"This class operates identically to the standard Queue 
class with the exception of the enqueue method, which takes a second argument 
indicating the priority, as follows: 
 
void enqueue(ValueType element, double priority); 
 
As in conventional English usage, smaller priority numbers come first in the queue, 
so that elements entered with priority 1 are processed before any elements with 
priority 2.  "
queue,"This class operates identically to the standard Queue 
class with the exception of the enqueue method, which takes a second argument 
indicating the priority, as follows: 
 
void enqueue(ValueType element, double priority); 
 
As in conventional English usage, smaller priority numbers come first in the queue, 
so that elements entered with priority 1 are processed before any elements with 
priority 2.  "
queue,"By entering each path into the queue using its total distance as a priority 
value, each call to dequeue returns the shortest path remaining in the queue. 
 
"
queue,"By entering each path into the queue using its total distance as a priority 
value, each call to dequeue returns the shortest path remaining in the queue. 
 
"
queue,"You can 
improve the performance of the priority queue package to O(log N) by using a data 
structure called a partially ordered tree, in which the following properties hold: 
 
1. 
"
queue,"The operations that define the partially ordered tree are precisely the ones you 
need to implement priority queues.  "
queue,"Thus, if you use partially ordered trees as the 
underlying representation, you can implement the priority queue package so that it 
runs in O(log N) time. 
 
"
queue,"Although you can implement partially ordered trees using a pointer-based 
structure, most implementations of priority queues employ an array-based structure 
called a heap, which is an array-based structure that simulates the operation of a 
partially ordered tree.  "
queue,"Implementing the heap-based priority queue is an excellent exercise that will 
sharpen your programming skills and give you more experience working with many 
of the data structures you have seen in this text.  "
queue,"• Priority queues can be implemented efficiently using a data structure called a 
heap, which is based on a special class of binary tree called a partially ordered 
tree.  "
queue,"The next phase visits the nodes that are one hop away, as follows: 
 
 
 
From here, the algorithm goes on to explore the nodes that are two hops away: 
 
788     Graphs 
 
 
In the final phase, the algorithm completes its exploration of the graph by visiting 
the nodes that are three hops from the start: 
 
 
 
The easiest way to implement the breadth-first algorithm is to use a queue of 
unprocessed nodes.  "
queue,"Because the queue is processed in order, all nodes that are one hop 
away from the starting node will appear earlier in the queue than nodes that are two 
hops away, and so forth.  "
queue,"Because the queue is processed in order, all nodes that are one hop 
away from the starting node will appear earlier in the queue than nodes that are two 
hops away, and so forth.  "
queue,"To 
understand why, it is important to note that graphs are typically used in a way that 
differs from the more familiar container classes such as arrays, stacks, queues, and 
sets.  "
queue,"The variable queue is a queue of paths, ordered so that paths in the queue are 
sorted in order if increasing cost.  "
queue,"The variable queue is a queue of paths, ordered so that paths in the queue are 
sorted in order if increasing cost.  "
queue,"The variable queue is a queue of paths, ordered so that paths in the queue are 
sorted in order if increasing cost.  "
queue,"This queue therefore differs from the 
first-in/first-out discipline of traditional queues and is instead a priority queue, 
in which the client can specify a priority value for each element.  "
queue,"This queue therefore differs from the 
first-in/first-out discipline of traditional queues and is instead a priority queue, 
in which the client can specify a priority value for each element.  "
queue,"This queue therefore differs from the 
first-in/first-out discipline of traditional queues and is instead a priority queue, 
in which the client can specify a priority value for each element.  "
queue,"This class operates 
identically to the standard Queue class with the exception of the enqueue 
method, which takes a second argument indicating the priority, as follows: 
 
void enqueue(ValueType element, double priority); 
 
 
As in conventional English usage, smaller priority numbers come first in the 
queue, so that elements entered with priority 1 are processed before any elements 
with priority 2.  "
queue,"This class operates 
identically to the standard Queue class with the exception of the enqueue 
method, which takes a second argument indicating the priority, as follows: 
 
void enqueue(ValueType element, double priority); 
 
 
As in conventional English usage, smaller priority numbers come first in the 
queue, so that elements entered with priority 1 are processed before any elements 
with priority 2.  "
queue,"By entering each path into the queue using its total distance as a 
priority value, each call to dequeue returns the shortest path remaining in the 
queue.  "
queue,"By entering each path into the queue using its total distance as a 
priority value, each call to dequeue returns the shortest path remaining in the 
queue.  "
queue,"Whenever a path 
is dequeued from the priority queue, you know the path must indicate the 
shortest route to the node at the end of that path, unless you have already found a 
shorter path ending at that node.  "
queue,"Thus, whenever you dequeue a path from the 
priority queue, you can note that its distance is now known by storing the 
minimum distance in the map fixed. 
 
"
queue,"The first path to Boston stored in the priority queue is the one that goes through 
Portland and Seattle, which is not the shortest available path.  "
queue,"Boston 
path is still in the priority queue when the algorithm finishes its operation. 
"
queue,"Show the contents of the priority queue at each step of the trace of Dijkstra’s 
algorithm shown in Figure 18-8. 
 
24."
queue,"3. Push its neighbors on the stack 
 
 
Exercises      817 
4. 
Take your solution from the preceding exercise and replace the stack with a 
queue.  "
queue,"The implementation of breadth-first search given in the chapter generates the 
correct traversal but ends up adding a large number of unnecessary paths to the 
queue.  "
queue,"The problem is that the code adds new paths to the queue even when 
the final node in the chain has already been visited, which means that it will 
simply be ignored whenever that path is removed from the queue.  "
queue,"The problem is that the code adds new paths to the queue even when 
the final node in the chain has already been visited, which means that it will 
simply be ignored whenever that path is removed from the queue.  "
queue,"You can fix 
this problem simply by checking to see whether the final node has been visited 
before adding it to the queue. 
 
"
queue,"Your program 
should keep track of both the average queue length during the execution of the 
algorithm and the total running time necessary to visit each of the nodes. 
 
"
stack,"Although it is tempting to think that the enqueue and dequeue methods will 
look almost exactly like their push and pop counterparts in the Stack class, you 
will run into several problems if you try to copy the existing code.  "
stack,"On the whole, the code is reasonably straightforward, particularly if you use the 
linked-list implementation of stacks as a model.  "
stack,"In many respects, the implementation of the Vector class is a combination of the 
editor buffer from Chapter 13 and the stack and queue abstractions you have seen in 
this chapter.  "
stack,"At the 
same time, Vector resembles the Stack and Queue classes by implementing deep 
copying and by using templates to support polymorphism. 
 
"
stack,"You have 
also had the chance to see array- and list-based implementations of the Stack and 
Queue classes, along with the public interface for a polymorphic Vector class. 
 
"
stack,"658     Linear Structures 
• Stacks can be implemented using a linked-list structure in addition to the more 
traditional array-based representation. 
"
stack,"The array-based implementation of queues is somewhat more complex than its 
stack counterpart.  "
stack,"3. 
Using the linked-list implementation, draw a diagram of the cells used to 
represent myStack after the following operations have been performed: 
 
Stack<char> myStack; 
myStack.push('A'); 
myStack.push('B'); 
myStack.push('C'); 
 
4. 
"
stack,"4. 
Develop a reasonably comprehensive unit test for the stack.h interface that 
tests the operations exported by the Stack class using stacks with several 
different base types.  "
stack,"4. 
Develop a reasonably comprehensive unit test for the stack.h interface that 
tests the operations exported by the Stack class using stacks with several 
different base types.  "
stack,"Use your unit test program to validate both the array- and 
list-based implementations of the Stack class. 
 
"
stack,"Suppose, for example, that you have declared and initialized an empty tree as 
follows: 
 
BSTNode *dwarfTree = NULL; 
 
These statements create a local variable dwarfTree that lives in the stack frame of 
the function that contains its declaration, as illustrated by the following diagram: 
 
 
 
What happens if you then call 
 
insertNode(dwarfTree, ""Grumpy""); 
 
starting with this initial configuration in which dwarfTree is empty?  "
stack,"The stack at the beginning of this call therefore looks like 
this: 
 
 
 
  The first step in the code checks if t is set to NULL, which is true is this case, so it 
executes the body of the if statement, which begins with the line 
 
t = new BSTNode; 
 
700     Trees 
This line allocates a new node on the heap and assigns it to the reference parameter 
t, therefore changing the pointer cell in the caller, as follows: 
 
 
 
The remaining statements initialize the fields in the new node, copying the key 
Grumpy and initializing each of the subtree pointers to NULL.  "
stack,"As 
before, the initial call generates a stack frame in which the reference parameter t is 
aliased to dwarfTree: 
 
 
 
This time, however, the value of the tree t is no longer NULL, since the variable 
dwarfTree now contains the address of the Grumpy node.  "
stack,"To 
understand why, it is important to note that graphs are typically used in a way that 
differs from the more familiar container classes such as arrays, stacks, queues, and 
sets.  "
stack,"In this text, for example, you have seen programs that declare variables of 
type Stack<double> and Set<string>.  "
stack,"3. 
Eliminate the recursion from the implementation of depthFirstSearch by 
using a stack to store the unexplored nodes.  "
stack,"At the beginning of the algorithm, 
you simply push the starting node on the stack.  "
stack,"Then, until the stack is empty, 
you repeat the following operations: 
 
1."
stack,"Pop the topmost node from the stack. 
"
stack,"3. Push its neighbors on the stack 
 
 
Exercises      817 
4. 
Take your solution from the preceding exercise and replace the stack with a 
queue.  "
stack,"3. Push its neighbors on the stack 
 
 
Exercises      817 
4. 
Take your solution from the preceding exercise and replace the stack with a 
queue.  "
stack,"In C++, local variables are always allocated on the stack, even if they are 
instances of a class type.  "
stack,"To create the stack frame, the compiler must know how 
much space to allocate for each of the local variables.  "
stack,"Thus, the picture of the stack frame 
containing these two variables will look something like this: 
 
 
 
830     Inheritance 
In C++, assigning one object to another—in the absence of a new definition of 
assignment—is implemented by copying all the fields.  "
stack,"As it is implemented in the Stanford libraries, the error 
844     Inheritance 
function generates a signal that something is amiss, making it possible for other 
functions within the program—as long as they appear somewhere in the chain of 
function calls that preceded the error condition and therefore still have a frame on 
the control stack—to respond to that condition.  "
stack,"The syntactic pattern used to throw an exception is simply 
 
throw value; 
 
When this statement appears inside any function nested within the try, the program 
stops executing the current function and climbs back up the chain of function calls, 
popping and discarding stack frames until it reaches the frame containing the try 
statement.  "
stack,"The stack frame underneath this one keeps track of what the 
parser was doing prior to making the recursive call. 
 
"
stack,"Although the interpreter program that appears in this chapter is considerably 
easier to implement than a complete compiler, it is possible to get a sense of 
how a compiler works by defining one for a simplified computer system called 
a stack machine.  "
stack,"A stack machine performs operations on an internal stack, 
which is maintained by the hardware, in much the same fashion as the Reverse 
Polish calculator from Chapter 5.  "
stack,"A stack machine performs operations on an internal stack, 
which is maintained by the hardware, in much the same fashion as the Reverse 
Polish calculator from Chapter 5.  "
stack,"For the hypothetical stack machine used in 
this problem, the available instructions appear in Figure 19-19. 
 
Write a function 
 
void compile(istream & infile, ostream & outfile); 
 
that reads expressions from infile and writes to outfile a sequence of 
instructions for the stack machine that have the same effect as evaluating each 
 
Exercises      883 
of the expressions in the input file and displaying their result.  "
stack,"For the hypothetical stack machine used in 
this problem, the available instructions appear in Figure 19-19. 
 
Write a function 
 
void compile(istream & infile, ostream & outfile); 
 
that reads expressions from infile and writes to outfile a sequence of 
instructions for the stack machine that have the same effect as evaluating each 
 
Exercises      883 
of the expressions in the input file and displaying their result.  "
stack,"Keeping track of that state 
will require you to maintain a stack of as-yet-unvisited nodes. 
 
"
Trees,"The resulting picture looks like this: 
 
 
 
704     Trees 
Tree traversals 
The structure of a binary search tree makes it easy to go through the nodes of the 
tree in the order specified by the keys.  "
Trees,"
 
708     Trees 
Tree-balancing strategies 
Binary search trees are useful in practice only if it is possible to avoid the 
worst-case behavior associated with unbalanced trees.  "
Trees,"724     Trees 
 Review questions 
1. 
"
Algorithms,"Algorithms for maintaining balance in a binary tree have been studied 
extensively in computer science.  "
Algorithms,"18.7 Algorithms for searching the web 
As noted in the introduction to this chapter, the web is a graph in which the nodes 
are the individual pages and the arcs are the hyperlinks that take you from one page 
to another.  "
Algorithms,"18.7 Algorithms for searching the web      809 
"
Algorithms,"The probability of reaching node A after following one 
random link is therefore one-half times the chance of being at C plus one-third times 
the chance of being at D.  If you express this calculation as a formula using primed 
letters to indicating probabilities on the next cycle, the result looks like this: 
 
 
 
 
18.7 Algorithms for searching the web      811 
A similar analysis yields the following formulas for the other pages in the graph: 
 
 
 
Each iteration of the PageRank algorithm replaces the probabilities for the pages 
A, B, C, D, and E with the values A!, B!, C!, D!, and E! computed by these formulae.  
"
